<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Roy Blog</title>
  <icon>https://www.gravatar.com/avatar/0564578760656ea13d584c96ba9a60c0</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shs400.github.io/"/>
  <updated>2020-01-03T06:26:12.404Z</updated>
  <id>http://shs400.github.io/</id>
  
  <author>
    <name>shs400</name>
    <email>tlagustn88@naver.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KotlinJS 를 시작해보자 ( setting &amp; hello world )</title>
    <link href="http://shs400.github.io/2020/01/02/kotlin01/"/>
    <id>http://shs400.github.io/2020/01/02/kotlin01/</id>
    <published>2020-01-02T04:34:17.000Z</published>
    <updated>2020-01-03T06:26:12.404Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="why-kotlin"><a href="#why-kotlin" class="headerlink" title="why? kotlin?"></a>why? kotlin?</h1><p>왜? 코틀린을 시작했는가?<br>실은 코틀린에 대해 잘몰랐었고, 안드로이드 언어이다. 정도? 만 가볍게 들어봤을뿐 거의 모르고있었고,<br>그냥 kotlinJS라는 이름만보고 JS코드를 작성하면 Kotlin 언어로 컴파일해주는것인가? 라고 잘못된 생각만을 가지고 있었습니다.<br>알고보니 코틀린은 멀티플랫폼 언어였고, 제가 보았던 KotlinJS는 kotlin이란 새로운 언어를 작성한후 javascript로 컴파일 해 주는 것이였습니다.<br>그리고 이왕 알아보기 시작한거 javascript 외의 다른 언어도 한번 공부해보자로 시작하여 코틀린에 대해 공부하기 시작하였습니다.</p><h1 id="Kotlin-or-KotlinJS란"><a href="#Kotlin-or-KotlinJS란" class="headerlink" title="Kotlin or KotlinJS란"></a>Kotlin or KotlinJS란</h1><p>코틀린은 자바 플랫폼에서 동작하는 프로그래밍 언어이고,<br>자바를 완전히 대체할 수 있는 언어가 되는 것이 코틀린의 주목적이라고 합니다.</p><p>자바와 같이 코틀린은 정적 타입의 프로그래밍 언어입니다.<br>정적 타입 지정은 프로그램의 모든 구성 요소의 타입이 컴파일 되는 시점에 알 수 있고, 컴파일러가 타입을 검증해준다는 것 입니다.<br>그중 코틀린 컴파일러는 자바와 다르게 문맥으로 변수의 타입을 자동으로 유추 할 수 있기 때문에 직접 명시를 해주지 않아도 된다고 합니다.<br>이런 기능을 타입 추론이라고 합니다.</p><p>ex)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val name = &apos;Roy&apos; // -&gt; == val name:String = &apos;Roy&apos;</span><br></pre></td></tr></table></figure></p><p>코틀린은 안드로이드 스튜디오 개발사인 Jet Brains에서 2011년에 공개한 언어인데<br>Google I/O 2017에서 안드로이드의 공식 개발언어가 되었고, Google I/O 2019에서는 kotlin First를 언급하여 코틀린을 최우선으로 사용하겠다고 언급하였습니다.<br><a href="https://developers-kr.googleblog.com/2019/05/google-io-2019-empowering-developers-to-build-experiences-on-Android-Play.html" target="_blank" rel="noopener">참조 - Google Developers 국문 블로그</a><br><img src="/images/kotlin/kotlinstudy01-1.jpeg" alt="kotlin"></p><p>또한 안드로이드 스튜디오로 모든 플렛폼개발이 가능하도록 개발중이라고 언급하였기 때문에 ios개발도 곧 가능할것이라 추측됩니다.</p><p>코틀린이라 하면 안드로이드나 자바를 생각하게 되는데,<br>코틀린은 플랫폼 중립적인 언어로 설계 되어있기때문에 다양한 환경에서 사용할 수 있습니다.</p><p><img src="/images/kotlin/kotlinstudy01-2.png" alt="kotlin"><br>현재는 JVM, Android, Browser, Native 코드를 작성할 수 있고,<br>자바스크립트대신 사용할 수 있는 코틀린 JS에 대해 설명하려고 합니다.</p><h2 id="Gradle-Project"><a href="#Gradle-Project" class="headerlink" title="Gradle Project"></a>Gradle Project</h2><p>본격적으로 시작하기에 앞서 Gradle Project에 대해 간단히 설명하겠습니다.</p><p>Gradle설정을 무엇으로 정하냐에 따라<br>c,자바,코틀린등을 컴파일을 할 수 있는 범용적인 빌드 프로젝트를 이야기합니다.<br>앤트(Ant), 그래이들(Gradle), 메이븐(Maven)등 여러 빌드툴중에 그래이들을 이용하여 빌드퇴는 프로젝트를 Gradle Project라고 합니다.</p><p>특징: 계층 구조로 구성이 가능합니다.</p><p>단점: 같은 계층내의 자식만 모듈간의 의존성을 설정 가능합니다.</p><p><img src="/images/kotlin/kotlinstudy01-3.png#left" alt="kotlin"></p><p>예를 들어 <code>A</code>와 <code>B</code>는 같은 계층이기 때문에 모둘간의 의존성을 설정 가능하지만<br><code>A-1</code>과 <code>B</code>는 의존성 설정이 불가능 하게 됩니다.<br>물론 <code>A-1</code>과 <code>B</code>의 의존성을 가지게하려면 복잡한 path 설정이 필요하므로 현재 내용에서는 다루지 않도록 하겠습니다.</p><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>이제 처음으로 기본적인 hello world를 콘솔로 찍어볼텐데,<br>모든 개발의 시작은 환경 설절이므로 제일 먼저 환경 설정을 해보도록 하겠습니다.<br>Jet Brains에서 공개한 언어이기 때문에 툴은 Intellij를 사용하겠습니다.</p><p><img src="/images/kotlin/kotlinstudy01-3.png#left" alt="kotlin"></p><p>우선 새 프로젝트를 구성하는데<br>보통 실제 프로젝트는 단일 모듈로 만들지 않고 다수의 모듈을 갖게됩니다. 또한 목적파일 하나당 별도의 모듈이 필요하게됩니다.</p><p>ex) app.js : app기능 , lib.js :  lib기능 이 필요하다면 목적파일 하나당 하나의 모듈이 필요한것입니다.</p><p>이렇게 만든 <code>app.js(A)</code>와 <code>lib.js(B)</code>를 의존성을 갖게하기 위해 상위 부모에 root모듈을 만들어줍니다.<br>(root모듈은 그냥 빈 그래이들 모듈상태로 A모듈과 B모듛의 의존성을 만들어주기위한 부모라고 생각하시면 됩니다.)</p><p><img src="/images/kotlin/kotlinstudy01-4.png#left" alt="kotlin"><br>먼저 new Project를 만들어주시고 의존성을 위한 빈 root 모듈을 만들어줍니다.</p><p>그 후 root모둘의 자식으로 app모듈과 lib 모듈을 만들어주게 되면 </p><p><img src="/images/kotlin/kotlinstudy01-5.png#left" alt="kotlin"><br><img src="/images/kotlin/kotlinstudy01-6.png#left" alt="kotlin"><br><img src="/images/kotlin/kotlinstudy01-7.png#left" alt="kotlin"></p><p>위와같은 구조의 app 모듈이 root모듈의 자식으로 생성되게됩니다.<br>(동일하게 lib 모듈도 생성해줍니다.)</p><p>참고로 인텔리제이에서는 모듈마다 build.gradle이 자동 생성되는데 해당 코드는 잘못된? 예전? 코드이기 때문에<br><a href="https://kotlinlang.org/docs/tutorials/javascript/getting-started-gradle/getting-started-with-gradle.html" target="_blank" rel="noopener">코틀린 공식 홈페이지</a>의 Getting Started를 참고하셔서 아래와 같이 내용을 변경하시면 됩니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">group &apos;org.example&apos;</span><br><span class="line">version &apos;1.0-SNAPSHOT&apos;</span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version = &apos;1.3.61&apos;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &apos;kotlin2js&apos;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &quot;org.jetbrains.kotlin:kotlin-stdlib-js:$kotlin_version&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>그리고 추가로 하단에있는 코드를 build.gradle에 추가해주면됩니다.<br>( 공식 사이트에는 File file로 되어있는데 File 삭제 )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">task assembleWeb(type: Sync) &#123;</span><br><span class="line">    configurations.compile.each &#123; file -&gt;</span><br><span class="line">        from(zipTree(file.absolutePath), &#123;</span><br><span class="line">            includeEmptyDirs = false</span><br><span class="line">            include &#123; fileTreeElement -&gt;</span><br><span class="line">                def path = fileTreeElement.path</span><br><span class="line">                path.endsWith(&quot;.js&quot;) &amp;&amp; (path.startsWith(&quot;META-INF/resources/&quot;) ||</span><br><span class="line">                        !path.startsWith(&quot;META-INF/&quot;))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    from compileKotlin2Js.destinationDir</span><br><span class="line">    into &quot;$&#123;projectDir&#125;/web&quot;</span><br><span class="line"></span><br><span class="line">    dependsOn classes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assemble.dependsOn assembleWeb</span><br><span class="line"></span><br><span class="line">// assemble Task가 assembleWeb에 의존성을 갖는다. </span><br><span class="line">// (assemble이 실행되려면 반드시 assembleWeb이 실행되어야함)</span><br><span class="line">// 그리고 build는 assemble에 의존성을 갖기 때문에 </span><br><span class="line">// build를 하면 자동으로 assembleWeb 까지 실행되게 된다.</span><br></pre></td></tr></table></figure></p><p>이제 app -&gt; src -&gt; main -&gt; kotlin -&gt; main.kt 파일을 열어<br>hello world 를 작성해봅니다.<br>( kotlin은 함수를 fun으로 작성합니다. )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 기본적인 준비는 끝낫고 빌드만 하면 되게되는데 인텔리제이 오른쪽에 보이는 그래들탭을 열어주면<br><img src="/images/kotlin/kotlinstudy01-8.png#left" alt="kotlin"></p><p>위와 같은 화면이 나타나지않고 (lib는 추가하지 않았으니 없는게 맞습니다.)<br>root의 자식으로 app Task가 존재하지 않을것입니다.</p><p>이유는</p><p><img src="/images/kotlin/kotlinstudy01-9.png#left" alt="kotlin"><br>root의 settings.gradle파일에 app을 include 해주지 않았기 때문에<br>include ‘:app’을 작성해주어야 gradle에 app Task가 노출되게 됩니다.</p><p>이 후 app - Tasks - Build - build를 해주면</p><p><img src="/images/kotlin/kotlinstudy01-10.png#left" alt="kotlin"><br>app 디렉토리에 web 과 build 폴더가 생성되게 되고<br>web폴더의 kotlin.js ( 표준 라이브러리 )와 app.js가 생성되게 됩니다.</p><p>이제 index.html을 만들어 위에만든 kotlin.js와 app.js 를 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/// index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"kotlin.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/kotlin/kotlinstudy01-11.png#left" alt="kotlin"></p><p>드디어 원하던 hello world가 출력되었습니다.</p><p>이번 글에서의 내용이 여기까지이고</p><p>자세히 파일을 보신분들은 아시겠지만 빌드 후 생성된 kotlin.js 파일의 용량이 2m인것을 보셨을겁니다.<br>이는 상용 서비스에서 사용하기에는 부담스러운 용량이기 때문에 다음 글에서 kotlin-dce-js에 대해 언급하도록 하겠습니다.<br>( plugin이기 때문에 궁금하시면 검색해서 보시면됩니다. )</p><ul><li>이 글은 <a href="https://www.bsidesoft.com/" target="_blank" rel="noopener">Bsidesoft</a>의 <a href="https://www.youtube.com/watch?v=bGIPJHl2W1I" target="_blank" rel="noopener">CodeSpitz Youtube</a> 강좌를 참고하여 작성하였습니다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;why-kotlin&quot;&gt;&lt;a href=&quot;#why-kotlin&quot; class=&quot;headerlink&quot; title=&quot;why? kotlin?&quot;&gt;&lt;/a&gt;why? kotlin?&lt;/h1&gt;&lt;p&gt;왜? 코틀린을 시작했는가?&lt;br
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
      <category term="코틀린" scheme="http://shs400.github.io/categories/javascript/blog/study/%EC%BD%94%ED%8B%80%EB%A6%B0/"/>
    
      <category term="코틀린JS" scheme="http://shs400.github.io/categories/javascript/blog/study/%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%BD%94%ED%8B%80%EB%A6%B0JS/"/>
    
      <category term="kotlin" scheme="http://shs400.github.io/categories/javascript/blog/study/%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%BD%94%ED%8B%80%EB%A6%B0JS/kotlin/"/>
    
      <category term="kotlinJS" scheme="http://shs400.github.io/categories/javascript/blog/study/%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%BD%94%ED%8B%80%EB%A6%B0JS/kotlin/kotlinJS/"/>
    
      <category term="language" scheme="http://shs400.github.io/categories/javascript/blog/study/%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%BD%94%ED%8B%80%EB%A6%B0JS/kotlin/kotlinJS/language/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="study" scheme="http://shs400.github.io/tags/study/"/>
    
      <category term="kotlin" scheme="http://shs400.github.io/tags/kotlin/"/>
    
      <category term="language" scheme="http://shs400.github.io/tags/language/"/>
    
      <category term="코틀린" scheme="http://shs400.github.io/tags/%EC%BD%94%ED%8B%80%EB%A6%B0/"/>
    
      <category term="코틀린JS" scheme="http://shs400.github.io/tags/%EC%BD%94%ED%8B%80%EB%A6%B0JS/"/>
    
      <category term="kotlinJS" scheme="http://shs400.github.io/tags/kotlinJS/"/>
    
  </entry>
  
  <entry>
    <title>firebase를 시작해보자</title>
    <link href="http://shs400.github.io/2019/10/17/firebase/"/>
    <id>http://shs400.github.io/2019/10/17/firebase/</id>
    <published>2019-10-17T07:30:42.000Z</published>
    <updated>2019-10-18T01:27:29.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="firebase를-시작해보자"><a href="#firebase를-시작해보자" class="headerlink" title="firebase를 시작해보자"></a>firebase를 시작해보자</h1><h2 id="firebase란"><a href="#firebase란" class="headerlink" title="firebase란"></a>firebase란</h2><p>파이어베이스는 2011년 파이어베이스사가 개발하고 2014년 구글에 인수된 모바일 및 웹 애플리케이션 개발 플랫폼입니다. (위키백과)<br>파이어베이스는 클라우드 서비스를 제공해주며 동시에 백엔드의 기능을 가지고 있습니다.</p><p>필자가 파이어베이스를 사용하게 된 계기는 웹사이트를 만들고 싶은데 서버가 필요했고,<br>서버구축을 할줄 모르는 상태에서 파이어베이스는 호스팅, 데이터베이스, 스토리지, 인증, FCM 등을 쉽게 사용할수 있게 해기 때문에 파이어베이스를 선택하였습니다.</p><h2 id="firebase-환경-설정"><a href="#firebase-환경-설정" class="headerlink" title="firebase 환경 설정"></a>firebase 환경 설정</h2><p>1) firebase 프로젝트 만들기<br>우선 firebase를 사용하려면 당연히 <a href="https://firebase.google.com" target="_blank" rel="noopener">https://firebase.google.com</a>에 접속을 해줍니다.<br>그 후 회원가입 or 로그인을해 주시고 console(콘솔)로 이동을 해줍니다. (우측 상단에 콘솔로 이동 링크)</p><p>콘솔 페이지로 이동후 새 플젝트 만들기를 해주시면 파이어베이스 프로젝트가 생성이 완료가 됩니다. ( 프로젝트 생성되는데 약간의 시간이 걸림)<br>생성이 완료가 되면 내가 만든 프로젝트 콘솔 페이지가 아래의 그림과 같이 나타나게 됩니다.<br><img src="/images/firebase/firebase1.png" alt="firebase"></p><p>마지막으로 첫화면에서 웹앱 추가 버튼을 클릭하여<br><img src="/images/firebase/firebase2.png" alt="firebase"><br>앱 닉네임을 등록하면 나의 앱이 등록되며<br><img src="/images/firebase/firebase3.png" alt="firebase"><br>firebase SDK와 해당 앱의 firebaseConfig 값이 부여되어 보여줍니다.<br><img src="/images/firebase/firebase4.png" alt="firebase"></p><p>이제 여러분의 프로젝트에 추가할 firebase 프로젝트가 기본적으로 준비되었습니다.<br>마지막으로 SDK 추가 및 firebaseConfig 초기화에 대해 설명을 하고 기능에 대해 설명 및 사용법을 알아보겠습니다.</p><h2 id="firebase-SDK-추가-및-firebaseConfig-초기화"><a href="#firebase-SDK-추가-및-firebaseConfig-초기화" class="headerlink" title="firebase SDK 추가 및 firebaseConfig 초기화"></a>firebase SDK 추가 및 firebaseConfig 초기화</h2><p>우선 위의 환경설정 마지막에 나온 firebase SDK 및 firebaseConfig를 본인의 프로젝트에 추가 및 초기화 해주도록합니다.</p><h3 id="SDK-추가"><a href="#SDK-추가" class="headerlink" title="SDK 추가"></a>SDK 추가</h3><p>SDK를 추가하는 방식으로 </p><ol><li>호스팅 URL에서 추가</li><li>CDN에서 추가</li><li>모듈 Bundler 사용</li><li>Node.js앱 </li></ol><p>이렇게 4가지 방식이 존재하고, 이 글에서는 모듈 Bundler를 사용하여 추가 해 보도록 하겠습니다.<br>(* 환경설정 마지막에 나온 firebase SDK는 2번 방법 )</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br><span class="line">npm install --save firebase</span><br><span class="line"></span><br><span class="line"><span class="comment">// firebase 앱이 항상 필요합니다.</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> firebase <span class="keyword">from</span> <span class="string">"firebase/app"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용할 firebase 기능 추가</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"firebase/auth"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"firebase/firestore"</span>;</span><br></pre></td></tr></table></figure><h3 id="firebaseConfig-초기화"><a href="#firebaseConfig-초기화" class="headerlink" title="firebaseConfig 초기화"></a>firebaseConfig 초기화</h3><p>SDK를 추가했으면 이제 firebase의 정보를 본인의 프로젝트 정보로 초기화 해줍니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firebaseConfig = &#123;</span><br><span class="line">  apiKey: <span class="string">"xxxxxxxxxx"</span>,</span><br><span class="line">  authDomain: <span class="string">"xxxxxxxxxx.firebaseapp.com"</span>,</span><br><span class="line">  databaseURL: <span class="string">"https://xxxxxxxxxx.firebaseio.com"</span>,</span><br><span class="line">  projectId: <span class="string">"xxxxxxxxxx"</span>,</span><br><span class="line">  storageBucket: <span class="string">"xxxxxxxxxx.appspot.com"</span>,</span><br><span class="line">  messagingSenderId: <span class="string">"xxxxxxxxxx"</span>,</span><br><span class="line">  appId: <span class="string">"xxxxxxxxxx"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Initialize Firebase</span></span><br><span class="line">firebase.initializeApp(firebaseConfig);</span><br></pre></td></tr></table></figure></p><ul><li>firebaseConfig의 값은 위에서 만든 본인의 firebase앱의 정보를 넣어주면 됩니다. </li></ul><p>여기까지 되셨다면 SDK추가와 config 초기화 까지 완료된것입니다.<br>이제부터는 firebase 기능에 대하여 설명 및 사용법을 알아보겠습니다. </p><h2 id="firebase-기능"><a href="#firebase-기능" class="headerlink" title="firebase 기능"></a>firebase 기능</h2><p>이 글에서는 firebase의 기능 중<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Authentication(인증)</span><br><span class="line">2. Database(데이터베이스 - 예시는 읽기만)</span><br><span class="line">3. Storage(저장소 - 예시는 읽기만)</span><br></pre></td></tr></table></figure></p><p>3가지 기능에 대해 알아보겟습니다.</p><h3 id="Authentication-인증"><a href="#Authentication-인증" class="headerlink" title="Authentication(인증)"></a>Authentication(인증)</h3><p>파이어베이스는 인증 시스템을 지원하기때문에 로그인 기능을 추가할 수 있습니다.<br>인증방법의 종류에는 아래와 같은 인증 방법이 있습니다.</p><ul><li>이메일/비밀번호 (사용자 직접 등록)</li><li>전화</li><li>Google</li><li>Play 게임</li><li>게임센터</li><li>Facebook</li><li>Twitter</li><li>Github</li><li>Yahoo</li><li>Microsoft</li></ul><p>이 글에서는 사용자를 직업 등록하는 방법에 대해 설명하겠습니다.<br>우선 사용자 등록을 합니다.( 아주 간단합니다. )<br>자신의 firebase 프로젝트 console화면의 Authentication 탭에 들어가보면 사용자, 로그인방법, 템플릿, 사용량 이렇게 4가지의 메뉴가 존재하는데<br>사용자 탭에서 사용자를 추가해주도록합니다.</p><p><img src="/images/firebase/firebase5.png" alt="firebase"></p><p>위처럼 firebase에 로그인 아이디와 비밀번호를 입력하여 사용자를 추가한 후 로그인 방법 탭에서 이메일/비밀번호를 활성화 해준 후<br>본인의 코드에서 아래와 같이 firebase.auth().signInWithEmailAndPassword(email, pwd)를 호출해주면<br>성공시 실패시 로직을 작성할 수 있게 됩니다.<br>( firebase.auth().signInWithEmailAndPassword(email, pwd) 는 Promise 반환 )</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> firebase <span class="keyword">from</span> <span class="string">"firebase"</span>;</span><br><span class="line">firebase.auth().signInWithEmailAndPassword(email, pwd)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">firebaseUser</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'인증 성공'</span>)</span><br><span class="line">    <span class="comment">// Todo add logic</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'인증 실패 : '</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>이로써 저희는 로그인 기능을 구현할 수 있게 되었습니다.</p><h3 id="Database-데이터베이스"><a href="#Database-데이터베이스" class="headerlink" title="Database(데이터베이스)"></a>Database(데이터베이스)</h3><p>1) 실시간데이터베이스 : Firebase의 기존 데이터베이스로서, 여러 클라이언트에서 실시간으로 상태를 동기화해야 하는 모바일 앱을 위한 효율적이고 지연 시간이 짧은 솔루션입니다.<br>오프라인에도 실시간 데이터 통신을 하면서 최신상태 유지, api까지 지원해줌, 잠금모드와 테스트 모드가 있는데, 개발할때는 누구나 읽고, 쓸수있도록 테스트 모드로 하는 것을 추천합니다.<br>기본적으로 json형식으로 지원해줍니다.</p><ul><li>데이터를 하나의 큰 JSON 트리로 저장합니다.<br>– 단순한 데이터를 매우 쉽게 저장합니다.<br>– 복잡한 계층적 데이터를 대규모로 정리하기 어렵습니다.</li></ul><p>2) Cloud Firestore : </p><ul><li>데이터를 문서 컬렉션으로 저장합니다.<br>– 단순한 데이터를 JSON과 매우 비슷한 방식으로 문서에 쉽게 저장합니다.<br>– 문서 안의 하위 컬렉션을 사용하여 복잡한 계층적 데이터를 대규모로 쉽게 정리할 수 있습니다.<br>– 비정규화 및 데이터 평면화가 덜 필요합니다.</li></ul><hr><p>이외의 차이점은 <a href="https://firebase.google.com/docs/firestore/rtdb-vs-firestore?hl=ko" target="_blank" rel="noopener">https://firebase.google.com/docs/firestore/rtdb-vs-firestore?hl=ko</a> 에서 확인 하실 수 있습니다.</p><p>firestore는 실시간 데이터베이스보다 풍부하고 빠른 쿼리와 우수한 확장성을 제공한다고 나와있지만 필자는 JSON 형식으로 지원해주는 RealTime 데이터베이스를 사용하려고 합니다.<br>처음 Database 화면에 접속하면 데이터베이스 만들기 버튼 바로 보이는데 이는 FireStore 데이터베이스이고 아래쪽에 RealTime 데이터베이스가 존재합니다.</p><p><img src="/images/firebase/firebase7.png" alt="firebase"></p><p>데이터베이스를 만들때 규칙을 설정하게되는데 불러와야하기 때문에 테스트모드로 설정을 해줍니다. (규칙은 바꿀수 있음)</p><p><img src="/images/firebase/firebase8.png" alt="firebase"><br>데이터베이스의 값입력을하면 위와같은 구조로 나타나게되고 JSON구조이기 때문에 접근하기 쉬울것이라 생각됩니다.<br>(필자는 아무렇지않게 firestore를 사용해놓고 호출은 RealTime database를 호출하여 헤멘적이있는데 다른 분들은 안그러실거라 믿습니다 ㅇㅅㅇ;)</p><p>이제 위에서 입력한 값을 코드에서 가져와서 사용해보겠습니다.<br>데이터 베이스의 값을 읽고 변경사항에 대해 수신 대기하려면 firebase.atabase.Reference의 on() 또는 once() 메소드를 사용하여 이벤트를 관찰합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = firebase.database().ref(<span class="string">'/'</span>); <span class="comment">// ref('database경로'); / 가 최상위 루</span></span><br><span class="line">ref.once(<span class="string">'value'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'res : '</span>, res)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//or </span></span><br><span class="line"></span><br><span class="line">ref.on(<span class="string">'value'</span>, snapshot =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'snapshot : '</span>, snapshot)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>쓰기와 업데이트 또는 삭제관련해서는 <a href="https://firebase.google.com/docs/database/web/read-and-write?hl=ko#get_a_database_reference" target="_blank" rel="noopener">https://firebase.google.com/docs/database/web/read-and-write?hl=ko#get_a_database_reference</a>를 참고하시면 됩니다.</p><h3 id="Storage-저장소"><a href="#Storage-저장소" class="headerlink" title="Storage(저장소)"></a>Storage(저장소)</h3><p>firebase Storage<br>문서, 사진, 파일, 동영상등 각종 파일을 저장하는 곳 이라고 생각하면 됩니다.<br>개발자들이 쉽게 파일들을 업로드하고 다운로드 할 수 있도록 해줍니다.</p><p>데이터베이스와 마찬가지로 규칙을 설정해주고 Storage의 위치를 지정해줍니다.<br>그 후 Storage 화면에서 파일을 업로드 할 수 있습니다.<br><img src="/images/firebase/firebase9.png" alt="firebase"></p><p>firebase.storage().ref().child(‘root’).getDownloadURL()를 사용하여 업로드 한 이미지의 주소를 받아올 수 있습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> storage = firebase.storage().ref();</span><br><span class="line">storage.child(<span class="string">'test_img.png'</span>).getDownloadURL().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'res : '</span>, res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>추가로 파일의 업로드와 삭제에 대한 정보는<br>업로드<br><a href="https://firebase.google.com/docs/storage/web/upload-files#manage_uploads" target="_blank" rel="noopener">https://firebase.google.com/docs/storage/web/upload-files#manage_uploads</a><br>삭제<br><a href="https://firebase.google.com/docs/storage/web/delete-files?hl=ko" target="_blank" rel="noopener">https://firebase.google.com/docs/storage/web/delete-files?hl=ko</a><br>에서 확인하시면 됩니다.</p><p>이번 글에서는 firebase에 대해 간단하게 알아보았고, 현재 개인적으로 firebase를 적용하고있는 Toy Project를 진행하면서 아직 사용해보지 않은 db와 storage 쪽의 업로드 및 삭제 혹은 firebase의 추가적으로 다른 기능들까지 사용해보고 글을 쓰게 될 것 같습니다.</p><pre><code>{  &apos;level&apos;: &apos;master&apos;,  &apos;name&apos;: &apos;김대원&apos;,  &apos;alias&apos;: &apos;원바&apos;,  &apos;age&apos;: 32,  &apos;avility&apos;: {    &apos;수비&apos;: 1.4,    &apos;피지컬&apos;: 0.4,    &apos;스피드&apos;: 0.9,    &apos;창조력&apos;: 1.1,    &apos;공격&apos;: 1,    &apos;기술&apos;: 1,    &apos;제공권&apos;: 0.2,    &apos;정신&apos;: 0.5  },  &apos;img&apos;: &apos;https://firebasestorage.googleapis.com/v0/b/fsa-project-60f97.appspot.com/o/wonba_slice.jpg?alt=media&amp;token=b2c0292b-7238-4ee3-8222-0a687f6aa6c8&apos;,  &apos;intro&apos;: &apos;하고싶은 말 - 원래 바보&apos;,  &apos;contact&apos;: &apos;010-0000-0000&apos;},{  level: &apos;member&apos;,  name: &apos;김태양&apos;,  alias: &apos;매탱&apos;,  age: &apos;32&apos;,  avility: {    수비: 1.24,    피지컬: 2.11,    스피드: 0.11,    창조력: 0.31,    공격: 1.03,    기술: 0.44,    제공권: 0.33,    정신: 0.72  },  img: &apos;https://firebasestorage.googleapis.com/v0/b/fsa-project-60f97.appspot.com/o/taeng_slice.jpg?alt=media&amp;token=eeba83dc-26a5-453a-b5b9-639d33f9f01f&apos;,  intro: &apos;하고싶은말 - 탱탱한 매탱&apos;,  contact: &apos;010-0000-0000&apos;},{  level: &apos;member&apos;,  name: &apos;박원일&apos;,  alias: &apos;박양&apos;,  age: &apos;32&apos;,  avility: {    수비: 0,    피지컬: 0,    스피드: 0,    창조력: 0,    공격: 0,    기술: 0,    제공권: 0,    정신: 0  },  img: &apos;https://firebasestorage.googleapis.com/v0/b/fsa-project-60f97.appspot.com/o/parkyang.jpeg?alt=media&amp;token=3e54dc99-0397-4315-84b3-775dff2800db&apos;,  intro: &apos;하고싶은말 - 야이 C XXXXXX&apos;,  contact: &apos;010-0000-0000&apos;},{  level: &apos;member&apos;,  name: &apos;권세완&apos;,  alias: &apos;권세&apos;,  age: &apos;32&apos;,  avility: {    수비: 0,    피지컬: 0,    스피드: 0,    창조력: 0,    공격: 0,    기술: 0,    제공권: 0,    정신: 0  },  img: &apos;https://firebasestorage.googleapis.com/v0/b/fsa-project-60f97.appspot.com/o/gwonse.jpeg?alt=media&amp;token=df4ab5ee-048d-40ae-ae80-d26baa861a1c&apos;,  intro: &apos;하고싶은말 - 지렸당&apos;,  contact: &apos;010-0000-0000&apos;},{  level: &apos;member&apos;,  name: &apos;심현수&apos;,  alias: &apos;면수&apos;,  age: &apos;32&apos;,  avility: {    수비: 0,    피지컬: 0,    스피드: 0,    창조력: 0,    공격: 0,    기술: 0,    제공권: 0,    정신: 0  },  img: &apos;src/assets/images/empty.png&apos;,  intro: &apos;하고싶은말&apos;,  contact: &apos;010-0000-0000&apos;},{  level: &apos;member&apos;,  name: &apos;이지훈&apos;,  alias: &apos;이지&apos;,  age: &apos;32&apos;,  avility: {    수비: 0,    피지컬: 0,    스피드: 0,    창조력: 0,    공격: 0,    기술: 0,    제공권: 0,    정신: 0  },  img: &apos;src/assets/images/empty.png&apos;,  intro: &apos;하고싶은말&apos;,  contact: &apos;010-0000-0000&apos;},{  level: &apos;member&apos;,  name: &apos;황지훈&apos;,  alias: &apos;황&apos;,  age: &apos;31&apos;,  avility: {    수비: 0,    피지컬: 0,    스피드: 0,    창조력: 0,    공격: 0,    기술: 0,    제공권: 0,    정신: 0  },  img: &apos;src/assets/images/empty.png&apos;,  intro: &apos;하고싶은말&apos;,  contact: &apos;010-0000-0000&apos;},{  level: &apos;member&apos;,  name: &apos;이유공&apos;,  alias: &apos;유공&apos;,  age: &apos;32&apos;,  avility: {    수비: 0,    피지컬: 0,    스피드: 0,    창조력: 0,    공격: 0,    기술: 0,    제공권: 0,    정신: 0  },  img: &apos;src/assets/images/empty.png&apos;,  intro: &apos;하고싶은말&apos;,  contact: &apos;010-0000-0000&apos;},{  level: &apos;member&apos;,  name: &apos;김성진&apos;,  alias: &apos;성진&apos;,  age: &apos;27&apos;,  avility: {    수비: 0,    피지컬: 0,    스피드: 0,    창조력: 0,    공격: 0,    기술: 0,    제공권: 0,    정신: 0  },  img: &apos;src/assets/images/empty.png&apos;,  intro: &apos;하고싶은말&apos;,  contact: &apos;010-0000-0000&apos;},{  level: &apos;member&apos;,  name: &apos;권우재&apos;,  alias: &apos;우재&apos;,  age: &apos;27&apos;,  avility: {    수비: 0,    피지컬: 0,    스피드: 0,    창조력: 0,    공격: 0,    기술: 0,    제공권: 0,    정신: 0  },  img: &apos;src/assets/images/empty.png&apos;,  intro: &apos;하고싶은말&apos;,  contact: &apos;010-0000-0000&apos;},{  level: &apos;member&apos;,  name: &apos;이은기&apos;,  alias: &apos;은기&apos;,  age: &apos;27&apos;,  avility: {    수비: 0,    피지컬: 0,    스피드: 0,    창조력: 0,    공격: 0,    기술: 0,    제공권: 0,    정신: 0  },  img: &apos;src/assets/images/empty.png&apos;,  intro: &apos;하고싶은말&apos;,  contact: &apos;010-0000-0000&apos;},{  level: &apos;member&apos;,  name: &apos;이준규&apos;,  alias: &apos;흰둥이&apos;,  age: &apos;31&apos;,  avility: {    수비: 0,    피지컬: 0,    스피드: 0,    창조력: 0,    공격: 0,    기술: 0,    제공권: 0,    정신: 0  },  img: &apos;src/assets/images/empty.png&apos;,  intro: &apos;하고싶은말&apos;,  contact: &apos;010-0000-0000&apos;},{  level: &apos;member&apos;,  name: &apos;박석현&apos;,  alias: &apos;석현이형&apos;,  age: &apos;37&apos;,  avility: {    수비: 0,    피지컬: 0,    스피드: 0,    창조력: 0,    공격: 0,    기술: 0,    제공권: 0,    정신: 0  },  img: &apos;src/assets/images/empty.png&apos;,  intro: &apos;하고싶은말&apos;,  contact: &apos;010-0000-0000&apos;},{  level: &apos;member&apos;,  name: &apos;황민구&apos;,  alias: &apos;민구형님&apos;,  age: &apos;38&apos;,  avility: {    수비: 0,    피지컬: 0,    스피드: 0,    창조력: 0,    공격: 0,    기술: 0,    제공권: 0,    정신: 0  },  img: &apos;src/assets/images/empty.png&apos;,  intro: &apos;하고싶은말&apos;,  contact: &apos;010-0000-0000&apos;},{  level: &apos;member&apos;,  name: &apos;윤지혁&apos;,  alias: &apos;윤지혁&apos;,  age: &apos;32&apos;,  avility: {    수비: 0,    피지컬: 0,    스피드: 0,    창조력: 0,    공격: 0,    기술: 0,    제공권: 0,    정신: 0  },  img: &apos;src/assets/images/empty.png&apos;,  intro: &apos;하고싶은말&apos;,  contact: &apos;010-0000-0000&apos;},{  level: &apos;member&apos;,  name: &apos;조한용&apos;,  alias: &apos;한용이&apos;,  age: &apos;26?&apos;,  avility: {    수비: 0,    피지컬: 0,    스피드: 0,    창조력: 0,    공격: 0,    기술: 0,    제공권: 0,    정신: 0  },  img: &apos;src/assets/images/empty.png&apos;,  intro: &apos;하고싶은말&apos;,  contact: &apos;010-0000-0000&apos;},{  level: &apos;member&apos;,  name: &apos;장성환&apos;,  alias: &apos;장성환&apos;,  age: &apos;32&apos;,  avility: {    수비: 0,    피지컬: 0,    스피드: 0,    창조력: 0,    공격: 0,    기술: 0,    제공권: 0,    정신: 0  },  img: &apos;src/assets/images/empty.png&apos;,  intro: &apos;하고싶은말&apos;,  contact: &apos;010-0000-0000&apos;},{  level: &apos;member&apos;,  name: &apos;김태주&apos;,  alias: &apos;태주&apos;,  age: &apos;24&apos;,  avility: {    수비: 0,    피지컬: 0,    스피드: 0,    창조력: 0,    공격: 0,    기술: 0,    제공권: 0,    정신: 0  },  img: &apos;src/assets/images/empty.png&apos;,  intro: &apos;하고싶은말&apos;,  contact: &apos;010-0000-0000&apos;}</code></pre><p>{<br>    “0”: {<br>      “author”: “gracehop”,<br>      “title”: “Announcing COBOL, a New Programming Language”<br>      “name”: “김대원”,<br>      “alias”: “원바”,<br>      “age”: 32,<br>      “avility”: {<br>        “수비”: 1.4,<br>        “피지컬”: 0.4,<br>        “스피드”: 0.9,<br>        “창조력”: 1.1,<br>        “공격”: 1,<br>        “기술”: 1,<br>        “제공권”: 0.2,<br>        “정신”: 0.5<br>      },<br>      “img”: “<a href="https://firebasestorage.googleapis.com/v0/b/fsa-project-60f97.appspot.com/o/wonba_slice.jpg?alt=media&amp;token=b2c0292b-7238-4ee3-8222-0a687f6aa6c8&quot;" target="_blank" rel="noopener">https://firebasestorage.googleapis.com/v0/b/fsa-project-60f97.appspot.com/o/wonba_slice.jpg?alt=media&amp;token=b2c0292b-7238-4ee3-8222-0a687f6aa6c8&quot;</a>,<br>      “intro”: “하고싶은 말 - 원래 바보”,<br>      “contact”: “010-0000-0000”<br>    },<br>    “1”: {<br>      “author”: “alanisawesome”,<br>      “title”: “The Turing Machine”<br>    }<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;firebase를-시작해보자&quot;&gt;&lt;a href=&quot;#firebase를-시작해보자&quot; class=&quot;headerlink&quot; title=&quot;firebase를 시작해보자&quot;&gt;&lt;/a&gt;firebase를 시작해보자&lt;/h1&gt;&lt;h2 id=&quot;firebase란&quot;&gt;&lt;a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>styled-components</title>
    <link href="http://shs400.github.io/2019/07/11/styled-component/"/>
    <id>http://shs400.github.io/2019/07/11/styled-component/</id>
    <published>2019-07-11T02:00:00.000Z</published>
    <updated>2019-07-15T00:55:07.132Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="Styled-Components"><a href="#Styled-Components" class="headerlink" title="Styled Components"></a>Styled Components</h1><p><img src="/images/styled-components/styled-components-logo.png" alt="logo"></p><p>이번 포스트는 Styled Compnents 에 대해서 알아보려고 합니다.</p><p>Styled Compnents는 나온지는 조금 되었고, 존재는 알았으나 따로 사용해보지 않았다가<br>theme provider를 사용해야할 계기가 있어 사용하게 되었습니다.</p><p>styled-components는 CSS-in-JS 라이브러리 입니다.</p><ul><li>CSS-in-JS : 자바스크립트 파일 안에서 CSS를 작성하는 형태</li></ul><p>이 라이브러리의 큰 장점은 JS or JSX파일 안에 CSS를 작성하기 때문에 따로 css파일을 작성하지 않는것이 장점입니다.<br>그리고 스타일을 입력할 떄 <code>Tagged 템플릿 리터럴</code>을 사용합니다.</p><h2 id="사용법-및-실행하기"><a href="#사용법-및-실행하기" class="headerlink" title="사용법 및 실행하기"></a>사용법 및 실행하기</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install styled-components --save-dev</span><br></pre></td></tr></table></figure><p>styled-components를 설치 한 후</p><p>예제 컴포넌트를 만들어봅니다.</p><h2 id="exampleComponent-js-styled-components-적용-전"><a href="#exampleComponent-js-styled-components-적용-전" class="headerlink" title="./exampleComponent.js (styled-components 적용 전)"></a>./exampleComponent.js (styled-components 적용 전)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> exampleComponent = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button&gt;일반 버튼&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button&gt;테두리 버튼&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default exampleComponent;</span></span><br></pre></td></tr></table></figure><p>위의 컴포넌트는 styled-components 적용전의 컴포넌트 입니다.<br>이 컴포넌트에 styled-components를 적용시키면</p><h2 id="exampleComponent-js-styled-components-적용-후"><a href="#exampleComponent-js-styled-components-적용-후" class="headerlink" title="./exampleComponent.js (styled-components 적용 후)"></a>./exampleComponent.js (styled-components 적용 후)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> styled, &#123; css &#125; <span class="keyword">from</span> <span class="string">'styled-components'</span>;</span><br><span class="line"><span class="keyword">const</span> buttonComponent = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;Box color=<span class="string">"black"</span>&gt;</span><br><span class="line">    &lt;BasicButton&gt;일반 버튼&lt;<span class="regexp">/BasicButton&gt;</span></span><br><span class="line"><span class="regexp">    &lt;BasicButton edge=&#123;true&#125;&gt;테두리 버튼&lt;/</span>BasicButton&gt;</span><br><span class="line">  &lt;<span class="regexp">/Box&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Box = styled.div`</span></span><br><span class="line"><span class="regexp">  /</span>* props 로 값을 직접 전달할 수 있습니다. *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">  background: $&#123;props =&gt; props.color || 'blue'&#125;;</span></span><br><span class="line"><span class="regexp">  padding: 10px;</span></span><br><span class="line"><span class="regexp">  display: flex;</span></span><br><span class="line"><span class="regexp">`;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const BasicButton = styled.button`</span></span><br><span class="line"><span class="regexp">  margin: 0 1em;</span></span><br><span class="line"><span class="regexp">  padding: 13px;</span></span><br><span class="line"><span class="regexp">  min-width: 80px;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span>* sass 처럼 &amp; 사용 가능 *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">  &amp;:hover &#123;</span></span><br><span class="line"><span class="regexp">    background: rgba(255, 255, 255, 0.9);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span>* edge 값이 <span class="literal">true</span> 일 때 특정 스타일을 부여해줍니다. *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">  $&#123;props =&gt;</span></span><br><span class="line"><span class="regexp">    props.edge &amp;&amp;</span></span><br><span class="line"><span class="regexp">    css`</span></span><br><span class="line"><span class="regexp">      background: none;</span></span><br><span class="line"><span class="regexp">      border: 2px solid white;</span></span><br><span class="line"><span class="regexp">      color: white;</span></span><br><span class="line"><span class="regexp">      &amp;:hover &#123;</span></span><br><span class="line"><span class="regexp">        background: white;</span></span><br><span class="line"><span class="regexp">        color: black;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    `&#125;;</span></span><br><span class="line"><span class="regexp">  &amp; + button &#123;</span></span><br><span class="line"><span class="regexp">    margin-left: 1rem;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">`;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default buttonComponent;</span></span><br></pre></td></tr></table></figure><p>보시는바와 같이</p><p>div는 Box 변수에 button은 Button 변수에 스타일링을 하여 담아 주고 있습니다.<br>여기서 특이한점은 css를 props를 사용하여 특정 값일때 스타일을 변경 할 수 있다는 것입니다. </p><h3 id="createGlobalStyle"><a href="#createGlobalStyle" class="headerlink" title="createGlobalStyle"></a>createGlobalStyle</h3><p>만약 global 하게 css 설정값이 필요하다면</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styled, &#123; createGlobalStyle &#125; <span class="keyword">from</span> <span class="string">'styled-components'</span>;</span><br><span class="line"><span class="keyword">const</span> GlobalStyle = createGlobalStyle<span class="string">`</span></span><br><span class="line"><span class="string">    body &#123;</span></span><br><span class="line"><span class="string">        padding: 0;</span></span><br><span class="line"><span class="string">        margin: 0;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> exampleComponent = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;GlobalStyle&gt;</span><br><span class="line">  &lt;Box color=<span class="string">"black"</span>&gt;</span><br><span class="line">    &lt;BasicButton&gt;일반 버튼&lt;<span class="regexp">/BasicButton&gt;</span></span><br><span class="line"><span class="regexp">    &lt;BasicButton edge=&#123;true&#125;&gt;테두리 버튼&lt;/</span>BasicButton&gt;</span><br><span class="line">  &lt;<span class="regexp">/Box&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">---- 아래 코드 생략 ----</span></span><br></pre></td></tr></table></figure><p>createGlobalStyle 메서드를 import 하고 GlobalStyle 변수에 global css를 정의 한 후<br>랜더링 부분에 추가하게되면 global한 css가 추가되게 됩니다.</p><h3 id="withComponent-상속"><a href="#withComponent-상속" class="headerlink" title="withComponent (상속)"></a>withComponent (상속)</h3><p>withComponent 메서드는 기존에 만들어놓은 style-component를 상속받아 새로운 component를 만듭니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LinkButton = BasicButton.widthComponent(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure></p><p>기존에 만들었던 Button styleCompnent를 a 태그에 적용하게됩니다.<br>이렇게 되면 Button에 적용되어있던 style까지 전부 상속받게됩니다.</p><p>상속받은 styleCompnent에서 스타일을 추가하고 싶다면</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LinkButton = styled(BasicButton.widthComponent(<span class="string">'a'</span>))<span class="string">`</span></span><br><span class="line"><span class="string">or</span></span><br><span class="line"><span class="string">const linkButton = BasicButton.widthComponent('a').extend`</span></span><br><span class="line">  color: blue;</span><br><span class="line"><span class="string">`;</span></span><br></pre></td></tr></table></figure><p>위와같이 styled or extend 메서드를 이용하여 적용해 주시면 됩니다.</p><p>이외의 기본 기능들은 <a href="https://www.styled-components.com/docs/basics" target="_blank" rel="noopener">공식홈페이지</a> 문서를 참고하시면 됩니다.</p><p>마지막으로</p><h3 id="ThemeProvider"><a href="#ThemeProvider" class="headerlink" title="ThemeProvider"></a>ThemeProvider</h3><p>ThemeProvider를 사용해 </p><p><code>./theme.js</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> theme = &#123;</span><br><span class="line">  color: &#123;</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">'#fff'</span>,</span><br><span class="line">    primary: <span class="string">'#547fbb'</span>,</span><br><span class="line">    warning: <span class="string">'#D72E3D'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> theme;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> styled, &#123; ThemeProvider &#125; <span class="keyword">from</span> <span class="string">'styled-components'</span>;</span><br><span class="line"><span class="keyword">import</span> theme <span class="keyword">from</span> <span class="string">'./theme'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (      </span><br><span class="line">      &lt;ThemeProvider theme=&#123;theme&#125;&gt;</span><br><span class="line">        &lt;BasicButton &#123;...props&#125;&gt;</span><br><span class="line">          &#123;children&#125;</span><br><span class="line">        &lt;<span class="regexp">/BasicButton&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>ThemeProvider&gt;        </span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BasicButton = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  color: <span class="subst">$&#123;props =&gt; &#123; props.theme.color.<span class="keyword">default</span> &#125;</span>&#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>테마에 따른 값을 변경하여 줄 수 있습니다.</p><p>styled components를 사용했던 이유는 theme 기능이 있기 때문에 사용해보게 되었는데,</p><p>개인적인 의견으로는<br>막상 사용해보니 css 코드에서 props 에 따라 값을 변경하고 하는것이 신선하였고,<br>SASS설치나 Webpack 설정을 하지않는다는 점과<br>사용해보지는 않았지만 styled-components로 작성된 css코드를 React Native에 바로 적용가능 하다고 하는 점,<br>( React Native에서 사용하면 기존에 사용하던 Text, View 등등 React Native 컴포넌트대신 styeld component 사용가능 )<br>마지막으로는 css를 위한 className이 따로 필요없다는 점이 가장 큰 장점이였던것 같습니다.</p><p>단점으로는<br>코드를 작성하고 theme를 사용하려고 해보니 오히려<br>${props =&gt; { props.theme.color.default }}<br>위와 같은 식으로 작성하는게 많아지다보면 더 복잡해지는 코드가 되는 느낌이 들었기 때문에<br>개안적으로는 아마 실제 프로젝트에선 굳이 사용하지는 않을것같다 라는 느낌을 받았고,<br>아마도.. css, sass, scss, postcss 등을 사용할 것 같습니다. </p><p>그러나 만약 webpack이나 sass 등을 모르고 styled-components도 모르는 상황이라면<br>styled-components가 접근하기에 훨씬 유용할것이라고 생각하고,<br>필자가 그 상황이라면 styled-components를 사용할 것 같습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;Styled-Components&quot;&gt;&lt;a href=&quot;#Styled-Components&quot; class=&quot;headerlink&quot; title=&quot;Styled Components&quot;&gt;&lt;/a&gt;Styled Components&lt;
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
      <category term="style" scheme="http://shs400.github.io/categories/javascript/blog/study/style/"/>
    
      <category term="css" scheme="http://shs400.github.io/categories/javascript/blog/study/style/css/"/>
    
    
      <category term="css" scheme="http://shs400.github.io/tags/css/"/>
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="study" scheme="http://shs400.github.io/tags/study/"/>
    
      <category term="style" scheme="http://shs400.github.io/tags/style/"/>
    
  </entry>
  
  <entry>
    <title>Docz</title>
    <link href="http://shs400.github.io/2019/04/23/Docz/"/>
    <id>http://shs400.github.io/2019/04/23/Docz/</id>
    <published>2019-04-23T04:37:15.000Z</published>
    <updated>2019-05-03T08:10:37.534Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="Docz"><a href="#Docz" class="headerlink" title="Docz"></a>Docz</h1><p>이번 포스트에서는 Docz에 대해 알아보려고 합니다.</p><p>Docz는 별도의 설정 없이 사용할수 있는 zero configuration 기반의 문서 생성 라이브러리입니다.<br>또한 mdx( markdown + jsx )라는 형식의 파일을 사용하고 있기 때문에<br>리액트를 사용하는 유저라면 더욱 더 손쉽게 배울 수 있습니다.</p><p>그리고 문서끼리는 의존성이 없고 각 문서가 컴포넌트에 의존하는 형식이기 때문에<br>프로젝트의 디렉토리 어느 위치에 .mdx 파일을 만들어도 상관이 없습니다.</p><p>Docz는 아래와 같은 장점을 가지고있다고 <a href="https://www.docz.site" target="_blank" rel="noopener">공식 홈페이지에</a> 나와있습니다.</p><blockquote><ul><li>Zero config </li><li>Gatsby 테마 사용 가능 </li><li>쉬운 커스터마이징</li><li>MDX 기반</li><li>최적화된 플러그인</li><li>타입스크립트 지원</li></ul></blockquote><hr><p>위의 6가지 장점중에서<br>필자가 생각하기엔 MDX 기반의 Zero config 문서화 툴이라는게 가장 큰 장점이지 않을까 생각합니다.</p><h3 id="설치-amp-실행해보기"><a href="#설치-amp-실행해보기" class="headerlink" title="설치 &amp; 실행해보기"></a>설치 &amp; 실행해보기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install docz doz-theme-<span class="keyword">default</span> --save-dev</span><br><span class="line">$ docz dev <span class="comment">// docz dev</span></span><br><span class="line">$ docz build <span class="comment">// docz build</span></span><br></pre></td></tr></table></figure><p>간단하게는 docz와 docz 테마를 설치 한 후<br>docz dev 명령어를 통하여 dev 서버를 실행할 수 있고,<br>docz build 명령어를 통하여 빌드를 할 수 있습니다.</p><h3 id="문서-생성"><a href="#문서-생성" class="headerlink" title="문서 생성"></a>문서 생성</h3><p>앞서 말씀드린 것 처럼 문서끼리는 의존성이 없고 프로젝트 디렉토리 어디에든<br>.mdx파일을 만들어주기만 한다면 Docz는 mdx 파일을 찾아 빌드해주게 됩니다.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">name: start</span><br><span class="line">route: /</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="section"># 시작하기</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 설명을 시작합니다.</span></span><br></pre></td></tr></table></figure><p>mdx파일을 만들고 dev 서버에서 확인을 해보면</p><p><img src="/images/docz/docz01.png" alt="docz"></p><p>위와 같은 화면이 나오게 됩니다.<br>참고) mdx 문서에 route 설정을 해주었기 때문에 해당 페이지가 첫화면으로 노출되게 됩니다.</p><p>기본적인 문서 생성은 여기까지 이고,</p><p>이제는 간단하게 버튼을 만들어 문서화를 해 보도록 하겠습니다.</p><p>우선 구조는 어떤 구조이던 상관이 없습니다. 최상위 루트에 다 넣으셔도 상관없습니다.<br>하지만 필자는 </p><p><img src="/images/docz/docz02.png#left" alt="docz"><br>위와 같은 구조로 작성하도록 하겠습니다.</p><ol><li>먼저 랜더링 할 버튼 컴포넌트를 만듭니다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cx <span class="keyword">from</span> <span class="string">'classnames'</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./Button.scss'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    children: <span class="string">''</span>,</span><br><span class="line">    className: <span class="string">''</span>,</span><br><span class="line">    size: <span class="string">'small'</span>,</span><br><span class="line">    theme: <span class="string">'default'</span>,</span><br><span class="line">    type: <span class="string">'button'</span>,</span><br><span class="line">    disabled: <span class="literal">false</span>,</span><br><span class="line">    onClick: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; className, children, type, theme, disabled, onClick &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button</span><br><span class="line">        className=&#123;cx(styles.button, styles[theme], styles[className])&#125;</span><br><span class="line">        type=&#123;type&#125;</span><br><span class="line">        onClick=&#123;onClick&#125;</span><br><span class="line">        disabled=&#123;disabled&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &#123;children&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">Button.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">  children: PropTypes.string,</span></span><br><span class="line"><span class="regexp">  className: PropTypes.string,</span></span><br><span class="line"><span class="regexp">  /</span>** size type = <span class="string">"small | normal | big"</span> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">  size: PropTypes.string,</span></span><br><span class="line"><span class="regexp">  /</span>** theme type = <span class="string">"default | primary | secondary | disabled | link | upload"</span> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">  theme: PropTypes.string,</span></span><br><span class="line"><span class="regexp">  /</span>** button type = <span class="string">"button | submit | reset"</span> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">  type: PropTypes.string,</span></span><br><span class="line"><span class="regexp">  disabled: PropTypes.bool,</span></span><br><span class="line"><span class="regexp">  onClick: PropTypes.func</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>후에 쓰일 docz의 Props 컴포넌트 사용을 위해 propTypes, defaultProps 을 정의 해 주면 좋습니다.<br>그리고 스타일링에 대한 플러그인을 설치 전 이기때문에 스타일링은 후에 넣어주셔도 됩니다.<br>(해당 버튼 컴포넌트는 작성자가 원하시는 코드를 작성하시고 위의 코드는 참고만 하시면 됩니다.)</p><ol start="2"><li>다음으로 버튼 컴포넌트에 대한 문서만듭니다.<br>(mdx 문서이기 때문에 jsx처럼 사용할 수 있습니다.)</li></ol><pre><code class="mdx">---name: Buttonroute: /button  // 작성자가 원하는 경로 설정---import { Playground, Props } from &apos;docz&apos;;import Button from &apos;./index.jsx&apos;;# Button## Basic usage&lt;Playground&gt;  &lt;Button&gt;default&lt;/Button&gt;  &lt;Button theme=&quot;warning&quot;&gt;warning&lt;/Button&gt;  &lt;Button theme=&quot;primary&quot;&gt;primary&lt;/Button&gt;  &lt;Button theme=&quot;secondary&quot;&gt;secondary&lt;/Button&gt;  &lt;Button theme=&quot;link&quot;&gt;link&lt;/Button&gt;&lt;/Playground&gt;## Props### propName | type | init&lt;Props of={Button} /&gt;</code></pre><p>작성한 mdx 문서를 보시면 jsx 처럼 컴포넌트를 import 하는것을 보실 수 있고,</p><p><code>&lt;Playground&gt;</code>는 컴포넌트를 랜더링하고 사용된 코드를 보여주기위해 사용됩니다.<br><code>&lt;Props&gt;</code>는 컴포넌트를 받아 해당컴포넌트의 props 테이블을 생성해줄때 사용됩니다.</p><p>그리고 처음에 작성한 Button 컴포넌트를 Playground를 사용하여 해당 컴포넌트를 랜더링해주면</p><p><img src="/images/docz/docz03.png" alt="docz"></p><p>이런 화면이 랜더링 되게 됩니다.</p><p>추가로 커스터마이징을 하고싶으시다면<br>doczrc.js를 프로젝트 루트에 만드시고,<br><a href="https://www.docz.site/docs/customizing" target="_blank" rel="noopener">Docz 공식 홈페이지 커스터마이징</a> 을 참고 하시면 됩니다.</p><p>이미 만들어져있는 테마를 사용하고 싶으시다면 Default 테마인 dark 와 light를 사용하시면 되고,<br><code>&lt;playground&gt;</code>에 단독적으로 테마를 적용할 수 있는데<br><a href="https://codemirror.net/theme/" target="_blank" rel="noopener">Codemirror 테마 URL</a>에 나와있는 테마를 사용하시면 됩니다.</p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>많은 사람들이 Docz와 StoryBook 그리고 Styleguidist 를 비교하고 있는데,<br>필자가 Docz를 선택한 이유는 </p><blockquote><ol><li>문서화만 필요했기 때문에</li><li>MDX를 써보고 싶어서</li><li>Zero config가 편해서</li></ol></blockquote><hr><p>이 3가지 이유 때문에 Docz를 사용하게 되었습니다.<br>개인적인 생각으로는 문서화만을 목적으로 한다면 Docz가 좋은것같고 다른 부가적인 기능이 필요하다면 StoryBook이 좋지 않을까 싶습니다.<br>(물론 Docz도 Stroybook 플러그인을 개발중입니다.)<br>이렇게 사용자의 목적에 따라 or 개인 취향에 따라 Docz, StoryBook, Styleguidist중 무엇을 사용할 것인지 판단하여 사용하시면 될 것 같습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;Docz&quot;&gt;&lt;a href=&quot;#Docz&quot; class=&quot;headerlink&quot; title=&quot;Docz&quot;&gt;&lt;/a&gt;Docz&lt;/h1&gt;&lt;p&gt;이번 포스트에서는 Docz에 대해 알아보려고 합니다.&lt;/p&gt;
&lt;p&gt;Docz는 별도
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
      <category term="Docz" scheme="http://shs400.github.io/categories/javascript/blog/study/Docz/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="study" scheme="http://shs400.github.io/tags/study/"/>
    
      <category term="Docz" scheme="http://shs400.github.io/tags/Docz/"/>
    
  </entry>
  
  <entry>
    <title>WebGL-9</title>
    <link href="http://shs400.github.io/2019/03/11/WebGL-9/"/>
    <id>http://shs400.github.io/2019/03/11/WebGL-9/</id>
    <published>2019-03-11T05:52:29.000Z</published>
    <updated>2019-03-15T06:08:14.644Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-9-Texture-2D"><a href="#WebGL-9-Texture-2D" class="headerlink" title="WebGL ( 9 - Texture 2D )"></a>WebGL ( 9 - Texture 2D )</h1><p>이번장에선 WebGL Texture에 대해 설명하려고 합니다.<br>텍스처란 우리가 만든 프로그램내에서 평면이나 3D화면에 적용하는 이미지를 말합니다.<br>이미지를 적용할때 보통은 텍스처를 입힌다고 많이 표현합니다. </p><p>텍스처로 사용하는 이미지는 비트맵으로 존재할 수 있고, 절차적으로 생성하여 사용할 수 도 있습니다. ( 이미지 사용 or 그려서 사용 )</p><p>보통 텍스처를 입히는 과정에서 스케일 조정, 늘이기, 왜곡 및 반복등을 사용하여 더욱더 입체적인 표현을 할 수 있게해줍니다.<br>보통 텍스처의 너비와 높이는 같은값을 사용하며, 64, 128, 256, 512같은 2의 거듭제곱 크기 입니다. </p><p>텍스처에도 좌표를 사용하게되는데 정점의 위치와 달리 (x,y)좌표 대신 (s,t)좌표로 나타내고 이 좌표를 텍셀이라고 표현하는데,<br>텍셀은 텍스처 요소(texture element), 텍스처 픽셀(texture pixel)의 약어 입니다.</p><p>텍스처 좌표는 (0,0)에서 부터 (1,1)로 제한되는데, 위에서 말한 거듭제곱 크기를 예를 들어<br>128 x 128 픽셀 크기의 텍스처의 경우에는 이를 범위내에서 표현하기 위해 모든점은 128로 나누게 됩니다.</p><p>이로인하여 예를들어 (0.5, 0.25)좌표는 (64, 32) 텍셀을 나타낸다고 할 수 있습니다.</p><p><img src="/images/webgl9/texture01.png" alt="texture"></p><p>이제부터는 본론으로 들어 텍스처 객체를 생선하고 바인딩을 해보도록 하겠습니다.<br>WebGL Texture를 생성하고 바인딩하는 코드는 아래와 같습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> texture = gl.createTexture();</span><br><span class="line">gl.bindTexture(gl.TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure><p>텍스처 타겟의 종류는 TEXTURE_2D 이외에도<br>TEXTURE_1D, TEXTURE_3D, 또는 TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY, TEXTURE_RECTANGLE, TEXTURE_CUBE_MAP, TEXTURE_BUFFER, TEXTURE_2D_MULTISAMPLE또는 TEXTURE_2D_MULTISAMPLE_ARRAY<br>등이 존재하지만 이번장에서는 TEXTURE_2D만 사용해보겠습니다.</p><p>특정 texture가 제대로 로드됐는지 확인할 때는 아래와 같이 isTexture 메서드를 사용하면 됩니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!gl.isTexture(<span class="keyword">this</span>.texture)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"텍스처가 잘못 로드되었습니다."</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>텍스처 데이터를 채울 때 가장 많이 사용하는 방법은 이미지파일로부터 텍스처 데이터를 로드하는 것입니다.</p><p>우선 텍스터 이미지 데이터를 보관할 변수를 선언하여줍니다.<br>그리고 텍스처 이미지를 로드 하기 위해 Image 객체를 사용합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textureImage = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadTexture</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  textureImage = <span class="keyword">new</span> Image();</span><br><span class="line">  textureImage.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setupTexture();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  textureImage.src = <span class="string">'./images/images.jpg'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>loadTexture 메서드에서는 Image 객체를 생성하고 onload 이벤트를 설정하여 이미지가 textureImage.src에 대입될때<br>로드가되면 setupTexture 메서드를 호출하도록 작성합니다. 제일 중요한 텍스처 설정에 대한 내용은 setupTexture 메서드에 있습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupTexture</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  texture = gl.createTexture(); <span class="comment">// 텍스처 생성</span></span><br><span class="line">  gl.bindTexture(gl.TEXTURE_2D, texture); <span class="comment">// 텍스처 바인드</span></span><br><span class="line">  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// true 인 경우 수직 축을 따라 소스 데이터를 뒤집습니다.</span></span><br><span class="line">  gl.texImage2D(gl.TEXTURE_2D, <span class="number">0</span>, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);</span><br><span class="line">  <span class="comment">// 텍스터 객체를 생성하고 TEXTURE_2D에 바인딩 한 후 이미지 데이터가 로딩된 이미지객체인</span></span><br><span class="line">  <span class="comment">// textureImage를 texImage2D()에 전당하여 오출하면, 이미지 데이터가 텍스처에 쓰여집니다.   </span></span><br><span class="line">  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);</span><br><span class="line">  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);</span><br><span class="line">  <span class="comment">// 텍스쳐를 위한 필터링을 준비합니다.</span></span><br><span class="line">  <span class="comment">// 필터링은 이미지 크기가 변경될 때 이미지가 필터되는 방식을 제어합니다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>pixelStorei : 웹지엘에게 데이터를 저장하는법을 알려줌</li><li>texParameteri : 텍스처 필터링 및 래핑을 처리하는 옵션을 설정</li></ul><hr><p>텍스처 설정은 먼저<br>createTexture 메서드를 통하여 텍스처를 생성하고 TEXTURE_2D에 바인드합니다.<br>그리고 pixelStorei 메서드를 호출하여 웹지엘에서 텍스처 데이터를 저장하는 방식을 조절합니다.</p><p>pixelStorei 옵션으로 UNPACK_FLIP_Y_WEBGL을 true로 설정하면 수직 Y축으로 소스데이터를 뒤집어줍니다.<br>이렇게 하면 데이터의 마지막행이 첫번째로 전송되는 행이되는데 이 옵션을 true로 하여 뒤집는 이유는 HTML 이미지에서<br>로드한 데이터가 웹지엘의 방향과 Y축점이 반대로 되어있기 때문에 해당 옵션을 사용하지 않으거나 false값을 설정한다면 이미지가 뒤집어져 보이게 됩니다.<br>(웹지엘에서 텍스처를 입힐때 왼쪽 하단부터 0,0이기 때문에 Y축이 반대입니다.)<br><img src="/images/webgl9/texture02.png" alt="texture"></p><p>texParameteri는 2번째 인자에 따라 텍스처 필터링과 밉래핑으로 나뉩니다.</p><p>텍스처 필터링은 크게 두 종류가 있고 종류에는 확대와 축소가 있습니다.</p><h3 id="필터링"><a href="#필터링" class="headerlink" title="필터링"></a>필터링</h3><p>TEXTURE_MIN_FILTER (축소)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)</span><br><span class="line"><span class="comment">// 기본 값 - NEAREST_MIPMAP_LINEAR</span></span><br></pre></td></tr></table></figure></p><p>축소의 경우 하나의 픽셀이 많은 영역의 텍셀에 대응할 경우 생기는 계단 현상을 유발하게되고,<br>3번쨰 인자가 LINEAR를 사용하여도 동일한 계단 현상이 나타나게 됩니다.<br>블록화 계단현상</p><p><img src="/images/webgl9/texture-contraction.gif" alt="texture"></p><p>TEXTURE_MAG_FILTER (확대)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)</span><br><span class="line"><span class="comment">// 기본 값 - LINEAR 이기때문에 아무것도 입력안하면 이미지가 번저보입니다.</span></span><br></pre></td></tr></table></figure></p><p>확대의 경우 텍스처 좌표에서 가장 가까운 텍셀값을 가져오기때문에 너무 많이 확대되면 블록화 현상이 생깁니다.<br>그러나 3번쨰 인자가 LINEAR라면 텍스처 좌표 주변의 4개 텍셀의 평균값으로 필터링하기 문에 이미지가 번저보이는 현상이 생깁니다.  </p><p><img src="/images/webgl9/texture-expand.gif" alt="texture"></p><h3 id="랩핑-매핑"><a href="#랩핑-매핑" class="headerlink" title="랩핑(매핑)"></a>랩핑(매핑)</h3><p>텍스처가 정사각형이던 아니던, 텍스처의 좌하단은 (0,0), 우상단은 (1,1)입니다.<br>그러나 사용자가 이 범위를 벗어나는 좌표를 사용할 때가 있는데, 웹지엘은 이를 텍스처 랩 모드에 따라서 처리합니다.</p><p>texParameteri 메소드에 2번째 인자로 TEXTURE_WRAP_S 혹은 TEXTURE_WRAP_T를 사용하여 S방향과 T방향에<br>각각 독립적으로 텍스처 랩모드를 설정할 수 있고 texParameteri 메서드의 3번째 인자로 설정하게 됩니다.</p><p>Default으로 아무것도 명시하지 않는다면 gl.REPEAT값이 적용됩니다.</p><ul><li>REPEAT 랩 모드 예시<br>(바둑판식으로 이미지를 반복합니다.)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);</span><br><span class="line">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/images/webgl9/texture03.png" alt="texture"></h2><ul><li>MIRRORED_REPEAT 랩 모드 예시<br>( S or T 축을 기준으로 거울처럼 반전하면서 같은 이미지를 반복합니다.)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);</span><br></pre></td></tr></table></figure></li></ul><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/images/webgl9/texture04.png" alt="texture"></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);</span><br></pre></td></tr></table></figure><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="/images/webgl9/texture05.png" alt="texture"></h2><ul><li>CLAMP_TO_EDGE 랩 모드 예시<br>(모서리 픽셀을 늘려서 확장시킵니다.)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);</span><br><span class="line">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);</span><br></pre></td></tr></table></figure><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="/images/webgl9/texture06.png" alt="texture"></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);</span><br><span class="line">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);</span><br></pre></td></tr></table></figure><h2 id="-4"><a href="#-4" class="headerlink" title=""></a><img src="/images/webgl9/texture07.png" alt="texture"></h2><p>이외에도 다른 옵션들이 존재하고, 다른 옵션들의 내용은<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter</a><br>아래의 링크에서 확인하시길 바랍니다.</p><p>그리고 텍스처 이미지는 아래의 주소에서 편하게 이용할 수 있습니다.</p><ul><li><a href="https://www.textures.com" target="_blank" rel="noopener">https://www.textures.com</a></li><li><a href="https://www.textureking.com" target="_blank" rel="noopener">https://www.textureking.com</a></li></ul><hr><p>다음장에선 3D입체 오브젝트에 텍스처를 입혀보는 내용을 다루도록 하겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-9-Texture-2D&quot;&gt;&lt;a href=&quot;#WebGL-9-Texture-2D&quot; class=&quot;headerlink&quot; title=&quot;WebGL ( 9 - Texture 2D )&quot;&gt;&lt;/a&gt;WebGL ( 9
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>immer</title>
    <link href="http://shs400.github.io/2019/01/31/immer/"/>
    <id>http://shs400.github.io/2019/01/31/immer/</id>
    <published>2019-01-31T05:26:08.000Z</published>
    <updated>2019-02-01T01:26:36.544Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="Immer-JS"><a href="#Immer-JS" class="headerlink" title="Immer JS"></a>Immer JS</h1><p>이번 포스트에서는 <a href="/2019/01/29/immutable/">Immutable JS</a> 포스트에서 언급하였던 Immer JS에 대해 설명하려고 합니다.</p><p><a href="/2019/01/29/immutable/">Immutable JS</a> 포스트에서 설명드린 불변성을 유지하려할때, spread 연산자보다 가독성을 좋게 하기위해<br>immutableJS를 사용한다고 설명 하였는데, immutableJS의 가독성도 spread에 비해 뛰어나게 좋은 정도는 아니고, 사용하기가 그닥 편리하지는 않습니다.( 필자의 생각 )</p><p>그러나 Immer JS를 사용하면 가독성이 좋아지고 편리하게 사용할 수 있습니다.<br>코드를 통해서 비교해보도록 하겠습니다.<br>아래와 같이 reducer를 통하여 불변성을 유지하며 state를 변경할때<br>immutable JS를 사용하면 아래와 같은 코드로 작성할 수 있고,<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counterInitState = <span class="built_in">Map</span>(&#123;</span><br><span class="line">  value: <span class="number">0</span>,</span><br><span class="line">  diff: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> counter = <span class="function">(<span class="params"> state = counterInitState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> Types.INCREMEMT:</span><br><span class="line">      <span class="keyword">return</span> state.update(<span class="string">'value'</span>, () =&gt; state.get(<span class="string">'value'</span>) + state.get(<span class="string">'diff'</span>));</span><br><span class="line">    <span class="keyword">case</span> Types.DECREMENT:</span><br><span class="line">      <span class="keyword">const</span> minDecrement = state.get(<span class="string">'value'</span>) &lt;= <span class="number">0</span> ? state.get(<span class="string">'value'</span>) : state.get(<span class="string">'value'</span>) - state.get(<span class="string">'diff'</span>);</span><br><span class="line">      <span class="keyword">return</span> state.update(<span class="string">'value'</span>, () =&gt; minDecrement);</span><br><span class="line">    <span class="keyword">case</span> Types.SET_DIFF:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        diff: action.diff</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">~~~  </span><br><span class="line"></span><br><span class="line">Immer JS를 사용하면 아래와 같은 코드로 작성 할 수 있습니다. </span><br><span class="line">~~~javascript</span><br><span class="line"><span class="keyword">const</span> counterInitState = &#123;</span><br><span class="line">  value: <span class="number">0</span>,</span><br><span class="line">  diff: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = produce(<span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> Types.INCREMEMT:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        value: draft.value + draft.diff,</span><br><span class="line">        diff: draft.diff</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> Types.DECREMENT:</span><br><span class="line">      <span class="keyword">const</span> minDecrement = draft.value &lt;= <span class="number">0</span> ? draft.value : draft.value - draft.diff;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        value: minDecrement,</span><br><span class="line">        diff: draft.diff</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> Types.SET_DIFF:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        value: draft.value,</span><br><span class="line">        diff: draft.diff</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> draft;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, counterInitState);</span><br></pre></td></tr></table></figure></p><p>여러분이 보시기에는 어느 코드가 저 보기편하고 작서하기 쉬운 코드일것 같나요?<br>필자의 생각으로는 ImmerJS를 사용한 코드가 가독성도 뛰어나고 코드작성시 편리하다고 생각합니다.<br>get을 사용하지 않고 .으로 접근할수 있는것 많으로도 많은 차이가 느껴지고 불변객체에 메서드를 랩핑해주지 않아도 되는 편리합니 있습니다.</p><p><a href="https://github.com/mweststrate/immer" target="_blank" rel="noopener">immerJS 공식 사이트</a>에서는 immer를 이렇게 설명합니다.</p><p><img src="/images/immer/immer01.png" alt="immer"><br>이미지 출처 : [<a href="https://github.com/mweststrate/immer]" target="_blank" rel="noopener">https://github.com/mweststrate/immer]</a></p><hr><p>immer를 사용하는것은 개인 비서를 갖는 것과 같습니다.<br>immer는 state를 받아서 draft라는 이전 state를 복사하고, 복사한 draft를 변경한뒤 state에 적용하면서 바꿔치기 하게됩니다.</p><p>쉽게 설명하면</p><ol><li>작가가 글은 쓰고,</li><li>작가의 글을 비서가 복사해 사본을 만들고 맞춤법등 변경될 부분을 수정한다.</li><li>마지막으로 비서가 수정한 글을 출판사에 제출한다.</li></ol><hr><p>이렇게 동작을 설명 할 수 있습니다.</p><p>이렇게 immutable, immer에 대해 설명하였으나, 결론적으로는<br>spread 연산자를 사용하던 immutable을 사용하던 아니면 immer를 사용하던, 선택은 사용하는 개발자의 몫이며<br>본인이 더 편리한 라이브러리를 사용하시길 바랍니다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;Immer-JS&quot;&gt;&lt;a href=&quot;#Immer-JS&quot; class=&quot;headerlink&quot; title=&quot;Immer JS&quot;&gt;&lt;/a&gt;Immer JS&lt;/h1&gt;&lt;p&gt;이번 포스트에서는 &lt;a href=&quot;/2019/01/2
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
      <category term="immutablity" scheme="http://shs400.github.io/categories/javascript/blog/study/immutablity/"/>
    
      <category term="immer" scheme="http://shs400.github.io/categories/javascript/blog/study/immutablity/immer/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="study" scheme="http://shs400.github.io/tags/study/"/>
    
      <category term="immutablity" scheme="http://shs400.github.io/tags/immutablity/"/>
    
      <category term="immer" scheme="http://shs400.github.io/tags/immer/"/>
    
  </entry>
  
  <entry>
    <title>immutable</title>
    <link href="http://shs400.github.io/2019/01/29/immutable/"/>
    <id>http://shs400.github.io/2019/01/29/immutable/</id>
    <published>2019-01-29T02:23:16.000Z</published>
    <updated>2019-01-29T08:21:19.524Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="Immutable-JS"><a href="#Immutable-JS" class="headerlink" title="Immutable JS"></a>Immutable JS</h1><p>저희가 사용하는 React와 Redux에서는 immutablity(불변성)를 항상 강조하고 있습니다.<br>Immutable JS에 대해 설명하기전에 immutablity(불변성)에 대해 설명을 하고 넘어가겠습니다.</p><h2 id="immutablity란"><a href="#immutablity란" class="headerlink" title="immutablity란?"></a>immutablity란?</h2><p>불변성 - 말 그대로 변하지 않는다는 것 입니다.<br>※ 우선 리액트 코드를 예를 들어 불변성에 대해 설명하고, Immutable JS 가 필요한 이유에 대해 설명하겠습니다.</p><p>React는 state의 불변성을 유지해야 한다고 합니다. 그렇기 때문에<br>state를 변경할때는 필수로 setState를 사용하여 업데이트를 해야하고,<br>state 객체 값을 <strong>직접 수정하면 안됩니다.</strong> </p><p>코드로 보자면<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  userList: [</span><br><span class="line">    &#123; </span><br><span class="line">      name: <span class="string">'sim'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; </span><br><span class="line">      name: <span class="string">'park'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>리액트 state에 userList라는 배열이 있고, 그 배열에 name: ‘kim’을 추가하거나<br>기존 userList를 수정한다 했을 때 아래와 같이 수정을 하는분들도 있을 것 입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state.userList.push(&#123; <span class="attr">name</span>: <span class="string">'kim'</span> &#125;);</span><br><span class="line">or</span><br><span class="line"><span class="keyword">this</span>.state.userList[<span class="number">0</span>].name = <span class="string">'lee'</span>;</span><br></pre></td></tr></table></figure><p>리액트를 사용하신다면 절대 위와 같이 사용하면 안됩니다.<br>리액트는 상태가 변할때 리렌더링이 되고, 리렌더링은 setState를 통해서 동작하도록 되어있습니다.<br>그렇기 때문에 아래 코드와 같이 수정해주어야 합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  name: <span class="string">'kim'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>위와 같이 setState를 이용하여 코드 작성시<br>리액트의 기본속성중의 하나인 부모 컴포넌트가 리렌더링 되면, 자식컴포넌트도 리렌더링 되는 현상을 보실 수 있을겁니다.<br>그 과정은 가상 DOM에서만 이뤄지는 렌더링이고, 렌더링 후에 리액트의 diffing알고리즘을 통하여 변화가 일어나는 부분만 실제로 업데이트 해준다고 합니다.</p><p>Ex)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ItemList <span class="keyword">from</span> <span class="string">"./item"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    users: PropTypes.array,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    users: [],</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  renderList() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; users &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> users.map(<span class="function">(<span class="params">user</span>) =&gt;</span> &lt;ItemList key=&#123;<span class="string">`<span class="subst">$&#123;user.id&#125;</span>_key`</span>&#125; user=&#123;user&#125; /&gt;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'users List 렌더됨 : '</span>,<span class="keyword">this</span>.props.users)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123; <span class="keyword">this</span>.renderList() &#125;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default UserList;</span></span><br></pre></td></tr></table></figure></p><p>해당 코드는 유저 리스트 화면을 렌더링해주는 코드입니다.<br>처음 렌더링이 될때 유저의 정보를 받고 해당 텍스트를 console에 출력합니다.<br><img src="/images/immutable/immutable01.png#left" alt="immutable"></p><p>문제는 부모컴포넌트에서 추가로 userList를 입력했을시 setState를 통해 상태를 변경해주면, 부모컨테이너가 리렌더링 되면서 자식 컴포넌트인 UserList 컴포넌트도 리렌더링 되게됩니다.<br>만약 부모 컴포넌트에서 입력해주는 input이 변경될때마다 setState를 변경시켰다면, 부모 컨테이너는 물론 UserList컨테이너 까지 리렌더링이되어 아래와 같은 문제가 나타나게 됩니다.<br><img src="/images/immutable/immutable02.png#left" alt="immutable"></p><p>실제 UserList는 변경되지 않았는데, 계속해서 리렌더링되고 있습니다. 실제 DOM에 반영되지 않는다 하더라도<br>미세하게 CPU 낭비가 존재 할 것이며, 이런 낭비를 없애기 위해 shouldComponentUpdate 라이프 사이클 훅을 작성합니다.<br>불변함을 유지하면서 코드를 짯기 때문에 아주 쉽게 코드를 작성할 수 있을 것입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  <span class="keyword">return</span> nextProps.users !== <span class="keyword">this</span>.props.users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserList 컴포넌트에 shouldComponentUpdate 라이프 사이클 훅에, 전달받은 props를 비교하여, Boolean 값을 리턴 해줌으로써<br>리렌더링을 할것인지 말것인지 판단하도록 해주게 됩니다.</p><p>드디어 immutable JS에 관해 설명을 하도록 하겠습니다.</p><p>이렇게 위의 내용처럼 최적화를 위해 불변성을 유지시켜 코드를 작성하다보면 복잡한 상태가 있을 수도 있습니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  userList: [</span><br><span class="line">    &#123; </span><br><span class="line">      id: <span class="number">01</span>,</span><br><span class="line">      name: <span class="string">'sim'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; </span><br><span class="line">      id: <span class="number">02</span>,</span><br><span class="line">      name: <span class="string">'park'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>이런 상태의 객체에서 불변성을을 유지하면서 userList 배열의 2번째 객체 이름을 변경하려면,<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; userList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"><span class="keyword">const</span> copyUser = [ ...userList ]; </span><br><span class="line"><span class="comment">// copyUser라는 변수에 spread 연산자를 통해 값을 복사해 넣습니다.</span></span><br><span class="line">copyUser[<span class="number">1</span>] = &#123;</span><br><span class="line">  ...userList[<span class="number">1</span>],</span><br><span class="line">  name: <span class="string">'lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  userList: copyUser</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>이렇게 userList의 2번째 객체이름을 변경해주면 불변성을 유지하면서 변경해줄 수 있습니다.<br>하지만 이런 구조가 더 깊은 구조로 되어있다면… 아래 내용처럼 해주어야합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  userList: &#123;</span><br><span class="line">    id: &#123;</span><br><span class="line">      idx: <span class="number">1</span>,</span><br><span class="line">      userName: &#123;</span><br><span class="line">        name: <span class="string">'sim'</span>,</span><br><span class="line">        friendsName: <span class="string">'park'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>위 코드를 불변성을 유지하며 변경하려면..<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; userList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"><span class="keyword">const</span> copyData = &#123; ...userList &#125;; </span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  userList: &#123;</span><br><span class="line">    ...copyData</span><br><span class="line">    id: &#123;</span><br><span class="line">      ...copyData.id</span><br><span class="line">      userName: &#123;</span><br><span class="line">        ...copyData.id.userName.name,</span><br><span class="line">        friends: <span class="string">'lee'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>이런식으로 spread 연산자가 반복적으로 사용되게 됩니다.<br>이렇게 번거롭고 복잡한 작업이 있을때 사용되는것이<br><strong>Immutable JS</strong> 입니다.</p><p>우선 immutable은 규칙이 있습니다.</p><ol><li>List - 배열</li><li>Map - 객체</li><li>set - 설정</li><li>get - 불러오기(읽기)</li><li>update - 불러오고 업데이트 시</li><li>List에 배열의 내장함수와 비슷한 함수들 존재 ( push, slice, filter 등 <a href="https://facebook.github.io/immutable-js/docs/#/List" target="_blank" rel="noopener">공식 사이트 문서 List() 참조</a> )</li><li>toJS - 일반 javascript 로 변환</li><li>setIn, getIn, updateIn - 깊은 구조의 객체의 값을 set, get, update 할때 </li><li>delete - key를 지울때 </li></ol><hr><p>이렇게 여러가지 규칙이 있습니다.<br>자세한 내용은 <a href="https://facebook.github.io/immutable-js/" target="_blank" rel="noopener">공식 사이트 문서 참조</a>하시길 바랍니다.</p><p>위의 규칙들을 사용해 객체의 구조에 적용해 본다면<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  userList: <span class="built_in">Map</span>(&#123;</span><br><span class="line">    users: List([</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'sim'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'park'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이렇게 적용이 가능하게 됩니다. immutable로 감싼 state는 사용시에도 규칙을 따르는데,<br>input에 텍스트 입력 후 버튼 클릭하는 함수에 코드를 작성해보면</p><pre><code class="javascript">onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> {  <span class="keyword">const</span> { userList } = <span class="keyword">this</span>.state;  <span class="keyword">this</span>.setState({    userList: userList.update(<span class="string">'users'</span>, users =&gt; users.push(<span class="built_in">Map</span>({      name: <span class="string">'lee'</span> <span class="comment">// 입력을 lee로 했다고 가정함.</span>    })))  });}</code></pre><p>위와 같이 작성할 수 있습니다.</p><p>immutable을 왜 사용해야 하는지 필요성을 못느낄 수 도 있겠지만,<br>필자의 경우는 코드의 가독성을 위해서 위와 같은 상황에서는 사용하는 것을 추천합니다.</p><p>.get(), getIn()을 계속 하는게 싫다면 Record를 사용하면 좀 더 편리하게 사용할 수 있다고 합니다.<br>하지만 저는 Record는 따로 설명하지 않으려고 합니다.<br>그 이유는 다음 포스트로 작성할 Immer JS는 Immutable JS 대신 사용하는 라이브러리 인데<br>사용하게되면 Record 를 사용하는것과 다를것이 없다고 생각되어 Record 설명은 생략하도록 하겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;Immutable-JS&quot;&gt;&lt;a href=&quot;#Immutable-JS&quot; class=&quot;headerlink&quot; title=&quot;Immutable JS&quot;&gt;&lt;/a&gt;Immutable JS&lt;/h1&gt;&lt;p&gt;저희가 사용하는 Reac
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
      <category term="immutable" scheme="http://shs400.github.io/categories/javascript/blog/study/immutable/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="study" scheme="http://shs400.github.io/tags/study/"/>
    
      <category term="immutable" scheme="http://shs400.github.io/tags/immutable/"/>
    
  </entry>
  
  <entry>
    <title>Test Utility - Enzyme</title>
    <link href="http://shs400.github.io/2019/01/23/enzyme/"/>
    <id>http://shs400.github.io/2019/01/23/enzyme/</id>
    <published>2019-01-23T04:18:23.000Z</published>
    <updated>2019-05-03T06:33:27.557Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="Test-Utility-Enzyme"><a href="#Test-Utility-Enzyme" class="headerlink" title="Test Utility - Enzyme"></a>Test Utility - Enzyme</h1><p>이번장은 앞장에서 설명한 <a href="//2019/01/22/jest/">Test FrameWork: Jest</a>에 이어서<br>React를 위한 자바스크립트 테스트 유틸리티인 Enzyme(엔자임)을 설명하려고 합니다.</p><h2 id="Enzyme이란"><a href="#Enzyme이란" class="headerlink" title="Enzyme이란?"></a>Enzyme이란?</h2><p>Enzyme은 airbnb에서 개발한 <strong>React용 컴포넌트 테스트 플러그인</strong>입니다.<br>컴포넌트를 얖게(shallow) 렌더링해서 테스트 해 볼 수 있고, 전체 DOM을 불러와 확인 할 수도 있습니다.<br>또한 그 형태가 jQuery 형태로 컴포넌트를 조회할 수 있기 때문에, <strong>컴포넌트 테스트</strong>로는 Enzyme이 매우 유용합니다.</p><h2 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h2><p>우선 npm으로 enzyme &amp; enzyme-adapter-react-16 를 설치합니다.<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev enzyme enzyme-adapter-react-<span class="number">16</span></span><br></pre></td></tr></table></figure></p><p>enzyme-adapter-react-16은<br>Enzyme이 react 16버전과 react 15버전에서 다르게 동작하기 때문에 enzyme-adapter-react-16 을 사용하여<br>react 16을 사용하고 있음을 알려주는 서드파티 입니다.</p><p>자 이제 앞장(<a href="//2019/01/22/jest/">Test FrameWork: Jest</a>)에서 작성했던 Counter.test.jsx 테스트 코드에 enzyme을 적용해보겠습니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> renderer <span class="keyword">from</span> <span class="string">"react-test-renderer"</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./index'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Counter'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> component = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'renders correctly'</span>, () =&gt; &#123;</span><br><span class="line">    component = renderer.create(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('matches snapshot', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    expect(component).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('increases correctly', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    component.getInstance().onIncrease();</span></span><br><span class="line"><span class="xml">    expect(component.getInstance().state.value).toBe(2);</span></span><br><span class="line"><span class="xml">    expect(component).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('decreases correctly', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    component.getInstance().onDecrease();</span></span><br><span class="line"><span class="xml">    expect(component.getInstance().state.value).toBe(1);</span></span><br><span class="line"><span class="xml">    const tree = component.toJSON();</span></span><br><span class="line"><span class="xml">    expect(tree).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure></p><p>위의 테스트 코드에 Enzyme을 적용하면<br>이제는 react-test-renderer 대신 Enzyme의 shallow를 사용하게됩니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; shallow, configure &#125; <span class="keyword">from</span> <span class="string">'enzyme'</span>;</span><br><span class="line"><span class="keyword">import</span> Adapter <span class="keyword">from</span> <span class="string">'enzyme-adapter-react-16'</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./index'</span>;</span><br><span class="line">configure(&#123; <span class="attr">adapter</span>: <span class="keyword">new</span> Adapter() &#125;);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Counter'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> component = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'renders correctly'</span>, () =&gt; &#123;</span><br><span class="line">    component = shallow(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('matches snapshot', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    expect(component).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('increases correctly', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    component.instance().onIncrease();</span></span><br><span class="line"><span class="xml">    expect(component.state().value).toBe(2);</span></span><br><span class="line"><span class="xml">    expect(component).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('decreases correctly', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    component.instance().onDecrease();</span></span><br><span class="line"><span class="xml">    expect(component.state().value).toBe(1);</span></span><br><span class="line"><span class="xml">    expect(component).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure></p><p>Enzyme에서 configure를 제외한다면 크게는 3가지 메서드가 존재하고, 그 메서드는 shallow, mount, render 입니다.</p><ol><li>shallow: 간단한 컴포넌트를 메모리에 렌더링합니다. ( 단일 컴포넌트를 테스트할 때 유용합니다. )</li><li>mount: HOC나 자식 컴포넌트 까지 전부 렌더링합니다. ( 다른 컴포넌트와의 관계를 테스트할 때 유용합니다. )</li><li>render: 컴포넌트를 정적인 html로 렌더링합니다. ( 컴포넌트가 브라우저에 붙었을 때 html로 어떻게 되는지 판단할 때 사용합니다.)</li></ol><hr><p>※ shallow 와 mount 두 API는 유사한 동작을 합니다.<br>그러나 mount가 좀 더 실제에 가깝게 동작을 합니다.<br>공식문서에는 테스트할 컴포넌트가 DOM API를 사용하거나 라이프사이클 훅 을 모두 활용할때 mount API를 사용하는것을 권장하고 있습니다.</p><p>특히 라이프 사이클 훅 관련하여 shallow와 mount는 차이점이 있습니다.<br>mount API는 모든 라이프사이클 훅이 호출되고,<br>shallow API는 componentDidmount 와 componentDidUpdate를 제외한 라이프사이클 훅이 호출된다는 점입니다.<br>이러한 차이점을 유의하여 필요에 따라 API를 사용하시면 됩니다. </p><p>위의 코드가 Enzyme을 적용한 코드인데<br>이렇게만 보면 굳이 왜? react-test-renderer 대신 Enzyme의 shallow를 사용하지? 라고 생각할 수 있을 것 입니다.</p><p>하지만<br>Enzyme을 사용하면 저희는 DOM이벤트를 시뮬레이트 해 볼 수 있습니다.<br>DOM이벤트를 시뮬레이트한다? 필자는 글로봐서는 감이 오지 않았습니다.</p><p>Enzyme API중 simulate를 사용하게 되는 것 인데,<br>위의 Enzyme 적용 테스트 코드 내용 중<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component.instance().onIncrease()</span><br></pre></td></tr></table></figure></p><p>처럼 함수를 실행하는 것이 아니라<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component.find(<span class="string">'.increaseButton'</span>).simulate(<span class="string">'click'</span>);</span><br></pre></td></tr></table></figure></p><p>처럼 실제로 카운트를 증가시키는 버튼을 마우스를 클릭하는 이벤트를 시뮬레이션 할 수 있게 되고,<br>아래의 테스트 코드처럼 테스트 할수 있게 됩니다.<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it('increases correctly', () =&gt; &#123;</span><br><span class="line">  component.<span class="built_in">find</span>('.increaseButton').simulate('click');</span><br><span class="line">  expect(component.state().value).toBe(<span class="number">2</span>);</span><br><span class="line">  expect(component).toMatchSnapshot();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>이렇게 Enzyme을 사용하면 특정 DOM에 이벤트를 시뮬레이트 할 수 도 있고, 그 외에도 수 많은 기능들이 있습니다.<br>나머지 수많은 기능들은 <a href="https://airbnb.io/enzyme/" target="_blank" rel="noopener">Enzyme 공식 홈페이지</a>를 참고하여 필요에 따라 사용하시길 바랍니다.</p><p>마지막으로 Jest와 Enzyme을 같이 사용하면 스냅샷이 보기 힘든 형태로 나오게 되는데 이 부분은<br>pakage.json에<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"jest"</span>: &#123;</span><br><span class="line">    <span class="string">"snapshotSerializers"</span>: [</span><br><span class="line">      <span class="string">"enzyme-to-json/serializer"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>를 추가해주시면 됩니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;Test-Utility-Enzyme&quot;&gt;&lt;a href=&quot;#Test-Utility-Enzyme&quot; class=&quot;headerlink&quot; title=&quot;Test Utility - Enzyme&quot;&gt;&lt;/a&gt;Test Utili
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="test" scheme="http://shs400.github.io/categories/javascript/blog/test/"/>
    
      <category term="tdd" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/"/>
    
      <category term="framework" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/framework/"/>
    
      <category term="jest" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/framework/jest/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/framework/jest/study/"/>
    
      <category term="enzyme" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/framework/jest/study/enzyme/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="test" scheme="http://shs400.github.io/tags/test/"/>
    
      <category term="tdd" scheme="http://shs400.github.io/tags/tdd/"/>
    
      <category term="framework" scheme="http://shs400.github.io/tags/framework/"/>
    
      <category term="jest" scheme="http://shs400.github.io/tags/jest/"/>
    
      <category term="enzyme" scheme="http://shs400.github.io/tags/enzyme/"/>
    
  </entry>
  
  <entry>
    <title>Test FrameWork - Jest</title>
    <link href="http://shs400.github.io/2019/01/22/jest/"/>
    <id>http://shs400.github.io/2019/01/22/jest/</id>
    <published>2019-01-22T01:52:04.000Z</published>
    <updated>2019-01-31T06:29:41.088Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="Test-Framework-Jest"><a href="#Test-Framework-Jest" class="headerlink" title="Test Framework - Jest"></a>Test Framework - Jest</h1><p>이번 내용은 리액트 테스트 프레임워크인 jest에 대해 설명하려고 합니다.</p><p>필자는 우선 테스트라는 것은 전혀 생각도 하지 않았고, 몇년전 모임 스터디중 Jasmine(자스민)을<br>아주 잠깐 맛보기로 써봤을 뿐이였습니다. 그당시 자스민을 쓰면서도 이걸 언제 작성하고 할까.. 귀찮은데..<br>재미도없어.. 이런 마음이 컷기 때문에 맛보기 정도만 해보고 그대로 저의 기억속에서 잊혀졌습니다.</p><p>그러다 최근 팀에 새로 입사하신분께서 jest에 대해 설명해주셨고, 유용함을 이제서야 느끼게 되어<br>이 글을 작성하게 되었습니다.</p><p>그렇다면 왜 테스트를 해야하는가에 대해 먼저 얘기해 보겠습니다.</p><h2 id="테스트-Why"><a href="#테스트-Why" class="headerlink" title="테스트.. Why?"></a>테스트.. Why?</h2><p>물론 저는 아직도 테스트를 반드시, 무조건 해야한다고 생각하지는 않습니다.<br>실무에 이미 도입되어있거나 혹은 도입하기위해 실무에 바로 써야하는 분들의 경우도 있을 것 이며,<br>아직 테스트코드에 대해 모르거나 예전의 저처럼 비관적으로 바라보는 경우도 있을 것 입니다.<br>왜냐하면 혼자하는 작업이거나 소규모 프로젝트라면 오히려 진행 속도를 늦출 수 있기 때문입니다.</p><p>일단 장점과 단점을 설명하자면 아래와 같습니다.</p><p><strong>장점</strong></p><ol><li>리팩토링할때 좋다.<ul><li>리팩토링 후에도 해당 모듈이 의도대로 작동하고 있음을 유닛 테스트를 통해서 확신할 수 있는데, 이를 회귀 테스트(Regression testing)라 합니다.</li></ul></li><li>협업시 좋다.<ul><li>A의 코드와 B의 코드로 C 라는 기능을 구현 하는데, A를 수정한뒤에 A 코드의 정상 동작을 확인 하였는데, 갑자기 A에서 문제가 생겼다고 했을시 기존에 유닛 테스트를 했다면<br>A코드의 문제를 바로 발견하고 수정했을것입니다. 하지만 유닛코드를 작성하지 않았다면 어디서 버그가 나타났는지 찾기 힘들것입니다.     </li></ul></li><li>그룹내에 공용으로 사용하여 테스트 코드를 늘릴 수 있다. ( 예외적인 상황 )<ul><li>예를 들면 같은 개발팀 내에서 validation 관련 컴포넌트 &amp; 테스트 코드를 공유하며 하나하나씩 테스트 코드를 작성하다보면 테스트 코드가 공유되고 양도 늘어나 더욱 빠른 테스트 환경을 만들 수 있다.</li></ul></li></ol><hr><p><strong>단점</strong></p><ol><li>시간이 걸린다.<ul><li>테스트 코드 작성 및 러닝커브</li></ul></li></ol><hr><p>이처럼 유닛테스트는 개발 시간을 증가 시키는것 처럼 보일 수 있습니다.<br>하지만 유닛테스트를 함으로써 개발 기간 중 대부분을 차지하는 디버깅 시간을 단축시킬수 있기 때문에 필수는 아니지만<br>할 수 있다면 작성 하며 개발 하는 것을 개인적으로는 추천합니다.</p><p>*필자는 그전에 개발을 하였을 때 테스트 없이 개발 하였고, 리팩토링하거나 코드 수정시 기존의 기능들이 제대로 동작하는지 하나하나 확인 했었는데,<br>테스트 코드를 작성함으로써 테스트만 돌리면 따로 확인작업을 하지않아도 된다는 것이 매력적으로 다가왔습니다.<br>물론 테스트 코드가 100%를 테스트 해주진 않겠지만 ( 테스트 코드 작성에 따라 다름으로 ) 어느정도 커버해준다는 것만 으로도 큰 매력이 있다고 생각합니다. </p><p>다음으로 이제 jest에 대해 설명하도록 하겠습니다.<br>(필자는 react를 사용하며 react에 최적화되어있는 test framework인 jest에 대해 알아보려고 합니다.)</p><h2 id="Jest란"><a href="#Jest란" class="headerlink" title="Jest란?"></a>Jest란?</h2><p>Jest는 페이스북에서 만든 테스트 프레임워크입니다.<br>React를 포함한 모든 자바스크립트 코드를 테스트하는데 사용될 수 있습니다.<br>Jest의 철학중 “Zero-Configuration”이 있는데, 이는 아래와 같이 설정 없는 테스트 환경을 제공한다고 합니다.<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev jset // jest 설치</span><br><span class="line">npm run jest // jest 시작</span><br></pre></td></tr></table></figure></p><p>이렇게 간단하게 설치와 테스트를 할 수 있습니다.<br>물론 테스트 코드를 작성하는것은 별개의 작업이지만 따로 설정이 필요없이 설치만 하면 테스트를 할수 있는 환경이 이루어집니다.</p><p>이렇게 Jest를 사용하여 저희는 <strong><a href="https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%9B_%ED%85%8C%EC%8A%A4%ED%8A%B8" target="_blank" rel="noopener">Unit Test(단위 테스트)</a></strong>를 해보려고 합니다.</p><h2 id="Unit-Test-단위-테스트-란"><a href="#Unit-Test-단위-테스트-란" class="headerlink" title="Unit Test(단위 테스트)란?"></a>Unit Test(단위 테스트)란?</h2><p><strong>Unit Test</strong>란, 소프트웨어를 최소한의 단위로 쪼개서 아주 작은 단위로 테스트 하는 것 을 말합니다.<br>예를 들자면 React에 A라는 Counter 컴포넌트가 있다면, A컴포넌트의 카운트 증가 함수를 테스트 하거나 카운트 감소 함수를 테스트 하는 것을 말합니다.</p><h2 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h2><p>기본적으로 React는 사용 하실줄 안다는 것을 가정하여 설명하도록 하겠습니다.<br>( 아래와 같이 Counter.jsx 컴포넌트 코드와 Counter.test.jsx 컴포넌트 테스트 코드를 먼저 작성합니다. )</p><p>Counter.jsx<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onIncrease = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">&#123;value&#125;</span>) =&gt;</span> (&#123; <span class="attr">value</span>: value + <span class="number">1</span> &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onDecrease = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">&#123;value&#125;</span>) =&gt;</span> (&#123; <span class="attr">value</span>: value &lt;= <span class="number">0</span> ? value : value - <span class="number">1</span> &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;카운터 예제&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;&#123;value&#125;&lt;/</span>h2&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.onIncrease&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.onDecrease&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Counter;</span></span><br></pre></td></tr></table></figure></p><p>Counter.test.jsx<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> renderer <span class="keyword">from</span> <span class="string">'react-test-renderer'</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./index'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Counter'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> component = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'renders correctly'</span>, () =&gt; &#123;</span><br><span class="line">    component = renderer.create(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('matches snapshot', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    const tree = component.toJSON();</span></span><br><span class="line"><span class="xml">    expect(tree).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  //increase 동작 확인</span></span><br><span class="line"><span class="xml">  it('increases correctly', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    component.getInstance().onIncrease();</span></span><br><span class="line"><span class="xml">    expect(component.getInstance().state.value).toBe(2); // value 값이 2인지 확인</span></span><br><span class="line"><span class="xml">    const tree = component.toJSON(); // re-render</span></span><br><span class="line"><span class="xml">    expect(tree).toMatchSnapshot(); // 스냅샷을 비교합니다.</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  // decrease 동작 확인</span></span><br><span class="line"><span class="xml">  it('decreases correctly', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    component.getInstance().onDecrease();</span></span><br><span class="line"><span class="xml">    expect(component.getInstance().state.value).toBe(1); // value 값이 1인지 확인</span></span><br><span class="line"><span class="xml">    const tree = component.toJSON(); // re-render</span></span><br><span class="line"><span class="xml">    expect(tree).toMatchSnapshot(); // 스냅샷을 비교합니다.</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure></p><p>중요한 것은 Counter.test.jsx 입니다. Counter.test.jsx 코드를 보시면<br>renderer, describe, it, expect등 처음 보는 메서드 들이 있을 것입니다.</p><p>describe와 it은 jest에서 제공되는 함수입니다.<br>describe는 테스트 묶음을 정의하고, it은 테스트 케이스를 정의 합니다.<br>( Counter.test.jsx 테스트 묶음(Suite)은 4개의 테스트를 가지고 있습니다. )</p><p>expect도 jest에서 제공하는 함수로 테스트값과 예상값이 일치하는지 여부를 판단합니다.<br>일치여부 뿐만 아니라 다른 비교도 할 수 있는데 <a href="https://jestjs.io/docs/en/expect.html" target="_blank" rel="noopener">Jest - Expect</a>에서 확인할 수 있습니다.</p><p>그리고 describe 와 it 에서 첫번째 파라미터는 해당 작업의 설명을 넣어주게 되는데,<br>describe 에서는 어떤 기능을 확인하는지, 그리고 it 부분에선 무엇을 검사해야 되는지에 대한 설명을 넣으시면 됩니다.</p><p>renderer는 스냅샷 테스트를 위해 사용되는 함수입니다. renderer를 사용하기위해서는 먼저 react-test-renderer 를 설치해 주어야합니다.<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev react-test-renderer</span><br></pre></td></tr></table></figure></p><p>react-test-renderer의 create() 함수는 인자로 리액트 컴포넌트를 받아 렌더링합니다.<br>이후 toMatchSnapshot() matcher를 통해 렌더링된 컴포넌트를 스냅샷과 비교할 수 있습니다.</p><h2 id="SnapShot-스냅샷-테스트란"><a href="#SnapShot-스냅샷-테스트란" class="headerlink" title="SnapShot(스냅샷) 테스트란?"></a>SnapShot(스냅샷) 테스트란?</h2><p>결과값을 파일로 저장해서 테스트할 때마다 테스트 결과값을 파일의 결과값과 비교합니다.<br>비교해서 다를때 개발자가 수정을 한 코드이면 업데이트를 하면되고( npm run jest – -u ),<br>의도하지 않은 코드라면 버그라고 판단하고 코드를 수정하면 될 것 입니다.</p><p>위의 Counter.test.jsx 테스트를 실행하면<br><img src="/images/jest/jest_img01.png#left" alt="snapshot"><br>이렇게 해당 테스트 코드 위치에 snapshots 폴더가 생기고 스냅샷 결과값은 아래와 같이 나오게된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">exports[<span class="string">`Counter decreases correctly 1`</span>] = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;h1&gt;</span></span><br><span class="line"><span class="string">    카운터</span></span><br><span class="line"><span class="string">  &lt;/h1&gt;</span></span><br><span class="line"><span class="string">  &lt;h2&gt;</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">  &lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;button</span></span><br><span class="line"><span class="string">    onClick=&#123;[Function]&#125;</span></span><br><span class="line"><span class="string">  &gt;</span></span><br><span class="line"><span class="string">    +</span></span><br><span class="line"><span class="string">  &lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;button</span></span><br><span class="line"><span class="string">    onClick=&#123;[Function]&#125;</span></span><br><span class="line"><span class="string">  &gt;</span></span><br><span class="line"><span class="string">    -</span></span><br><span class="line"><span class="string">  &lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line">exports[<span class="string">`Counter increases correctly 1`</span>] = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;h1&gt;</span></span><br><span class="line"><span class="string">    카운터</span></span><br><span class="line"><span class="string">  &lt;/h1&gt;</span></span><br><span class="line"><span class="string">  &lt;h2&gt;</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">  &lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;button</span></span><br><span class="line"><span class="string">    onClick=&#123;[Function]&#125;</span></span><br><span class="line"><span class="string">  &gt;</span></span><br><span class="line"><span class="string">    +</span></span><br><span class="line"><span class="string">  &lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;button</span></span><br><span class="line"><span class="string">    onClick=&#123;[Function]&#125;</span></span><br><span class="line"><span class="string">  &gt;</span></span><br><span class="line"><span class="string">    -</span></span><br><span class="line"><span class="string">  &lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line">exports[<span class="string">`Counter matches snapshot 1`</span>] = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;h1&gt;</span></span><br><span class="line"><span class="string">    카운터</span></span><br><span class="line"><span class="string">  &lt;/h1&gt;</span></span><br><span class="line"><span class="string">  &lt;h2&gt;</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">  &lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;button</span></span><br><span class="line"><span class="string">    onClick=&#123;[Function]&#125;</span></span><br><span class="line"><span class="string">  &gt;</span></span><br><span class="line"><span class="string">    +</span></span><br><span class="line"><span class="string">  &lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;button</span></span><br><span class="line"><span class="string">    onClick=&#123;[Function]&#125;</span></span><br><span class="line"><span class="string">  &gt;</span></span><br><span class="line"><span class="string">    -</span></span><br><span class="line"><span class="string">  &lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure></p><p>이렇게 작성된 스냅샷과 현재 코드와 비교하여 달라진 곳이 있는지 테스트 하게 되는 것 입니다.</p><p>지금까지 설명한데로 진행하게되면, 터미널에는 아래와 같은 메세지가 출력될 것입니다.<br><img src="/images/jest/jest_img02.png#left" alt="jset_test"></p><p>이를 바탕으로 더 많은 테스트 코드를 작성하여 안정성있는 코드를 작성하실 수 있길 바랍니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;Test-Framework-Jest&quot;&gt;&lt;a href=&quot;#Test-Framework-Jest&quot; class=&quot;headerlink&quot; title=&quot;Test Framework - Jest&quot;&gt;&lt;/a&gt;Test Frame
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="test" scheme="http://shs400.github.io/categories/javascript/blog/test/"/>
    
      <category term="tdd" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/"/>
    
      <category term="framework" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/framework/"/>
    
      <category term="jest" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/framework/jest/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/framework/jest/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="test" scheme="http://shs400.github.io/tags/test/"/>
    
      <category term="tdd" scheme="http://shs400.github.io/tags/tdd/"/>
    
      <category term="framework" scheme="http://shs400.github.io/tags/framework/"/>
    
      <category term="jest" scheme="http://shs400.github.io/tags/jest/"/>
    
  </entry>
  
  <entry>
    <title>WebGL-8</title>
    <link href="http://shs400.github.io/2019/01/22/WebGL-8/"/>
    <id>http://shs400.github.io/2019/01/22/WebGL-8/</id>
    <published>2019-01-22T01:51:31.000Z</published>
    <updated>2019-01-23T07:25:14.970Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-8-작성중"><a href="#WebGL-8-작성중" class="headerlink" title="WebGL ( 8 - 작성중 )"></a>WebGL ( 8 - 작성중 )</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-8-작성중&quot;&gt;&lt;a href=&quot;#WebGL-8-작성중&quot; class=&quot;headerlink&quot; title=&quot;WebGL ( 8 - 작성중 )&quot;&gt;&lt;/a&gt;WebGL ( 8 - 작성중 )&lt;/h1&gt;
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL-7</title>
    <link href="http://shs400.github.io/2018/12/24/WebGL-7/"/>
    <id>http://shs400.github.io/2018/12/24/WebGL-7/</id>
    <published>2018-12-24T00:17:36.000Z</published>
    <updated>2019-01-23T07:21:33.826Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-7-View"><a href="#WebGL-7-View" class="headerlink" title="WebGL ( 7 - View )"></a>WebGL ( 7 - View )</h1><p>이번장은 3D 도형을 구현하기전에 View 관점에 대해 설명하려고 합니다.<br>앞의 6장의 행렬과 관련된 내용입니다.</p><h2 id="모델-뷰-프로젝션-Matrix-MVP"><a href="#모델-뷰-프로젝션-Matrix-MVP" class="headerlink" title="모델, 뷰, 프로젝션 Matrix ( MVP )"></a>모델, 뷰, 프로젝션 Matrix ( MVP )</h2><p>먼저 랜더링 간단한 랜더링 파이프라인은 이렇습니다.</p><p><img src="/images/webgl6/matrix08.jpg" alt="matrix"></p><p>월드 -&gt; 카메라 -&gt; 투영행렬을 거쳐 3차원이 2차원으로 변환되는 과정입니다.<br>투영행렬이 끝난뒤에 클리핑과 뷰포트 변환이 있지만 여기서는 위와같이 투영 행렬까지만 설명합니다.</p><p><img src="/images/webgl6/matrix09.jpg" alt="matrix"></p><p><code>모델 Matrix</code>는 모델좌표계에서 월드 좌표계로 변환해주는 행렬입니다.<br>( 6장에서 배운 translate, scale, rotate 변환이 모델 Matrix 입니다. )</p><p><img src="/images/webgl6/matrix10.jpg" alt="matrix 변환"></p><p>다음으로 월드 좌표계에서 카메라 좌표계로 변환해줘야 하는데<br>이때 <code>뷰 Matrix</code>를 사용합니다.<br>( 이 과정에서 카메라의 이동이라던지 카메라 위치 설정등이 이루어지고 lookAt 함수를 사용하게 됩니다. )</p><p><img src="/images/webgl6/matrix11.jpg" alt="matrix 변환"></p><p>마지막으로 투영 변환 ( Projection Matrix )</p><p>월드 좌표계와 카메라 좌표계는 모두 3차원 좌표계입니다.<br>그러나 우리가 디스플레이로 확인하게 되는 랜더링 결과들은 모두 2차원의 화면입니다.<br>때문에 3차원 좌표계를 2차원 좌표계로 바꾸는 변환이 필요하다는 것을 알 수 있는데,<br>이때 <code>투영 변환</code>이 필요합니다.</p><p>투영 변환에는 perspective와 Orthographic가 있는데<br>우리는 perspective를 사용하도록 하겠습니다.</p><h3 id="perspective"><a href="#perspective" class="headerlink" title="perspective"></a>perspective</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Ex)</span><br><span class="line">mat4.perspective(view, canvas.width / canvas.height, <span class="number">0.1</span>, <span class="number">2000.0</span>, pMatrix);</span><br><span class="line"><span class="comment">// mat4.perspective 는 gl-matrix 라이브러리의 헬퍼 함수 </span></span><br><span class="line"><span class="comment">// (시야, 종횡비, 전방 및 후방 경계를 인자로 받는다.)</span></span><br><span class="line"><span class="comment">// 1. 시야 : 수직방향 시야각입니다.</span></span><br><span class="line"><span class="comment">// 2. 종횡비 : 화면 비 이고, 윈도우 크기에 의존합니다.</span></span><br><span class="line"><span class="comment">// 3. 근거리 잘라내기</span></span><br><span class="line"><span class="comment">// 4. 원거리 잘라내기</span></span><br></pre></td></tr></table></figure><iframe src="https://webgl2fundamentals.org/webgl/frustum-diagram.html" width="700px" height="600px" frameborder="0" allowfullscreen></iframe><p>출처 : [webglfundamentals.org]</p><p>위의 변환까지 모두 완료가 되면 GLSL에서<br>Model, View, Projection 을 모두 곱해줘야합니다.<br>이때 행렬의 곱 순서는 꼭 mvp의 역순으로 곱해주어야 합니다.<br>( MVPmatrix = projection X view X model; )</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=<span class="string">"shader-vs"</span> type=<span class="string">"x-shader/x-vertex"</span>&gt;</span><br><span class="line">    attribute vec3 aVertexPosition;</span><br><span class="line">    attribute vec4 aVertexColor;</span><br><span class="line"></span><br><span class="line">    uniform mat4 uMVMatrix;</span><br><span class="line">    uniform mat4 uPMatrix;</span><br><span class="line"></span><br><span class="line">    varying vec4 v_color;</span><br><span class="line">    <span class="keyword">void</span> main(<span class="keyword">void</span>) &#123;</span><br><span class="line">      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, <span class="number">1.0</span>);</span><br><span class="line">      v_color = aVertexColor * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>이번장은 여기서 마무리하고 다음장에서는 실제 3D 화면을 구현해 보도록 하겠습니다.</p><p><img src="/images/webgl6/matrix12.jpg" alt="matrix 변환"></p><p>핵심 위치에 라벨을 붙임</p><p><img src="/images/webgl6/matrix13.jpg" alt="matrix 변환"></p><p>라벨을 붙인후 각 라벨에 인덱스 정점을 활용</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-7-View&quot;&gt;&lt;a href=&quot;#WebGL-7-View&quot; class=&quot;headerlink&quot; title=&quot;WebGL ( 7 - View )&quot;&gt;&lt;/a&gt;WebGL ( 7 - View )&lt;/h1&gt;&lt;p&gt;이
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL ( 6 - Martrix )</title>
    <link href="http://shs400.github.io/2018/11/21/WebGL-6/"/>
    <id>http://shs400.github.io/2018/11/21/WebGL-6/</id>
    <published>2018-11-21T05:40:37.000Z</published>
    <updated>2019-01-23T07:21:33.842Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-6-Martrix"><a href="#WebGL-6-Martrix" class="headerlink" title="WebGL ( 6 - Martrix )"></a>WebGL ( 6 - Martrix )</h1><p>이번에는 3D를 표현하기에 앞서<br>Matrix(행렬)에 대해 설명부터 하려고 합니다.</p><p>3D를 표현하기전에<br>저희는 기존에 버텍스를(x,y,z,w) 다루었습니다.<br>( * 앞장까지는 x,y,z 만으로도 표현이 가능하였습니다. )</p><p>저희가 기억해야할 것은 w입니다.</p><ul><li><code>w = 1 이면 벡터공간에서의 점의 위치입니다. ( x, y, z, 1 )</code></li><li><code>w = 0 이면 벡터공간에서의 방향입니다. ( x, y, z, 0 )</code></li></ul><p>위의 내용은 무조건 기억하고 있어야합니다.</p><h3 id="Matrix-이해"><a href="#Matrix-이해" class="headerlink" title="Matrix 이해"></a>Matrix 이해</h3><p>3D 그래픽스에서 4x4 행렬을 주로 사용하는데,<br>이들은 우리의 (x,y,z,w) 버텍스들을 변형하게 해줍니다. 이에 대한 공식은 아래와 같습니다.<br>행렬 x 버텍스 = 변형된 버텍스 ( * 순서가 동일해야합니다. )</p><p><img src="/images/webgl6/matrix01.gif" alt="matrix 변환"></p><p>위의 공식은 GLSL에서는 아래와 같이 사용합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mat4 Matrix;</span><br><span class="line">vec4 Vector;</span><br><span class="line"></span><br><span class="line">vec4 transformedVector = Matrix * Vector;</span><br></pre></td></tr></table></figure><p>이처럼 저희는 변형된 버텍스 값을 사용하게되며,<br>앞서 말했던 (x,y,z,w) 벡터에 대해 설명하기 위해<br>이해하기 쉬운 평행이동 행렬에 대해 설명하겠습니다.</p><h4 id="평행이동-행렬"><a href="#평행이동-행렬" class="headerlink" title="평행이동 행렬"></a>평행이동 행렬</h4><p><img src="/images/webgl6/matrix02.png" alt="matrix 변환"></p><p>위의 행렬이 평행이동 행렬입니다.<br>X,Y,Z에 있는 것들이 자신의 위치에서 더하고자 하는 값입니다.</p><p><img src="/images/webgl6/matrix03.png" alt="matrix 변환"></p><p>자신을 X 방향으로 20만큼 평행이동 시키면 위와 같이 계산을 하게되고,<br>결과는 벡터 ( 10, 10, 10, 1 )을 X 방향으로 20 이동시킨<br>( 30, 10, 10, 1 ) 벡터값을 얻게 됩니다.<br><code>(w = 1 일때 x 방향으로 이동하였으므로 위치가 변경되었습니다.)</code></p><p><img src="/images/webgl6/matrix04.png" alt="matrix 변환"></p><p>자신을 X 방향으로 20만큼 평행이동 시키면 위와 같이 계산을 하게되고,<br>결과는 벡터 ( 0, 0, -1, 0 )을 X 방향으로 20 이동시켰으나<br>변함이 없는 ( 0, 0, -1, 0 ) 벡터값을 얻게 됩니다.<br><code>(w = 0 일때 x 방향으로 이동하였으나 변화가 없습니다.)</code><br><code>이유는 바로 점은 이동하면 다른 좌표값을 갖는 점이 되지만 벡터는 이동한다고 방향이나 크기가 변하지 않기 때문입니다</code></p><h4 id="단위-행렬"><a href="#단위-행렬" class="headerlink" title="단위 행렬"></a>단위 행렬</h4><p>단위 행렬은 주 대각선이 1이고 나머지가 0인 행렬이고, 아무것도 하지않는 행렬입니다.</p><p><img src="/images/webgl6/matrix05.png" alt="matrix 변환"></p><p>단위행렬에 벡터값(x, y, z, w)을 곱하면 벡터값 자신이 나오기 때문에 아무것도 하지 않습니다.</p><p>이를 이용하여 우리는 scale 매트릭스, translate 매트릭스, rotate 매트릭스등을 활용할 수 있습니다.<br>예를 들어 scale 매트릭스는 아래의 그림과 같습니다.</p><h4 id="Scale-행렬"><a href="#Scale-행렬" class="headerlink" title="Scale 행렬"></a>Scale 행렬</h4><p><img src="/images/webgl6/matrix06.png" alt="matrix 변환"></p><p>벡터값을 모든방향으로 2배 scale하려면</p><p><img src="/images/webgl6/matrix07.png" alt="matrix 변환"></p><p>벡터값의 x,y,z가 아닌 scale 매트릭스의 x,y,z값을 2배로 주면 벡터값이 2배가 되고,<br>실제 코드에선 아래와 같이 사용됩니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mat4.scale(mvMatrix, [<span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">2.0</span>]);</span><br><span class="line"><span class="comment">// 스캐일 매트릭스 사용법</span></span><br></pre></td></tr></table></figure><p>!! 만약 scale, translate, rotate를 같이 사용할때는 꼭 순서를 지켜서 사용하여야 합니다.<br>순서는 translate -&gt; rotate -&gt; scale</p><p>위와 같이 단위 행렬, 평행이동 행렬, Scale 행렬 등 여러 행렬을 따로 구현 하는 것 보다는<br>이미 나와있는 기존의 라이브러리를 활용하는 것이 좋습니다.</p><p>우리는 gl-matrix라는 라이브러리를 사용하려고 하고,<br>해당 라이브러리의 주소는 <a href="http://glmatrix.net" target="_blank" rel="noopener">http://glmatrix.net</a> 입니다.</p><p>해당 페이지의 내용과 이미지의 출처는<br><a href="https://webglfundamentals.org/" target="_blank" rel="noopener">https://webglfundamentals.org/</a> 입니다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-6-Martrix&quot;&gt;&lt;a href=&quot;#WebGL-6-Martrix&quot; class=&quot;headerlink&quot; title=&quot;WebGL ( 6 - Martrix )&quot;&gt;&lt;/a&gt;WebGL ( 6 - Martri
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL 기초( 5 - 도형 이동 )</title>
    <link href="http://shs400.github.io/2018/11/01/WebGL-5/"/>
    <id>http://shs400.github.io/2018/11/01/WebGL-5/</id>
    <published>2018-11-01T07:58:46.000Z</published>
    <updated>2019-01-23T07:21:33.838Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-기초-5-도형-이동"><a href="#WebGL-기초-5-도형-이동" class="headerlink" title="WebGL 기초( 5 - 도형 이동 )"></a>WebGL 기초( 5 - 도형 이동 )</h1><p>이번에는 삼각형에 움직임을 추가해보려고 합니다.</p><p>이를 위해서 애니메이션 루프를 설정해야하는데<br>setTimeout 이나 setInterveal 보다 requestAnimationFrame 활용할 예정입니다.</p><p>앞의 두 메서드가 아닌 requestAnimationFrame 사용하려는 이유는<br>좀 더 정확하고, 다른 브라우저 탭을 보고 있는 동안에는 씬에 애니메이션을 적용하지 않기 때문입니다.<br>( 예외로 requestAnimationFrame 사용하면 모바일 기기에서 불필요한 배터리 수명을 줄일 수 있다고 합니다.)</p><p>애니메이션을 만들게 될때 씬의 뷰를 움직이는 방법이있는데,<br>현재는 뷰를 조절하는 법을 모르기때문에 모델의 좌표계를 수정하여 움직임을 주도록 작성하였습니다.</p><p>requestAnimationFrame 지원이 브라우저마다 다르기때문에<br>사용항 브라우저에서 지원되는지를 확인하고 사용하여야 하거나 polyfill을 통해 수행할 수 있습니다.<br>url : <a href="https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/" target="_blank" rel="noopener">https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// setupWebGL();</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// initShader();</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// setupBuffers();</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// drawScene();</span></span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="comment">// 기존에 init해주던 부분에 animLoop를 호출하여 계속 반복시킵니다.</span></span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="undefined">  initShader();</span></span><br><span class="line"><span class="undefined">  setupBuffers();</span></span><br><span class="line"><span class="javascript">  (<span class="function"><span class="keyword">function</span> <span class="title">animLoop</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">    setupWebGL();</span></span><br><span class="line"><span class="undefined">    setupDynamicBuffers();</span></span><br><span class="line"><span class="undefined">    drawScene();</span></span><br><span class="line"><span class="undefined">    requestAnimationFrame(animLoop, canvas);</span></span><br><span class="line"><span class="undefined">  &#125;)();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>requestAnimationFrame의 첫번째 파라미터는 콜백 함수이고,<br>두번째 인자는 애니메이션의 대상이되는 엘리먼트입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> angle = <span class="number">0.0</span>;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">setupDynamicBuffers</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 변환 범위를 -0.5 ~ 0.5로 제한하기위해 sin 사용</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> x_translation = <span class="built_in">Math</span>.sin(angle)/<span class="number">2.0</span>;</span></span><br><span class="line"><span class="undefined">              </span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> positionsColor = [</span></span><br><span class="line"><span class="javascript">        <span class="number">-0.5</span> + x_translation,  <span class="number">0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 1</span></span></span><br><span class="line"><span class="javascript">        <span class="number">-0.5</span> + x_translation, <span class="number">-0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 2</span></span></span><br><span class="line"><span class="javascript">        <span class="number">0.5</span> + x_translation, <span class="number">-0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 3</span></span></span><br><span class="line"><span class="undefined">      ];</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined">      positionsColorBuffer = gl.createBuffer();</span></span><br><span class="line"><span class="undefined">      gl.bindBuffer(gl.ARRAY_BUFFER, positionsColorBuffer);</span></span><br><span class="line"><span class="javascript">      gl.bufferData(gl.ARRAY_BUFFER, <span class="keyword">new</span> <span class="built_in">Float32Array</span>(positionsColor), gl.DYNAMIC_DRAW);</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> triangleVertices = [</span></span><br><span class="line"><span class="javascript">        <span class="number">-0.5</span> + x_translation,  <span class="number">0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 1</span></span></span><br><span class="line"><span class="javascript">        <span class="number">-0.5</span> + x_translation, <span class="number">-0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 2</span></span></span><br><span class="line"><span class="javascript">        <span class="number">0.5</span> + x_translation, <span class="number">-0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 3</span></span></span><br><span class="line"><span class="undefined">      ];</span></span><br><span class="line"><span class="undefined">      angle += 0.01;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined">      trianglesVerticeBuffer = gl.createBuffer();</span></span><br><span class="line"><span class="undefined">      gl.bindBuffer(gl.ARRAY_BUFFER, trianglesVerticeBuffer);</span></span><br><span class="line"><span class="javascript">      gl.bufferData(gl.ARRAY_BUFFER, <span class="keyword">new</span> <span class="built_in">Float32Array</span>(triangleVertices), gl.DYNAMIC_DRAW);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>가장 중요한 것은 정점이나 데이터가 변경될때는 정점의 타입을<br>STATIC_DRAW에서 DYNAMIC_DRAW로 바꾸어야한다는 것입니다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/j6p9qozr/embedded/result/dark" frameborder="0" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-기초-5-도형-이동&quot;&gt;&lt;a href=&quot;#WebGL-기초-5-도형-이동&quot; class=&quot;headerlink&quot; title=&quot;WebGL 기초( 5 - 도형 이동 )&quot;&gt;&lt;/a&gt;WebGL 기초( 5 - 도형
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL 기초( 4 - Shader 이해 &amp; 색상 채우기 )</title>
    <link href="http://shs400.github.io/2018/10/31/WebGL-4/"/>
    <id>http://shs400.github.io/2018/10/31/WebGL-4/</id>
    <published>2018-10-31T05:06:29.000Z</published>
    <updated>2019-05-03T06:33:27.578Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-기초-4-Shader-이해-amp-색상-채우기"><a href="#WebGL-기초-4-Shader-이해-amp-색상-채우기" class="headerlink" title="WebGL 기초( 4 - Shader 이해 &amp; 색상 채우기 )"></a>WebGL 기초( 4 - Shader 이해 &amp; 색상 채우기 )</h1><p>이번에는 Shader에서 알아보고<br>삼각형에 색상을 그라이데이션으로 넣어보는 작업을 하도록 하겠습니다.</p><h3 id="Shader의-이해"><a href="#Shader의-이해" class="headerlink" title="Shader의 이해"></a>Shader의 이해</h3><p>GPU는 아래와 같이 2가지 일을 합니다. </p><ol><li>원본의 정점을 클립공간 정점으로 처리</li><li>클립공간을 pixel로 처리</li></ol><p>vertexShader 셰이더와 fragmentShader는 GPU가 이러한 일들을 할 수 있도록<br>명령과 계산된 데이터를 전달하는 기능을 수행합니다. </p><p>먼저 vertex-Shader와 fragment-Shader를 작성해줍니다.<br>(* vertex-Shader : 정점, fragment-Shader : 색상 )</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 버텍스 셰이더 작성 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"shader-vs"</span> <span class="attr">type</span>=<span class="string">"x-shader/x-vertex"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  attribute vec4 aVertexPosition;  </span></span><br><span class="line"><span class="undefined">  uniform mat4 u_matrix;</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="keyword">void</span> main(<span class="keyword">void</span>) &#123;</span></span><br><span class="line"><span class="undefined">    gl_Position = u_matrix * aVertexPosition;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 클립공간은 -1.0 ~ 1.0의 범위 인데 </span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// gl_Position * 0.5 + 0.5 하여 0.0 ~ 1.0 으로 변경하였다.</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> primitiveType = gl.TRIANGLES;</span><br><span class="line"><span class="keyword">var</span> offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">9</span>;</span><br><span class="line">gl.drawArrays(primitiveType, offset, count);</span><br></pre></td></tr></table></figure><p><img src="/images/vertex-shader-anim.gif" alt="버텍스셰이"><br>출처 : webglfundamentals.org</p><p>위의 이미지와 같이 원본 정점 9개를 작성한 vertexShader 함수를 통하여<br>GLSL에서 정의된 변수인 gl_Position에 주면 클립공간 정점으로 GPU에 저장합니다.</p><p>gl.drawArrays() 함수를 호출할 때 primitiveType을 TRIANGLES로 지정하였기 때문에<br>3개의 클립공간의 정점이 생성될 때마다 GPU는 이를 이용해 삼각형을 그리게 됩니다.</p><p>이 삼각형을 그릴때 아래의 그림과 같이 3개의 정점을 기준으로 래스터화 합니다.</p><ul><li>래스터화 = ‘삼각형을 픽셀로 그림’<br>Ex) <img src="/images/webgl4/webgl4_1.png" alt="정점삼각형"> &gt;&gt; <img src="/images/webgl4/webgl4_2.png" alt="삼각형래스터화"></li></ul><p>래스터화를 할 때 삼각형을 구성하는 각각의 픽셀에 대해서 프래그먼트 셰이더를 호출하게 되는데<br>이때 프래그먼트 셰이더는 특수변수인 gl_FragColor를 통해 각 픽셀의 색상을 알려주게 됩니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 프래그먼트 셰이더 작성 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"shader-fs"</span> <span class="attr">type</span>=<span class="string">"x-shader/x-fragment"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  precision mediump float; <span class="comment">// 실수 정확도</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 낮은 정도의 precision을 가질수록 빠른 렌더 속도를 가지지만 렌더 퀄리가 그만큼 떨어진다.</span></span></span><br><span class="line"><span class="undefined">  varying vec4 v_color;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">void</span> main(<span class="keyword">void</span>) &#123;</span></span><br><span class="line"><span class="javascript">    gl_FragColor = vec4(<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>); <span class="comment">// vec4(R,G,B,A)</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// GLSL의 색상값은 0~1 의 값으로 나타낸다.</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/7osmx9rz/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>이를 응용하면 아래와 같이 응용할 수 있습니다.</p><p>참고)<br>varing은 vertexShader에서 만든 데이터를 에서 fragmentShader에게 전달하는데 사용됩니다.<br>(* varing의 타입과 이름이 동일해야 연결이 됩니다.)</p><ol><li>프래그먼트 셰이더는 래스터화된 점, 선, 면 등을 구성하는 픽셀 수 만큼 호출된다.</li><li>버텍스 셰이더에서 설정한 배어링 값은 선의 경우 2점 보간, 삼각형의 경우 3점 보간을 해서<br>프래그먼트 셰이더에게 전달된다(배어링은 보간되어 전달된다는 점이 중요합니다).</li></ol><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/oct0k29f/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>아래의 그림을 통하여 정점 3개의 삼각형의 v_color가 보간되어 레스터화 되는 동작을 확인할 수 있습니다.</p><iframe src="https://webglfundamentals.org/webgl/lessons/resources/fragment-shader-anim.html" width="400px" height="300px" frameborder="0" allowfullscreen></iframe><p>출처 : [webglfundamentals.org]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-기초-4-Shader-이해-amp-색상-채우기&quot;&gt;&lt;a href=&quot;#WebGL-기초-4-Shader-이해-amp-색상-채우기&quot; class=&quot;headerlink&quot; title=&quot;WebGL 기초( 4 -
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL 기초( 3 - 삼각형 그리기 )</title>
    <link href="http://shs400.github.io/2018/08/08/WebGL-3/"/>
    <id>http://shs400.github.io/2018/08/08/WebGL-3/</id>
    <published>2018-08-08T11:18:53.000Z</published>
    <updated>2019-01-23T07:21:33.845Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-기초-3-삼각형-그리기"><a href="#WebGL-기초-3-삼각형-그리기" class="headerlink" title="WebGL 기초( 3 - 삼각형 그리기 )"></a>WebGL 기초( 3 - 삼각형 그리기 )</h1><p>모든 준비가 완료되었으니 마지막으로 렌더링을 시작하겠습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 클리어 색상을 녹색으로 설정</span></span><br><span class="line">gl.clearColor(<span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.1</span>, <span class="number">1.0</span>);</span><br><span class="line">gl.clear(gl.COLOR_BUFFER_BIT);</span><br></pre></td></tr></table></figure><p>초기화시 클리어 색상값(R,G,B,A)을 정하고 클리어하게되면<br>작성자가 정한 색으로 캔버스의 배경색이 칠해지게 됩니다.</p><p>그 후 WebGL이 앞서 만든 프로그램을 사용가능 하도록 해줍니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 앞장에서 glProgram 이라는 프로그램을 만듬</span></span><br><span class="line"><span class="comment">// 프로그램 사용</span></span><br><span class="line">gl.useProgram(glProgram);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 참조한 위치 애트리뷰트를 사용할 것임을 알려줍니다.</span></span><br><span class="line">gl.enableVertexAttribArray(positionAttributeLocation);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 위치 버퍼를 바인드 합니다.</span></span><br><span class="line"><span class="comment">// 어느 버퍼를 사용할지 바인드 포인트로 지정하는 셈입니다.</span></span><br><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// positionBuffer (ARRAY_BUFFER)에서 데이터를 가져오는</span></span><br><span class="line"><span class="comment">// 방법을 위치 애트리뷰트에게 알려 줌</span></span><br><span class="line"><span class="keyword">var</span> size = <span class="number">2</span>;          <span class="comment">// 각 반복마다 2개씩 버퍼 데이타 참조</span></span><br><span class="line"><span class="keyword">var</span> type = gl.FLOAT;   <span class="comment">// 32bit 부동 소수점 값</span></span><br><span class="line"><span class="keyword">var</span> normalize = <span class="literal">false</span>; <span class="comment">// 데이터를 노말라이즈 하지 않는다.</span></span><br><span class="line"><span class="keyword">var</span> stride = <span class="number">0</span>;        <span class="comment">// 0 = move forward size * sizeof(type) 각 반복마다 다음 위치</span></span><br><span class="line"><span class="keyword">var</span> offset = <span class="number">0</span>;        <span class="comment">// 버퍼 시작 위치</span></span><br><span class="line">gl.vertexAttribPointer(</span><br><span class="line">  positionAttributeLocation,</span><br><span class="line">  size,</span><br><span class="line">  type,</span><br><span class="line">  normalize,</span><br><span class="line">  stride,</span><br><span class="line">  offset</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이제 마지막으로 WebGL 에게 만든 GLSL 프로그램을 실행하라고 요청을 해봅시다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GLSL 프로그램을 실행하도록 요청</span></span><br><span class="line"><span class="keyword">var</span> primitiveType = gl.TRIANGLES;</span><br><span class="line"><span class="keyword">var</span> offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">3</span>;</span><br><span class="line">gl.drawArrays(primitiveType, offset, count);</span><br></pre></td></tr></table></figure></p><p>이제는 아래와 같이 두개의 삼각형이 보이게 될 것입니다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/6szy70u2/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>마지막으로 drawArrays에 사용되는 원시타입에 대해 설명을 하자면</p><p><code>원시 타입(primitiveType)</code><br>원시 타입은 특정 그래픽 언어에서<br>모델을 개발할 때 사용하는 그래픽 구성 요소입니다.<br>웹지엘에는 7개의 원시타입이 있는데<br><img src="/images/primitive_type.png" alt="원시타입"><br><code>좌측 상단부터 우측 하단 순서</code><br>POINTS, LINES, LINE_STRIP, LINE_LOOP,<br>TRIANGLES, TRIANGLE_STRIP, TRIANFLE_FAN 이 있습니다.</p><ul><li><p>POINTS<br>POINTS는 한번에 하나씩 렌더링되는 정점(공간좌표)입니다.<br>(총 정점 : 4개)</p></li><li><p>LINES<br>정점의 쌍을 따라 형태를 이룹니다.<br>두개의 선이 같은 정점을 공유하고 있찌만, 각선은 별로도 정의 되어있습니다.<br>(총 정점 : 6개)</p></li><li><p>LINE_STRIP<br>첫번째 선을 제외하고 각 선의 시작점이 이전 선의 끝점인 정점 컬렉션으로 이뤄집니다.<br>LINE_STRIP에서는 여러 선에서 일부 정점을 재사용합니다.<br>(총 정점 : 5개) </p></li><li><p>LINE_LOOP<br>첫번째 정점과 마지막 정점이 다시 연결돼 닫힌 고리를 형성한다는 점 을 제외하곤 LINE_STRIP과 유사합니다.<br>(총 정점 : 5개)</p></li><li><p>TRIANGLES<br>삼각형당 정점 3개로 이뤄집니다.<br>위 그림에서 삼각형 3개를 그리는데 삼각형별로 정점 3개씩 필요하며,<br>LINES와 마찬가지로 공유된 정점은 우연히 겹쳐 있을 뿐입니다.<br>(총 정점 : 9개)</p></li><li><p>TRIANGLE_STRIP<br>ABC, (BC)D, (CD)E, (DE)F, (EF)G, (FG)H, (GH)I 정점을 통해 형성됩니다.<br>여러 삼각형에서 정점을 재사용 하여 삼각형을 렌더링 합니다.<br>(총 정점 : 9개)</p></li><li><p>TRIANFLE_FAN<br>삼각형의 일부로 지정한 첫번쨰 정점을 사용합니다.<br>첫번째 정점 A는 7번 사용 나머지 정점은 2번씩 사용됩니다.<br>(총 정점 : 8개)</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-기초-3-삼각형-그리기&quot;&gt;&lt;a href=&quot;#WebGL-기초-3-삼각형-그리기&quot; class=&quot;headerlink&quot; title=&quot;WebGL 기초( 3 - 삼각형 그리기 )&quot;&gt;&lt;/a&gt;WebGL 기초( 
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL 기초( 2 - 삼각형 그리기 준비 )</title>
    <link href="http://shs400.github.io/2018/08/08/WebGL-2/"/>
    <id>http://shs400.github.io/2018/08/08/WebGL-2/</id>
    <published>2018-08-08T06:04:46.000Z</published>
    <updated>2019-01-23T07:21:33.849Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-기초-2-삼각형-그리기-준비"><a href="#WebGL-기초-2-삼각형-그리기-준비" class="headerlink" title="WebGL 기초( 2 - 삼각형 그리기 준비 )"></a>WebGL 기초( 2 - 삼각형 그리기 준비 )</h1><p>이번에는 코드를 보며 아래와 같이 삼각형을 만들어보기로 합니다.</p><h3 id="1-셰이더-작성"><a href="#1-셰이더-작성" class="headerlink" title="1 - 셰이더 작성"></a>1 - 셰이더 작성</h3><p>먼저 앞장에서 작업한 버텍스 셰이더와 프래그먼트 셰이더를 작성합니다.</p><h3 id="2-WebGL-렌더링-컨텍스트-생성하기"><a href="#2-WebGL-렌더링-컨텍스트-생성하기" class="headerlink" title="2 - WebGL 렌더링 컨텍스트 생성하기"></a>2 - WebGL 렌더링 컨텍스트 생성하기</h3><p>WebGL 렌더링 컨텍스트는 canvas로부터 얻어올 수 있습니다.</p><p>canvas는 ‘2D’와 ‘webgl’이라는 두개의 캔버스 context가 있습니다.<br>canvas는 둘 중 어떤 컨텍스트를 사용하든 상관하지 않지만<br>원하는 API를 노출하는 적절한 객체를 제공해주려면<br>canvas에게 명시적으로 알려줘야 합니다.</p><p>context를 가져오려면 canvas의 getContext 메소드를 호출하면됩니다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrap'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"my-canvas"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span></span><br><span class="line">      해당 브라우저는 html5 canvas element를 지원하지 않습니다.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> gl = <span class="literal">null</span>,</span></span><br><span class="line"><span class="javascript">      canvas = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">    canvas = <span class="built_in">document</span>.getElementById(<span class="string">'my-canvas'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">try</span>&#123;</span></span><br><span class="line"><span class="javascript">      gl = canvas.getContext(<span class="string">'webgl'</span>) || </span></span><br><span class="line"><span class="javascript">      canvas.getContext(<span class="string">'experimental-webgl'</span>);</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">catch</span> (e)&#123;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>*getContext<br>-첫번째 파라미터 : context이름<br>-두번째 파라미터 : 선택인자</p><h3 id="3-셰이더-컴파일-및-링크-gt-프로그램-생성"><a href="#3-셰이더-컴파일-및-링크-gt-프로그램-생성" class="headerlink" title="3 - 셰이더 컴파일 및 링크 -&gt; 프로그램 생성"></a>3 - 셰이더 컴파일 및 링크 -&gt; 프로그램 생성</h3><p>지금까지 작성한 셰이더를 GPU에서 동작하도록 단계별로 진행합니다.</p><p><strong>1단계</strong><br>정점 셰이더와 프래그먼트 셰이더의 문자열을 가져옵니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vertexShaderSource = <span class="built_in">document</span>.getElementById(<span class="string">"2d-vertex-shader"</span>).text;</span><br><span class="line"><span class="keyword">var</span> fragmentShaderSource = <span class="built_in">document</span>.getElementById(<span class="string">"2d-fragment-shader"</span>).text;</span><br></pre></td></tr></table></figure></p><p><strong>2단계</strong><br>셰이더 생성 및 컴파일을 합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 셰이더 컴파일</span></span><br><span class="line"><span class="keyword">var</span> vertextShader = makeShader(vertexShaderSource, gl.VERTEX_SHADER),</span><br><span class="line">    fragmentShader = makeShader(fragmentShaderSource, gl.FRAGMENT_SHADER);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeShader</span>(<span class="params">src, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> shader = gl.createShader(type);</span><br><span class="line">  gl.shaderSource(shader, src);</span><br><span class="line">  gl.compileShader(shader);</span><br><span class="line">  <span class="keyword">return</span> shader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>3단계</strong><br>2개의 셰이더를 1개의 프로그램에 연결하기<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 프로그램 생성</span></span><br><span class="line"><span class="comment">// 프로그램은 vertexShader,fragmentShader 두쌍을 합쳐서 프로그램이라고 합니다.</span></span><br><span class="line">glProgram = gl.createProgram();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 프로그램에 셰이더 첨부 및 연결</span></span><br><span class="line">gl.attachShader(glProgram, vertexShader);</span><br><span class="line">gl.attachShader(glProgram, fragmentShader);</span><br><span class="line">gl.linkProgram(glProgram);</span><br></pre></td></tr></table></figure></p><p>여기까지가 하나의 GLSL프로그램을 만드는 과정입니다.</p><h3 id="4-셰이더에서-참조할-데이터-넣기"><a href="#4-셰이더에서-참조할-데이터-넣기" class="headerlink" title="4 - 셰이더에서 참조할 데이터 넣기"></a>4 - 셰이더에서 참조할 데이터 넣기</h3><p>이제부터 WebGL API를 사용하여 앞에서 만든 GLSL프로그램에서 참조할 데이터를 넣어줄 것입니다.</p><p>앞에서 만든 GLSL프로그램에서 aVertexPosition 애트리뷰트를 사용하였는데,<br>이 애트리뷰트에서 소비할 데이터를 제공할 버퍼를 만들어 줍니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> triangleVerticeBuffer = gl.createBuffer();</span><br><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, triangleVerticeBuffer);</span><br></pre></td></tr></table></figure></p><hr><p><strong>bindBuffer( target, mybuffer )</strong></p><hr><p>WebGL은 내부에 버퍼를 여러개 생성하고 관리할 수 있습니다.<br>그래서 어떤 버퍼를 사용하고 있는지 일려주어야 하는데, 어떤 버퍼를 사용하고 있다고 가리키는 것을<br><code>바인드 포인트(bind point)</code>라고 합니다.<br>그렇기 때문에 bindBuffer 함수를 실행하면 바인드 포인트는 triangleVerticeBuffer를 가리키게 되고,<br>이후에 제공되는 데이터는 이 바인드 포인트가 가리키는 버퍼에 입력되게 됩니다.</p><p>bindBuffer의 첫번째 인자로는 상수 값<br>ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER 이 들어가는데<br>ARRAY_BUFFER는 타깃 버퍼가 <code>위치 및 색상같은 정점 어트리뷰트</code>에 사용될때,<br>ELEMENT_ARRAY_BUFFER는 타깃 버퍼가 <code>정점 인덱스를 포함할 때</code> 사용합니다.</p><p>그후 bufferData를 통해 GPU에 데이터를 올리게 됩니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> triangleVertices = [</span><br><span class="line">  <span class="comment">// 왼쪽 삼각형</span></span><br><span class="line">  <span class="number">-0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>,</span><br><span class="line">   <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">  <span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0.0</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 오른쪽 삼각형</span></span><br><span class="line">  <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>,</span><br><span class="line">  <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">  <span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0.0</span></span><br><span class="line">];</span><br><span class="line"><span class="comment">// 공간 좌표 (x,y,z)이고 값은 캔버스 크기로부터 -1~1 까지 표현된다.</span></span><br><span class="line">gl.bufferData(gl.ARRAY_BUFFER, <span class="keyword">new</span> <span class="built_in">Float32Array</span>(triangleVertices), gl.STATIC_DRAW);</span><br></pre></td></tr></table></figure></p><p>WebGL은 강력한 형의 값을 요구하기 때문에<br>데이터를 32비트 부동 소수점 형식의 값의 배열로 만들기 위해 Float32Array를 사용해 줍니다.<br>이때 앞에서 정의 한 triangleVerticeBuffer를 인자로 넘기지 않는 이유는<br>이미 바인드 포인트가 triangleVerticeBuffer를 가리키고 있기때문 입니다.</p><hr><p><strong>bufferData( target, data, usage )</strong></p><hr><p>bufferData 호출에서 세번째 파라미터 usage(용법)는 3가지가 존재하는데,<br>최적화와 관련된 상수라고 합니다.(파악안됨..)</p><ul><li><p>STATIC_DRAW<br>데이터를 한번만 설정하고 애플리케이션이 여러번 사용하는 동안 다시 변경하지 않습니다.</p></li><li><p>DYNAMIC_DRAW<br>애플리케이션에서 데이터를 여러번 사용하지만 매번 내용을 재설정합니다.</p></li><li><p>STREAM_DRAW<br>데이터를 변경하지 않습니다.</p></li></ul><h3 id="5-애트리뷰트-참고하기"><a href="#5-애트리뷰트-참고하기" class="headerlink" title="5 - 애트리뷰트 참고하기"></a>5 - 애트리뷰트 참고하기</h3><p>마지막으로 앞서 만든 GLSL 프로그램에서 애트리뷰트로 aVertexPosition이 사용되는데,<br>WebGL API를 통하여 프로그램에 정의된 애트리뷰트의 위치를 얻어옵니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var positionAttributeLocation = gl.getAttribLocation(program, &quot;aVertexPosition&quot;);</span><br></pre></td></tr></table></figure><p>getAttribLocation()함수를 이용해 프로그램의 a_position 애트리뷰트의 위치를 참조했습니다.</p><p>셰이더 컴파일 및 링크, 데이터를 버퍼에 제공, 애트리뷰트의 위치를 참조까지 완료하면<br>삼각형을 그리기 위한 준비가 완료됩니다.</p><p>이 과정은 초기화 과정으로 전체 코드 동작중 한번만 실행하도록 해야한다고 합니다.</p><p>다음 장에서는 WebGL 기초 마지막으로<br>삼각형을 그려보도록 하겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-기초-2-삼각형-그리기-준비&quot;&gt;&lt;a href=&quot;#WebGL-기초-2-삼각형-그리기-준비&quot; class=&quot;headerlink&quot; title=&quot;WebGL 기초( 2 - 삼각형 그리기 준비 )&quot;&gt;&lt;/a&gt;W
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL 기초( 1 - 시작 )</title>
    <link href="http://shs400.github.io/2018/08/06/WebGL-1/"/>
    <id>http://shs400.github.io/2018/08/06/WebGL-1/</id>
    <published>2018-08-06T07:28:35.000Z</published>
    <updated>2019-05-03T06:33:27.575Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-기초-1-시작하기"><a href="#WebGL-기초-1-시작하기" class="headerlink" title="WebGL 기초( 1 - 시작하기 )"></a>WebGL 기초( 1 - 시작하기 )</h1><p>기초에서는 삼각형을 그리는것을 목표로 합니다.</p><p>우선 WebGL은 래스터화 엔진 중 하나입니다.<br>래스터화는 벡터 또는 윤곽선 데이터를 비트맵으로 바꾸는 과정을 의미합니다.<br>개발자는 WebGL 3D API를 사용해 코드를 작성하면 점, 선, 도형 등을 그릴 수 있습니다.</p><p>WebGL은 컴퓨터의 GPU(Graphic Processing Unit)에서 운영됩니다.<br>그래서 GPU에 실행명령을 수행하기 위해 셰이더가 필요하고<br>그 셰이더에는 2개의 함수가 제공되는데,<br>각각을 <code>정점 셰이더(or 버텍스 셰이더)</code>, <code>프래그먼트 셰이더(or 픽셀 셰이더)</code> 라고합니다.</p><p>이 셰이더 함수들은 GLSL(GL Shader Language)라고 하는 C/C++ 언어로 작성할 수 있습니다.<br>(GLSL에 대해서는 후에 설명)</p><h2 id="셰이더-Shader"><a href="#셰이더-Shader" class="headerlink" title="셰이더(Shader)"></a>셰이더(Shader)</h2><p>셰이더란 화면에 출력할 픽셀의 위치와 색상을 계산하는 함수입니다.</p><p>정점은 셰이더로 넘겨줄 수 있는 어트리뷰트를 갖고 있습니다.<br>또한 각 정점별로 일정한 유니폼 값도 셰이더로 넘겨 줄 수 있는데,<br>자세한 내용은 뒤에 다루기로 하겠습니다.</p><p>지금은 셰이더엔 <code>정점 셰이더</code>와 <code>프래그먼트 셰이더</code>가 있고,<br>하는일은 아래와 같다는 정도만 알고 있기로 합니다.</p><ul><li>정점(vertex) 셰이더 : 정점의 최종 위치를 설정</li><li>프래그먼트 셰이더 : 각 픽셀의 최종 색상을 설정</li></ul><p>화면안의 그려줄 영역의 위치를 계산해 주는 함수를 정점 셰이더라고 하고,<br>영역안의 픽셀들마다 색상을 계산해서 그려주는 함수를<br>프래그먼트 셰이더(픽셀 셰이더) 라고합니다.</p><p><img src="/images/shader.png" alt="셰이더과정"><br>이미지 출처 : [<a href="https://github.com/ejonghyuck/TIL/blob/master/Shader/shader.md]" target="_blank" rel="noopener">https://github.com/ejonghyuck/TIL/blob/master/Shader/shader.md]</a></p><h2 id="셰이더가-참고할-데이터를-제공하는-방법"><a href="#셰이더가-참고할-데이터를-제공하는-방법" class="headerlink" title="셰이더가 참고할 데이터를 제공하는 방법"></a>셰이더가 참고할 데이터를 제공하는 방법</h2><p>셰이더는 GPU에 공급된 데이터로 어떻게 그림을 그리는지 GPU에 시킬 명령들을 선언한 함수일뿐입니다.<br>함수를 실행하기 전에 셰이더가 그림을 그리기 위한 데이터를 GPU에 제공해야하는데</p><p>방법으로는 4가지가 있습니다.</p><ol><li><p>애트리뷰트<br>애트리뷰트는 버터를 사용합니다.<br>버퍼 : 개발자가 GPU에 올려줄 바이너리 배열 데이터입니다.<br>또한 애트리뷰트는 vertex shader에서만 사용되며 읽기 전용 값 입니다.</p></li><li><p>유니폼<br>유니폼은 셰이더 실행하기 전에 정의하는 전역 변수입니다.<br>이 전역 변수에 변환 행렬 정보나 특정 필터 정보 또는 뷰포트 정보 등을 정의해두면 셰이더가 이 변수의 데이타를 참고할 수 있습니다.<br>JavaScript에서 uniformMatrix#fv()를 통해 전달 받은 값을 저장하며 주로 변형(이동, 회전, 스케일)을 계산하기 위한 벡터가 넘어옴</p></li><li><p>텍스쳐<br>텍스처는 셰이더에서 무작위로 접근이 가능한 배열로 된 데이타입니다.<br>텍스처는 보통 이미지 데이터라고 생각할 수 있지만 텍스처 자체는 단순한 데이타이기 때문에 색상 뿐아니라 다른 것도 쉽게 추가시킬 수 있습니다.</p></li><li><p>배어링<br>버텍스 셰이더에서 만든 데이터를 프래그먼트 셰이더에게 전달하는데 쓰입니다.<br>vertex shader에서 계산된 값을 fragment shader로 전달해 줄 때 사용합니다.</p></li></ol><p>Ex) 버텍스 셰이더와 프래그먼트 셰이더<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>WebGL<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  body &#123; background: grey; &#125;</span></span><br><span class="line"><span class="undefined">  canvas &#123; background: white; &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 캔버스 정의 - WebGL의 결과 랜더링 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"my-canvas"</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"500"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- 버텍스 셰이더 작성 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"shader-vs"</span> <span class="attr">type</span>=<span class="string">"x-shader/x-vertex"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    attribute vec3 aVertexPosition;</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">    <span class="keyword">void</span> main(<span class="keyword">void</span>) &#123;</span></span><br><span class="line"><span class="undefined">      gl_Position = vec4(aVertexPosition, 1.0);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 프래그먼트 셰이더 작성 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"shader-fs"</span> <span class="attr">type</span>=<span class="string">"x-shader/x-fragment"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">void</span> main(<span class="keyword">void</span>) &#123;</span></span><br><span class="line"><span class="undefined">      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>코드를 보시면 각 셰이더에서<br>type 은 text/javascript가 아닌 임의의 값을 주면 됩니다.<br>이유는 셰이더가 javascript로 해석되지 않도록 하는 것이 목적이기 때문입니다.</p><p>셰이더에서 <code>attribute vec3 aVertexPosition</code> 는<br>attribute : 셰이더 변수 종류( attribute | uniform | varying )<br>vec3 : 배열 타입, vec3는 3행 배열<br>aVertexPosition : 배열 이름, 한 개의 버텍스를 나타냅니다. 관습적으로 맨 앞에 a를 붙여서 attribute임을 표시를 나타냅니다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/4ntr3obg/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>WebGL의 기본이 되는 canvas는 HTML5 스펙입니다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"my-canvas"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span></span><br><span class="line">    해당 브라우저는 html5 canvas element를 지원하지 않습니다.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="기본-canvas-화면"><a href="#기본-canvas-화면" class="headerlink" title="기본 canvas 화면"></a>기본 canvas 화면</h2><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/jr0xw1zg/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>※ html5 canvas 미지원시<br>‘해당 브라우저는 html5 canvas element를 지원하지 않습니다.’를 출력합니다.</p><h2 id="WebGL-기초"><a href="#WebGL-기초" class="headerlink" title="WebGL 기초"></a>WebGL 기초</h2><p>canvas는 ‘2D’와 ‘webgl’이라는 두개의 캔버스 context가 있습니다.</p><p>canvas는 둘 중 어떤 컨텍스트를 사용하든 상관하지 않지만<br>원하는 API를 노출하는 적절한 객체를 제공해주려면<br>canvas에게 명시적으로 알려줘야 합니다.</p><p>context를 가져오려면 canvas의 getContext 메소드를 호출하면됩니다.</p><ul><li>getContext</li></ul><ul><li>첫번째 파라미터 : context 타입 </li><li>두번째 파라미터 : context 속성</li></ul><p>Ex) canvas.getContext(‘experimental-webgl’, {<br>  antialias: false, // 앤티 앨리어싱을 수행할지 여부를 나타내는 부울 값입니다.<br>  depth: false  // 캔버스에 알파 버퍼가 있는지 여부를 나타내는 부울입니다.<br>});<br>// experimental-webgl은 WebGL이 정식으로 지원되지 않을 때 사용되던 이름</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = setupWebGL;</span><br><span class="line"><span class="keyword">var</span> gl = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// gl 은 웹지엘에서 컨텍스트 객체를 참조할 때 관례적으로 사용하는 변수명</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupWebGL</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"my-canvas"</span>);</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    gl = canvas.getContext(<span class="string">'experimental-webgl'</span>);</span><br><span class="line">  &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">    <span class="comment">//컨텍스트 가져오지 못하여 에러 발생시  </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(gl)&#123;</span><br><span class="line">    gl.clearColor(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// clearColor(R,G,B,A)</span></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">'WebGL 지원 안함'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/tLpjk184/embedded/result/dark" frameborder="0" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-기초-1-시작하기&quot;&gt;&lt;a href=&quot;#WebGL-기초-1-시작하기&quot; class=&quot;headerlink&quot; title=&quot;WebGL 기초( 1 - 시작하기 )&quot;&gt;&lt;/a&gt;WebGL 기초( 1 - 시작하기 
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 Transform</title>
    <link href="http://shs400.github.io/2018/06/07/CSS3-Study/"/>
    <id>http://shs400.github.io/2018/06/07/CSS3-Study/</id>
    <published>2018-06-07T00:46:00.000Z</published>
    <updated>2019-01-23T07:20:30.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="transform-화면-변형"><a href="#transform-화면-변형" class="headerlink" title="transform (화면 변형)"></a>transform (화면 변형)</h1><p>transform은 엘리먼트의 크기, 위치, 모양을 변경하는 속성입니다.</p><p>transform 함수들은 transform: scale(2, 0.5)같은 형태로 사용가능<br>다중으로 사용할경우에는 transform: scale(2, 0.5) rotate(45deg) 처럼 사용가능</p><p>X, Y, Z 축의 대한 이미지</p><p><img src="/images/x.gif" alt="x축 회전 이미지"></p><p><img src="/images/y.gif" alt="y축 회전 이미지"></p><p><img src="/images/z.gif" alt="z축 회전 이미지"></p><h2 id="scale-크기변경"><a href="#scale-크기변경" class="headerlink" title="scale - 크기변경"></a>scale - 크기변경</h2><p>2D 크기의 변환 함수.</p><p>Ex1) transform: scale(x,y)<br>y 값이 없을시 x 와 동일값으로 가정하여 계산</p><p>Ex2) transform: scaleX(x)<br>y 값이 없을시 y는 1값으로 가정하여 계산</p><p>Ex3) transform: scaleY(y)<br>x 값이 없을시 x는 1값으로 가정하여 계산</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/wcutdk8f/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="translate-이동"><a href="#translate-이동" class="headerlink" title="translate - 이동"></a>translate - 이동</h2><p>Ex) transform: translate(x,y)<br>좌표 평면에서의 2D 이동.<br>y의 값이 없으면 0으로 가정하여 계산</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/5zwejxg6/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="rotate-회전하기"><a href="#rotate-회전하기" class="headerlink" title="rotate - 회전하기"></a>rotate - 회전하기</h2><p>Ex) transform: rotate(angle)<br>요소를 자신의 원점(또는 transform-origin 속성에 설정된 지점)을 기준으로<br>angle 각도만큼 시계방향으로 회전시킨다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/kf3cxygv/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>transform-origin은 rotate(), skew() 등의<br>회전, 변형 속성을 사용하기 전에 기준점을 정해 두는 것이고<br>디폴트 값은 (50%, 50%)입니다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/h0ey5fcd/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="skew-기울이기"><a href="#skew-기울이기" class="headerlink" title="skew - 기울이기"></a>skew - 기울이기</h2><p>Ex) transform: skew(angleX, angleY)<br>요소에 x,y 축을 중심으로 각 angle 각도 만큼 기울인다.<br>angleY 값이 없으면 Y축 연산은 하지않는다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/e1wohf3v/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="matrix"><a href="#matrix" class="headerlink" title="matrix"></a>matrix</h2><p>Ex1) transform: matrix(1,2,3,4,5,6)<br>Ex2) matrix(scaleX(), skewY(), skewX(), scaleY(), translateX(), translateY());<br>martrix는 다른 함수들의 기초가 되는 함수입니다.<br>그래서 matrix를 제대로 쓸 줄 알면 다른 transform 함수들을 조합해서<br>사용하는 것보다 간결하게 작성할 수 있습니다.</p><p><img src="/images/matrix.png" alt="matrix 정보 이미지"></p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/6gj943kp/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="perspective-시점-또는-관찰자-관점-원근감-깊이감"><a href="#perspective-시점-또는-관찰자-관점-원근감-깊이감" class="headerlink" title="perspective - 시점(또는 관찰자 관점,원근감,깊이감)"></a>perspective - 시점(또는 관찰자 관점,원근감,깊이감)</h2><p>원근감을 제어합니다.<br>값이 작을 수록 가까이에서 보는 것 같이 느껴지고 3D 효과도 커집니다.</p><p>쉽게 표현하자면 멀리 떨어져있는것은 작게만들고<br>가까운곳에 있는것은 크게만들어서 원근감을 부여하는것입니다.<br>perspective() 함수를 이용해서 transform 속성에 지정할 수도 있고<br>perspective 속성을 이용해서 부모요소에 지정할 수도 있습니다.<br>부모요소에 지정할 경우 자식요소들이 동일한 소실점을 갖습니다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/u5gvdzy9/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="부모-perspective-와-자식-perspective-차이"><a href="#부모-perspective-와-자식-perspective-차이" class="headerlink" title="부모 perspective 와 자식 perspective 차이"></a>부모 perspective 와 자식 perspective 차이</h2><iframe scrolling="no" width="100%" height="600" src="//jsfiddle.net/enphb0fw/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>부모요소에 perspective을 주면<br>원근감이 개별적이지않고 전체적으로 영향을 주기때문에 각각의 요소의 변형이 다르게 나타난다.</p><p>하지만 자식요소에  perspective을 주면<br>요소마다 개별적으로 영향을 주기때문에 각각의 요소의 변형이 동일하다.</p><h2 id="perspective-와-translateZ"><a href="#perspective-와-translateZ" class="headerlink" title="perspective 와 translateZ"></a>perspective 와 translateZ</h2><iframe scrolling="no" width="100%" height="700" src="//jsfiddle.net/2kaw5fgu/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p><img src="/images/perspective.png" alt="원근감 이해 이미지"></p><h2 id="translate-와-rotate-동시-변화-및-순서-변경"><a href="#translate-와-rotate-동시-변화-및-순서-변경" class="headerlink" title="translate 와 rotate 동시 변화 및 순서 변경"></a>translate 와 rotate 동시 변화 및 순서 변경</h2><iframe scrolling="no" width="100%" height="700" src="//jsfiddle.net/zs8mL5w1/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>결과가 다른이유는 축을 기점으로 이동하기 때문이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;transform-화면-변형&quot;&gt;&lt;a href=&quot;#transform-화면-변형&quot; class=&quot;headerlink&quot; title=&quot;transform (화면 변형)&quot;&gt;&lt;/a&gt;transform (화면 변형)&lt;/h1&gt;&lt;p&gt;transform은 엘리먼
      
    
    </summary>
    
      <category term="css" scheme="http://shs400.github.io/categories/css/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/css/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/css/blog/study/"/>
    
    
      <category term="css" scheme="http://shs400.github.io/tags/css/"/>
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>javascript - call(),apply(), bind() 메서드</title>
    <link href="http://shs400.github.io/2018/01/02/script-study03/"/>
    <id>http://shs400.github.io/2018/01/02/script-study03/</id>
    <published>2018-01-02T07:43:50.000Z</published>
    <updated>2019-01-22T08:53:43.928Z</updated>
    
    <content type="html"><![CDATA[<p>call(),apply(), bind() 메서드<br><!-- excerpt --></p><p>앞서 설명하였던 기본적인 this 바인딩 3가지 방법 외에도<br>메서드를 이용하여 임의적으로 특정 객체에 바인딩 시키는 방법이 3가지 존재한다.</p><p>1) apply() 메서드</p><ul><li>apply은 파라미터 중 첫 번째 인자를 함수 내부에서 사용할 this로 만들어준다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Name = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objName = &#123;&#125;</span><br><span class="line">Name.apply(objName,[<span class="string">'sim'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(objName);</span><br><span class="line"><span class="comment">//&#123; name: 'sim' &#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>2) call() 메서드</p><ul><li>call은 apply와 기능은 같지만, 두번째 매개변수가 배열이 아닌 각각의 값으로 넘길 수 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Name = <span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objName = &#123;&#125;</span><br><span class="line">Name.call(objName,<span class="string">'sim'</span>,<span class="number">31</span>);</span><br><span class="line"><span class="built_in">console</span>.log(objName);</span><br><span class="line"><span class="comment">//&#123; name: 'sim', age: 31&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>3) bind() 메서드 ※ es5 문법</p><ul><li>함수가 가리키는 this만 바꾸고 호출하지는 않음.</li><li>새 함수를 만드는데 그 this는 bind에 전달된 값. <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"> <span class="keyword">var</span> example = &#123; <span class="attr">color</span> : <span class="string">"blue"</span>&#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">colorValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line"> &#125;</span><br><span class="line">colorValue();</span><br><span class="line"><span class="keyword">var</span> bindColor = colorValue.bind(example);</span><br><span class="line">bindColor();</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure></li></ul><p>colorValue 함수의 this는 window 이므로 red 가 출력되고<br>colorValue에 example 을 bind 해줄시 this가 example 객체를 가리키므로<br>this.color 값은 blue가 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;call(),apply(), bind() 메서드&lt;br&gt;&lt;!-- excerpt --&gt;&lt;/p&gt;
&lt;p&gt;앞서 설명하였던 기본적인 this 바인딩 3가지 방법 외에도&lt;br&gt;메서드를 이용하여 임의적으로 특정 객체에 바인딩 시키는 방법이 3가지 존재한다.&lt;/
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript - this 바인딩</title>
    <link href="http://shs400.github.io/2018/01/02/script-study02/"/>
    <id>http://shs400.github.io/2018/01/02/script-study02/</id>
    <published>2018-01-02T06:54:29.000Z</published>
    <updated>2019-05-03T06:51:08.093Z</updated>
    
    <content type="html"><![CDATA[<p>this 바인딩<br><!-- excerpt --></p><p>this 바인딩은 기본적으로 3가지 유형이 있다.<br>this는 함수가 호출되는 패턴에 따라 this가 어디에 바인딩 되는지 결정된다.</p><ol><li><p>전역함수를 호출할 때 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="string">'global'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> global = <span class="string">'local'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this.global : '</span>,<span class="keyword">this</span>.global);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this : '</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func();</span><br><span class="line"><span class="comment">// global</span></span><br><span class="line"><span class="comment">// window</span></span><br></pre></td></tr></table></figure></li><li><p>함수가 객체의 속성이고 해당 객체를 통해 함수를 호출할 때</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    func : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.func();</span><br><span class="line"><span class="comment">// object ( obj 객체 )</span></span><br></pre></td></tr></table></figure></li><li><p>생성자 함수(new)를 호출할 때 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name || <span class="string">'empty'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sim = <span class="keyword">new</span> Person(<span class="string">'sim'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sim.name);</span><br></pre></td></tr></table></figure></li></ol><p>이외의 방법으로 call(),apply(), bind() 메서드가 존재한다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;this 바인딩&lt;br&gt;&lt;!-- excerpt --&gt;&lt;/p&gt;
&lt;p&gt;this 바인딩은 기본적으로 3가지 유형이 있다.&lt;br&gt;this는 함수가 호출되는 패턴에 따라 this가 어디에 바인딩 되는지 결정된다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;전역함수를 호출
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
