<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Roy Blog</title>
  <icon>https://www.gravatar.com/avatar/0564578760656ea13d584c96ba9a60c0</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shs400.github.io/"/>
  <updated>2019-01-12T01:41:22.908Z</updated>
  <id>http://shs400.github.io/</id>
  
  <author>
    <name>shs400</name>
    <email>tlagustn88@naver.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebGL-7</title>
    <link href="http://shs400.github.io/2018/12/24/WebGL-7/"/>
    <id>http://shs400.github.io/2018/12/24/WebGL-7/</id>
    <published>2018-12-24T00:17:36.000Z</published>
    <updated>2019-01-12T01:41:22.908Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-7-View"><a href="#WebGL-7-View" class="headerlink" title="WebGL ( 7 - View )"></a>WebGL ( 7 - View )</h1><p>이번장은 3D 도형을 구현하기전에 View 관점에 대해 설명하려고 합니다.<br>앞의 6장의 행렬과 관련된 내용입니다.</p><h2 id="모델-뷰-프로젝션-Matrix-MVP"><a href="#모델-뷰-프로젝션-Matrix-MVP" class="headerlink" title="모델, 뷰, 프로젝션 Matrix ( MVP )"></a>모델, 뷰, 프로젝션 Matrix ( MVP )</h2><p>먼저 랜더링 간단한 랜더링 파이프라인은 이렇습니다.</p><p><img src="/images/webgl6/matrix08.jpg" alt="matrix"></p><p>월드 -&gt; 카메라 -&gt; 투영행렬을 거쳐 3차원이 2차원으로 변환되는 과정입니다.<br>투영행렬이 끝난뒤에 클리핑과 뷰포트 변환이 있지만 여기서는 위와같이 투영 행렬까지만 설명합니다.</p><p><img src="/images/webgl6/matrix09.jpg" alt="matrix"></p><p><code>모델 Matrix</code>는 모델좌표계에서 월드 좌표계로 변환해주는 행렬입니다.<br>( 6장에서 배운 translate, scale, rotate 변환이 모델 Matrix 입니다. )</p><p><img src="/images/webgl6/matrix10.jpg" alt="matrix 변환"></p><p>다음으로 월드 좌표계에서 카메라 좌표계로 변환해줘야 하는데<br>이때 <code>뷰 Matrix</code>를 사용합니다.<br>( 이 과정에서 카메라의 이동이라던지 카메라 위치 설정등이 이루어지고 lookAt 함수를 사용하게 됩니다. )</p><p><img src="/images/webgl6/matrix11.jpg" alt="matrix 변환"></p><p>마지막으로 투영 변환 ( Projection Matrix )</p><p>월드 좌표계와 카메라 좌표계는 모두 3차원 좌표계입니다.<br>그러나 우리가 디스플레이로 확인하게 되는 랜더링 결과들은 모두 2차원의 화면입니다.<br>때문에 3차원 좌표계를 2차원 좌표계로 바꾸는 변환이 필요하다는 것을 알 수 있는데,<br>이때 <code>투영 변환</code>이 필요합니다.</p><p>투영 변환에는 perspective와 Orthographic가 있는데<br>우리는 perspective를 사용하도록 하겠습니다.</p><h3 id="perspective"><a href="#perspective" class="headerlink" title="perspective"></a>perspective</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Ex)</span><br><span class="line">mat4.perspective(view, canvas.width / canvas.height, <span class="number">0.1</span>, <span class="number">2000.0</span>, pMatrix);</span><br><span class="line"><span class="comment">// mat4.perspective 는 gl-matrix 라이브러리의 헬퍼 함수 </span></span><br><span class="line"><span class="comment">// (시야, 종횡비, 전방 및 후방 경계를 인자로 받는다.)</span></span><br><span class="line"><span class="comment">// 1. 시야 : 수직방향 시야각입니다.</span></span><br><span class="line"><span class="comment">// 2. 종횡비 : 화면 비 이고, 윈도우 크기에 의존합니다.</span></span><br><span class="line"><span class="comment">// 3. 근거리 잘라내기</span></span><br><span class="line"><span class="comment">// 4. 원거리 잘라내기</span></span><br></pre></td></tr></table></figure><iframe src="https://webgl2fundamentals.org/webgl/frustum-diagram.html" width="700px" height="600px" frameborder="0" allowfullscreen></iframe><p>출처 : [webglfundamentals.org]</p><p>위의 변환까지 모두 완료가 되면 GLSL에서<br>Model, View, Projection 을 모두 곱해줘야합니다.<br>이때 행렬의 곱 순서는 꼭 mvp의 역순으로 곱해주어야 합니다.<br>( MVPmatrix = projection X view X model; )</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=<span class="string">"shader-vs"</span> type=<span class="string">"x-shader/x-vertex"</span>&gt;</span><br><span class="line">    attribute vec3 aVertexPosition;</span><br><span class="line">    attribute vec4 aVertexColor;</span><br><span class="line"></span><br><span class="line">    uniform mat4 uMVMatrix;</span><br><span class="line">    uniform mat4 uPMatrix;</span><br><span class="line"></span><br><span class="line">    varying vec4 v_color;</span><br><span class="line">    <span class="keyword">void</span> main(<span class="keyword">void</span>) &#123;</span><br><span class="line">      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, <span class="number">1.0</span>);</span><br><span class="line">      v_color = aVertexColor * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>이번장은 여기서 마무리하고 다음장에서는 실제 3D 화면을 구현해 보도록 하겠습니다.</p><p><img src="/images/webgl6/matrix12.jpg" alt="matrix 변환"></p><p>핵심 위치에 라벨을 붙임</p><p><img src="/images/webgl6/matrix13.jpg" alt="matrix 변환"></p><p>라벨을 붙인후 각 라벨에 인덱스 정점을 활용</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-7-View&quot;&gt;&lt;a href=&quot;#WebGL-7-View&quot; class=&quot;headerlink&quot; title=&quot;WebGL ( 7 - View )&quot;&gt;&lt;/a&gt;WebGL ( 7 - View )&lt;/h1&gt;&lt;p&gt;이
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL ( 6 - Martrix )</title>
    <link href="http://shs400.github.io/2018/11/21/WebGL-6/"/>
    <id>http://shs400.github.io/2018/11/21/WebGL-6/</id>
    <published>2018-11-21T05:40:37.000Z</published>
    <updated>2019-01-10T01:16:47.512Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-6-Martrix"><a href="#WebGL-6-Martrix" class="headerlink" title="WebGL ( 6 - Martrix )"></a>WebGL ( 6 - Martrix )</h1><p>이번에는 3D를 표현하기에 앞서<br>Matrix(행렬)에 대해 설명부터 하려고 합니다.</p><p>3D를 표현하기전에<br>저희는 기존에 버텍스를(x,y,z,w) 다루었습니다.<br>( * 앞장까지는 x,y,z 만으로도 표현이 가능하였습니다. )</p><p>저희가 기억해야할 것은 w입니다.</p><ul><li><code>w = 1 이면 벡터공간에서의 점의 위치입니다. ( x, y, z, 1 )</code></li><li><code>w = 0 이면 벡터공간에서의 방향입니다. ( x, y, z, 0 )</code></li></ul><p>위의 내용은 무조건 기억하고 있어야합니다.</p><h3 id="Matrix-이해"><a href="#Matrix-이해" class="headerlink" title="Matrix 이해"></a>Matrix 이해</h3><p>3D 그래픽스에서 4x4 행렬을 주로 사용하는데,<br>이들은 우리의 (x,y,z,w) 버텍스들을 변형하게 해줍니다. 이에 대한 공식은 아래와 같습니다.<br>행렬 x 버텍스 = 변형된 버텍스 ( * 순서가 동일해야합니다. )</p><p><img src="/images/webgl6/matrix01.gif" alt="matrix 변환"></p><p>위의 공식은 GLSL에서는 아래와 같이 사용합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mat4 Matrix;</span><br><span class="line">vec4 Vector;</span><br><span class="line"></span><br><span class="line">vec4 transformedVector = Matrix * Vector;</span><br></pre></td></tr></table></figure><p>이처럼 저희는 변형된 버텍스 값을 사용하게되며,<br>앞서 말했던 (x,y,z,w) 벡터에 대해 설명하기 위해<br>이해하기 쉬운 평행이동 행렬에 대해 설명하겠습니다.</p><h4 id="평행이동-행렬"><a href="#평행이동-행렬" class="headerlink" title="평행이동 행렬"></a>평행이동 행렬</h4><p><img src="/images/webgl6/matrix02.png" alt="matrix 변환"></p><p>위의 행렬이 평행이동 행렬입니다.<br>X,Y,Z에 있는 것들이 자신의 위치에서 더하고자 하는 값입니다.</p><p><img src="/images/webgl6/matrix03.png" alt="matrix 변환"></p><p>자신을 X 방향으로 20만큼 평행이동 시키면 위와 같이 계산을 하게되고,<br>결과는 벡터 ( 10, 10, 10, 1 )을 X 방향으로 20 이동시킨<br>( 30, 10, 10, 1 ) 벡터값을 얻게 됩니다.<br><code>(w = 1 일때 x 방향으로 이동하였으므로 위치가 변경되었습니다.)</code></p><p><img src="/images/webgl6/matrix04.png" alt="matrix 변환"></p><p>자신을 X 방향으로 20만큼 평행이동 시키면 위와 같이 계산을 하게되고,<br>결과는 벡터 ( 0, 0, -1, 0 )을 X 방향으로 20 이동시켰으나<br>변함이 없는 ( 0, 0, -1, 0 ) 벡터값을 얻게 됩니다.<br><code>(w = 0 일때 x 방향으로 이동하였으나 변화가 없습니다.)</code><br><code>이유는 바로 점은 이동하면 다른 좌표값을 갖는 점이 되지만 벡터는 이동한다고 방향이나 크기가 변하지 않기 때문입니다</code></p><h4 id="단위-행렬"><a href="#단위-행렬" class="headerlink" title="단위 행렬"></a>단위 행렬</h4><p>단위 행렬은 주 대각선이 1이고 나머지가 0인 행렬이고, 아무것도 하지않는 행렬입니다.</p><p><img src="/images/webgl6/matrix05.png" alt="matrix 변환"></p><p>단위행렬에 벡터값(x, y, z, w)을 곱하면 벡터값 자신이 나오기 때문에 아무것도 하지 않습니다.</p><p>이를 이용하여 우리는 scale 매트릭스, translate 매트릭스, rotate 매트릭스등을 활용할 수 있습니다.<br>예를 들어 scale 매트릭스는 아래의 그림과 같습니다.</p><h4 id="Scale-행렬"><a href="#Scale-행렬" class="headerlink" title="Scale 행렬"></a>Scale 행렬</h4><p><img src="/images/webgl6/matrix06.png" alt="matrix 변환"></p><p>벡터값을 모든방향으로 2배 scale하려면</p><p><img src="/images/webgl6/matrix07.png" alt="matrix 변환"></p><p>벡터값의 x,y,z가 아닌 scale 매트릭스의 x,y,z값을 2배로 주면 벡터값이 2배가 되고,<br>실제 코드에선 아래와 같이 사용됩니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mat4.scale(mvMatrix, [<span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">2.0</span>]);</span><br><span class="line"><span class="comment">// 스캐일 매트릭스 사용법</span></span><br></pre></td></tr></table></figure><p>!! 만약 scale, translate, rotate를 같이 사용할때는 꼭 순서를 지켜서 사용하여야 합니다.<br>순서는 translate -&gt; rotate -&gt; scale</p><p>위와 같이 단위 행렬, 평행이동 행렬, Scale 행렬 등 여러 행렬을 따로 구현 하는 것 보다는<br>이미 나와있는 기존의 라이브러리를 활용하는 것이 좋습니다.</p><p>우리는 gl-matrix라는 라이브러리를 사용하려고 하고,<br>해당 라이브러리의 주소는 <a href="http://glmatrix.net" target="_blank" rel="noopener">http://glmatrix.net</a> 입니다.</p><p>해당 페이지의 내용과 이미지의 출처는<br><a href="https://webglfundamentals.org/" target="_blank" rel="noopener">https://webglfundamentals.org/</a> 입니다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-6-Martrix&quot;&gt;&lt;a href=&quot;#WebGL-6-Martrix&quot; class=&quot;headerlink&quot; title=&quot;WebGL ( 6 - Martrix )&quot;&gt;&lt;/a&gt;WebGL ( 6 - Martri
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL 기초( 5 - 도형 이동 )</title>
    <link href="http://shs400.github.io/2018/11/01/WebGL-5/"/>
    <id>http://shs400.github.io/2018/11/01/WebGL-5/</id>
    <published>2018-11-01T07:58:46.000Z</published>
    <updated>2019-01-10T01:17:25.311Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-기초-5-도형-이동"><a href="#WebGL-기초-5-도형-이동" class="headerlink" title="WebGL 기초( 5 - 도형 이동 )"></a>WebGL 기초( 5 - 도형 이동 )</h1><p>이번에는 삼각형에 움직임을 추가해보려고 합니다.</p><p>이를 위해서 애니메이션 루프를 설정해야하는데<br>setTimeout 이나 setInterveal 보다 requestAnimationFrame 활용할 예정입니다.</p><p>앞의 두 메서드가 아닌 requestAnimationFrame 사용하려는 이유는<br>좀 더 정확하고, 다른 브라우저 탭을 보고 있는 동안에는 씬에 애니메이션을 적용하지 않기 때문입니다.<br>( 예외로 requestAnimationFrame 사용하면 모바일 기기에서 불필요한 배터리 수명을 줄일 수 있다고 합니다.)</p><p>애니메이션을 만들게 될때 씬의 뷰를 움직이는 방법이있는데,<br>현재는 뷰를 조절하는 법을 모르기때문에 모델의 좌표계를 수정하여 움직임을 주도록 작성하였습니다.</p><p>requestAnimationFrame 지원이 브라우저마다 다르기때문에<br>사용항 브라우저에서 지원되는지를 확인하고 사용하여야 하거나 polyfill을 통해 수행할 수 있습니다.<br>url : <a href="https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/" target="_blank" rel="noopener">https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// setupWebGL();</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// initShader();</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// setupBuffers();</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// drawScene();</span></span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="comment">// 기존에 init해주던 부분에 animLoop를 호출하여 계속 반복시킵니다.</span></span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="undefined">  initShader();</span></span><br><span class="line"><span class="undefined">  setupBuffers();</span></span><br><span class="line"><span class="javascript">  (<span class="function"><span class="keyword">function</span> <span class="title">animLoop</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">    setupWebGL();</span></span><br><span class="line"><span class="undefined">    setupDynamicBuffers();</span></span><br><span class="line"><span class="undefined">    drawScene();</span></span><br><span class="line"><span class="undefined">    requestAnimationFrame(animLoop, canvas);</span></span><br><span class="line"><span class="undefined">  &#125;)();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>requestAnimationFrame의 첫번째 파라미터는 콜백 함수이고,<br>두번째 인자는 애니메이션의 대상이되는 엘리먼트입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> angle = <span class="number">0.0</span>;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">setupDynamicBuffers</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 변환 범위를 -0.5 ~ 0.5로 제한하기위해 sin 사용</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> x_translation = <span class="built_in">Math</span>.sin(angle)/<span class="number">2.0</span>;</span></span><br><span class="line"><span class="undefined">              </span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> positionsColor = [</span></span><br><span class="line"><span class="javascript">        <span class="number">-0.5</span> + x_translation,  <span class="number">0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 1</span></span></span><br><span class="line"><span class="javascript">        <span class="number">-0.5</span> + x_translation, <span class="number">-0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 2</span></span></span><br><span class="line"><span class="javascript">        <span class="number">0.5</span> + x_translation, <span class="number">-0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 3</span></span></span><br><span class="line"><span class="undefined">      ];</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined">      positionsColorBuffer = gl.createBuffer();</span></span><br><span class="line"><span class="undefined">      gl.bindBuffer(gl.ARRAY_BUFFER, positionsColorBuffer);</span></span><br><span class="line"><span class="javascript">      gl.bufferData(gl.ARRAY_BUFFER, <span class="keyword">new</span> <span class="built_in">Float32Array</span>(positionsColor), gl.DYNAMIC_DRAW);</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> triangleVertices = [</span></span><br><span class="line"><span class="javascript">        <span class="number">-0.5</span> + x_translation,  <span class="number">0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 1</span></span></span><br><span class="line"><span class="javascript">        <span class="number">-0.5</span> + x_translation, <span class="number">-0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 2</span></span></span><br><span class="line"><span class="javascript">        <span class="number">0.5</span> + x_translation, <span class="number">-0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 3</span></span></span><br><span class="line"><span class="undefined">      ];</span></span><br><span class="line"><span class="undefined">      angle += 0.01;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined">      trianglesVerticeBuffer = gl.createBuffer();</span></span><br><span class="line"><span class="undefined">      gl.bindBuffer(gl.ARRAY_BUFFER, trianglesVerticeBuffer);</span></span><br><span class="line"><span class="javascript">      gl.bufferData(gl.ARRAY_BUFFER, <span class="keyword">new</span> <span class="built_in">Float32Array</span>(triangleVertices), gl.DYNAMIC_DRAW);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>가장 중요한 것은 정점이나 데이터가 변경될때는 정점의 타입을<br>STATIC_DRAW에서 DYNAMIC_DRAW로 바꾸어야한다는 것입니다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/j6p9qozr/embedded/result/dark" frameborder="0" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-기초-5-도형-이동&quot;&gt;&lt;a href=&quot;#WebGL-기초-5-도형-이동&quot; class=&quot;headerlink&quot; title=&quot;WebGL 기초( 5 - 도형 이동 )&quot;&gt;&lt;/a&gt;WebGL 기초( 5 - 도형
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL 기초( 4 - Shader 이해 &amp; 색상 채우기 )</title>
    <link href="http://shs400.github.io/2018/10/31/WebGL-4/"/>
    <id>http://shs400.github.io/2018/10/31/WebGL-4/</id>
    <published>2018-10-31T05:06:29.000Z</published>
    <updated>2019-01-10T01:16:44.877Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-기초-4-Shader-이해-amp-색상-채우기"><a href="#WebGL-기초-4-Shader-이해-amp-색상-채우기" class="headerlink" title="WebGL 기초( 4 - Shader 이해 &amp; 색상 채우기 )"></a>WebGL 기초( 4 - Shader 이해 &amp; 색상 채우기 )</h1><p>이번에는 Shader에서 알아보고<br>삼각형에 색상을 그라이데이션으로 넣어보는 작업을 하도록 하겠습니다.</p><h3 id="Shader의-이해"><a href="#Shader의-이해" class="headerlink" title="Shader의 이해"></a>Shader의 이해</h3><p>GPU는 아래와 같이 2가지 일을 합니다. </p><ol><li>원본의 정점을 클립공간 정점으로 처리</li><li>클립공간을 pixel로 처리</li></ol><p>vertexShader 셰이더와 fragmentShader는 GPU가 이러한 일들을 할 수 있도록<br>명령과 계산된 데이터를 전달하는 기능을 수행합니다. </p><p>먼저 vertex-Shader와 fragment-Shader를 작성해줍니다.<br>(* vertex-Shader : 정점, fragment-Shader : 색상 )</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 버텍스 셰이더 작성 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"shader-vs"</span> <span class="attr">type</span>=<span class="string">"x-shader/x-vertex"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  attribute vec4 aVertexPosition;  </span></span><br><span class="line"><span class="undefined">  uniform mat4 u_matrix;</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="keyword">void</span> main(<span class="keyword">void</span>) &#123;</span></span><br><span class="line"><span class="undefined">    gl_Position = u_matrix * aVertexPosition;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 클립공간은 -1.0 ~ 1.0의 범위 인데 </span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// gl_Position * 0.5 + 0.5 하여 0.0 ~ 1.0 으로 변경하였다.</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> primitiveType = gl.TRIANGLES;</span><br><span class="line"><span class="keyword">var</span> offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">9</span>;</span><br><span class="line">gl.drawArrays(primitiveType, offset, count);</span><br></pre></td></tr></table></figure><p><img src="/images/vertex-shader-anim.gif" alt="버텍스셰이"><br>출처 : webglfundamentals.org</p><p>위의 이미지와 같이 원본 정점 9개를 작성한 vertexShader 함수를 통하여<br>GLSL에서 정의된 변수인 gl_Position에 주면 클립공간 정점으로 GPU에 저장합니다.</p><p>gl.drawArrays() 함수를 호출할 떄 primitiveType을 TRIANGLES로 지정하였기 때문에<br>3개의 클립공간의 정점이 생성될 때마다 GPU는 이를 이용해 삼각형을 그리게 됩니다.</p><p>이 삼각형을 그릴때 아래의 그림과 같이 3개의 정점을 기준으로 래스터화 합니다.</p><ul><li>래스터화 = ‘삼각형을 픽셀로 그림’<br>Ex) <img src="/images/webgl4/webgl4_1.png" alt="정점삼각형"> &gt;&gt; <img src="/images/webgl4/webgl4_2.png" alt="삼각형래스터화"></li></ul><p>래스터화를 할 때 삼각형을 구성하는 각각의 픽셀에 대해서 프래그먼트 셰이더를 호출하게 되는데<br>이때 프래그먼트 셰이더는 특수변수인 gl_FragColor를 통해 각 픽셀의 색상을 알려주게 됩니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 프래그먼트 셰이더 작성 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"shader-fs"</span> <span class="attr">type</span>=<span class="string">"x-shader/x-fragment"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  precision mediump float; <span class="comment">// 실수 정확도</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 낮은 정도의 precision을 가질수록 빠른 렌더 속도를 가지지만 렌더 퀄리가 그만큼 떨어진다.</span></span></span><br><span class="line"><span class="undefined">  varying vec4 v_color;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">void</span> main(<span class="keyword">void</span>) &#123;</span></span><br><span class="line"><span class="javascript">    gl_FragColor = vec4(<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>); <span class="comment">// vec4(R,G,B,A)</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// GLSL의 색상값은 0~1 의 값으로 나타낸다.</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/7osmx9rz/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>이를 응용하면 아래와 같이 응용할 수 있습니다.</p><p>참고)<br>varing은 vertexShader에서 만든 데이터를 에서 fragmentShader에게 전달하는데 사용됩니다.<br>(* varing의 타입과 이름이 동일해야 연결이 됩니다.)</p><ol><li>프래그먼트 셰이더는 래스터화된 점, 선, 면 등을 구성하는 픽셀 수 만큼 호출된다.</li><li>버텍스 셰이더에서 설정한 배어링 값은 선의 경우 2점 보간, 삼각형의 경우 3점 보간을 해서<br>프래그먼트 셰이더에게 전달된다(배어링은 보간되어 전달된다는 점이 중요합니다).</li></ol><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/oct0k29f/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>아래의 그림을 통하여 정점 3개의 삼각형의 v_color가 보간되어 레스터화 되는 동작을 확인할 수 있습니다.</p><iframe src="https://webglfundamentals.org/webgl/lessons/resources/fragment-shader-anim.html" width="400px" height="300px" frameborder="0" allowfullscreen></iframe><p>출처 : [webglfundamentals.org]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-기초-4-Shader-이해-amp-색상-채우기&quot;&gt;&lt;a href=&quot;#WebGL-기초-4-Shader-이해-amp-색상-채우기&quot; class=&quot;headerlink&quot; title=&quot;WebGL 기초( 4 -
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL 기초( 3 - 삼각형 그리기 )</title>
    <link href="http://shs400.github.io/2018/08/08/WebGL-3/"/>
    <id>http://shs400.github.io/2018/08/08/WebGL-3/</id>
    <published>2018-08-08T11:18:53.000Z</published>
    <updated>2019-01-10T01:16:42.435Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-기초-3-삼각형-그리기"><a href="#WebGL-기초-3-삼각형-그리기" class="headerlink" title="WebGL 기초( 3 - 삼각형 그리기 )"></a>WebGL 기초( 3 - 삼각형 그리기 )</h1><p>모든 준비가 완료되었으니 마지막으로 렌더링을 시작하겠습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 클리어 색상을 녹색으로 설정</span></span><br><span class="line">gl.clearColor(<span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.1</span>, <span class="number">1.0</span>);</span><br><span class="line">gl.clear(gl.COLOR_BUFFER_BIT);</span><br></pre></td></tr></table></figure><p>초기화시 클리어 색상값(R,G,B,A)을 정하고 클리어하게되면<br>작성자가 정한 색으로 캔버스의 배경색이 칠해지게 됩니다.</p><p>그 후 WebGL이 앞서 만든 프로그램을 사용가능 하도록 해줍니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 앞장에서 glProgram 이라는 프로그램을 만듬</span></span><br><span class="line"><span class="comment">// 프로그램 사용</span></span><br><span class="line">gl.useProgram(glProgram);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 참조한 위치 애트리뷰트를 사용할 것임을 알려줍니다.</span></span><br><span class="line">gl.enableVertexAttribArray(positionAttributeLocation);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 위치 버퍼를 바인드 합니다.</span></span><br><span class="line"><span class="comment">// 어느 버퍼를 사용할지 바인드 포인트로 지정하는 셈입니다.</span></span><br><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// positionBuffer (ARRAY_BUFFER)에서 데이터를 가져오는</span></span><br><span class="line"><span class="comment">// 방법을 위치 애트리뷰트에게 알려 줌</span></span><br><span class="line"><span class="keyword">var</span> size = <span class="number">2</span>;          <span class="comment">// 각 반복마다 2개씩 버퍼 데이타 참조</span></span><br><span class="line"><span class="keyword">var</span> type = gl.FLOAT;   <span class="comment">// 32bit 부동 소수점 값</span></span><br><span class="line"><span class="keyword">var</span> normalize = <span class="literal">false</span>; <span class="comment">// 데이터를 노말라이즈 하지 않는다.</span></span><br><span class="line"><span class="keyword">var</span> stride = <span class="number">0</span>;        <span class="comment">// 0 = move forward size * sizeof(type) 각 반복마다 다음 위치</span></span><br><span class="line"><span class="keyword">var</span> offset = <span class="number">0</span>;        <span class="comment">// 버퍼 시작 위치</span></span><br><span class="line">gl.vertexAttribPointer(</span><br><span class="line">  positionAttributeLocation,</span><br><span class="line">  size,</span><br><span class="line">  type,</span><br><span class="line">  normalize,</span><br><span class="line">  stride,</span><br><span class="line">  offset</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이제 마지막으로 WebGL 에게 만든 GLSL 프로그램을 실행하라고 요청을 해봅시다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GLSL 프로그램을 실행하도록 요청</span></span><br><span class="line"><span class="keyword">var</span> primitiveType = gl.TRIANGLES;</span><br><span class="line"><span class="keyword">var</span> offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">3</span>;</span><br><span class="line">gl.drawArrays(primitiveType, offset, count);</span><br></pre></td></tr></table></figure></p><p>이제는 아래와 같이 두개의 삼각형이 보이게 될 것입니다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/6szy70u2/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>마지막으로 drawArrays에 사용되는 원시타입에 대해 설명을 하자면</p><p><code>원시 타입(primitiveType)</code><br>원시 타입은 특정 그래픽 언어에서<br>모델을 개발할 때 사용하는 그래픽 구성 요소입니다.<br>웹지엘에는 7개의 원시타입이 있는데<br><img src="/images/primitive_type.png" alt="원시타입"><br><code>좌측 상단부터 우측 하단 순서</code><br>POINTS, LINES, LINE_STRIP, LINE_LOOP,<br>TRIANGLES, TRIANGLE_STRIP, TRIANFLE_FAN 이 있습니다.</p><ul><li><p>POINTS<br>POINTS는 한번에 하나씩 렌더링되는 정점(공간좌표)입니다.<br>(총 정점 : 4개)</p></li><li><p>LINES<br>정점의 쌍을 따라 형태를 이룹니다.<br>두개의 선이 같은 정점을 공유하고 있찌만, 각선은 별로도 정의 되어있습니다.<br>(총 정점 : 6개)</p></li><li><p>LINE_STRIP<br>첫번째 선을 제외하고 각 선의 시작점이 이전 선의 끝점인 정점 컬렉션으로 이뤄집니다.<br>LINE_STRIP에서는 여러 선에서 일부 정점을 재사용합니다.<br>(총 정점 : 5개) </p></li><li><p>LINE_LOOP<br>첫번째 정점과 마지막 정점이 다시 연결돼 닫힌 고리를 형성한다는 점 을 제외하곤 LINE_STRIP과 유사합니다.<br>(총 정점 : 5개)</p></li><li><p>TRIANGLES<br>삼각형당 정점 3개로 이뤄집니다.<br>위 그림에서 삼각형 3개를 그리는데 삼각형별로 정점 3개씩 필요하며,<br>LINES와 마찬가지로 공유된 정점은 우연히 겹쳐 있을 뿐입니다.<br>(총 정점 : 9개)</p></li><li><p>TRIANGLE_STRIP<br>ABC, (BC)D, (CD)E, (DE)F, (EF)G, (FG)H, (GH)I 정점을 통해 형성됩니다.<br>여러 삼각형에서 정점을 재사용 하여 삼각형을 렌더링 합니다.<br>(총 정점 : 9개)</p></li><li><p>TRIANFLE_FAN<br>삼각형의 일부로 지정한 첫번쨰 정점을 사용합니다.<br>첫번째 정점 A는 7번 사용 나머지 정점은 2번씩 사용됩니다.<br>(총 정점 : 8개)</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-기초-3-삼각형-그리기&quot;&gt;&lt;a href=&quot;#WebGL-기초-3-삼각형-그리기&quot; class=&quot;headerlink&quot; title=&quot;WebGL 기초( 3 - 삼각형 그리기 )&quot;&gt;&lt;/a&gt;WebGL 기초( 
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL 기초( 2 - 삼각형 그리기 준비 )</title>
    <link href="http://shs400.github.io/2018/08/08/WebGL-2/"/>
    <id>http://shs400.github.io/2018/08/08/WebGL-2/</id>
    <published>2018-08-08T06:04:46.000Z</published>
    <updated>2019-01-10T01:16:40.297Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-기초-2-삼각형-그리기-준비"><a href="#WebGL-기초-2-삼각형-그리기-준비" class="headerlink" title="WebGL 기초( 2 - 삼각형 그리기 준비 )"></a>WebGL 기초( 2 - 삼각형 그리기 준비 )</h1><p>이번에는 코드를 보며 아래와 같이 삼각형을 만들어보기로 합니다.</p><h3 id="1-셰이더-작성"><a href="#1-셰이더-작성" class="headerlink" title="1 - 셰이더 작성"></a>1 - 셰이더 작성</h3><p>먼저 앞장에서 작업한 버텍스 셰이더와 프래그먼트 셰이더를 작성합니다.</p><h3 id="2-WebGL-렌더링-컨텍스트-생성하기"><a href="#2-WebGL-렌더링-컨텍스트-생성하기" class="headerlink" title="2 - WebGL 렌더링 컨텍스트 생성하기"></a>2 - WebGL 렌더링 컨텍스트 생성하기</h3><p>WebGL 렌더링 컨텍스트는 canvas로부터 얻어올 수 있습니다.</p><p>canvas는 ‘2D’와 ‘webgl’이라는 두개의 캔버스 context가 있습니다.<br>canvas는 둘 중 어떤 컨텍스트를 사용하든 상관하지 않지만<br>원하는 API를 노출하는 적절한 객체를 제공해주려면<br>canvas에게 명시적으로 알려줘야 합니다.</p><p>context를 가져오려면 canvas의 getContext 메소드를 호출하면됩니다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrap'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"my-canvas"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span></span><br><span class="line">      해당 브라우저는 html5 canvas element를 지원하지 않습니다.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> gl = <span class="literal">null</span>,</span></span><br><span class="line"><span class="javascript">      canvas = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">    canvas = <span class="built_in">document</span>.getElementById(<span class="string">'my-canvas'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">try</span>&#123;</span></span><br><span class="line"><span class="javascript">      gl = canvas.getContext(<span class="string">'webgl'</span>) || </span></span><br><span class="line"><span class="javascript">      canvas.getContext(<span class="string">'experimental-webgl'</span>);</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">catch</span> (e)&#123;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>*getContext<br>-첫번째 파라미터 : context이름<br>-두번째 파라미터 : 선택인자</p><h3 id="3-셰이더-컴파일-및-링크-gt-프로그램-생성"><a href="#3-셰이더-컴파일-및-링크-gt-프로그램-생성" class="headerlink" title="3 - 셰이더 컴파일 및 링크 -&gt; 프로그램 생성"></a>3 - 셰이더 컴파일 및 링크 -&gt; 프로그램 생성</h3><p>지금까지 작성한 셰이더를 GPU에서 동작하도록 단계별로 진행합니다.</p><p><strong>1단계</strong><br>정점 셰이더와 프래그먼트 셰이더의 문자열을 가져옵니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vertexShaderSource = <span class="built_in">document</span>.getElementById(<span class="string">"2d-vertex-shader"</span>).text;</span><br><span class="line"><span class="keyword">var</span> fragmentShaderSource = <span class="built_in">document</span>.getElementById(<span class="string">"2d-fragment-shader"</span>).text;</span><br></pre></td></tr></table></figure></p><p><strong>2단계</strong><br>셰이더 생성 및 컴파일을 합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 셰이더 컴파일</span></span><br><span class="line"><span class="keyword">var</span> vertextShader = makeShader(vertexShaderSource, gl.VERTEX_SHADER),</span><br><span class="line">    fragmentShader = makeShader(fragmentShaderSource, gl.FRAGMENT_SHADER);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeShader</span>(<span class="params">src, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> shader = gl.createShader(type);</span><br><span class="line">  gl.shaderSource(shader, src);</span><br><span class="line">  gl.compileShader(shader);</span><br><span class="line">  <span class="keyword">return</span> shader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>3단계</strong><br>2개의 셰이더를 1개의 프로그램에 연결하기<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 프로그램 생성</span></span><br><span class="line"><span class="comment">// 프로그램은 vertexShader,fragmentShader 두쌍을 합쳐서 프로그램이라고 합니다.</span></span><br><span class="line">glProgram = gl.createProgram();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 프로그램에 셰이더 첨부 및 연결</span></span><br><span class="line">gl.attachShader(glProgram, vertexShader);</span><br><span class="line">gl.attachShader(glProgram, fragmentShader);</span><br><span class="line">gl.linkProgram(glProgram);</span><br></pre></td></tr></table></figure></p><p>여기까지가 하나의 GLSL프로그램을 만드는 과정입니다.</p><h3 id="4-셰이더에서-참조할-데이터-넣기"><a href="#4-셰이더에서-참조할-데이터-넣기" class="headerlink" title="4 - 셰이더에서 참조할 데이터 넣기"></a>4 - 셰이더에서 참조할 데이터 넣기</h3><p>이제부터 WebGL API를 사용하여 앞에서 만든 GLSL프로그램에서 참조할 데이터를 넣어줄 것입니다.</p><p>앞에서 만든 GLSL프로그램에서 aVertexPosition 애트리뷰트를 사용하였는데,<br>이 애트리뷰트에서 소비할 데이터를 제공할 버퍼를 만들어 줍니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> triangleVerticeBuffer = gl.createBuffer();</span><br><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, triangleVerticeBuffer);</span><br></pre></td></tr></table></figure></p><hr><p><strong>bindBuffer( target, mybuffer )</strong></p><hr><p>WebGL은 내부에 버퍼를 여러개 생성하고 관리할 수 있습니다.<br>그래서 어떤 버퍼를 사용하고 있는지 일려주어야 하는데, 어떤 버퍼를 사용하고 있다고 가리키는 것을<br><code>바인드 포인트(bind point)</code>라고 합니다.<br>그렇기 때문에 bindBuffer 함수를 실행하면 바인드 포인트는 triangleVerticeBuffer를 가리키게 되고,<br>이후에 제공되는 데이터는 이 바인드 포인트가 가리키는 버퍼에 입력되게 됩니다.</p><p>bindBuffer의 첫번째 인자로는 상수 값<br>ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER 이 들어가는데<br>ARRAY_BUFFER는 타깃 버퍼가 <code>위치 및 색상같은 정점 어트리뷰트</code>에 사용될때,<br>ELEMENT_ARRAY_BUFFER는 타깃 버퍼가 <code>정점 인덱스를 포함할 때</code> 사용합니다.</p><p>그후 bufferData를 통해 GPU에 데이터를 올리게 됩니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> triangleVertices = [</span><br><span class="line">  <span class="comment">// 왼쪽 삼각형</span></span><br><span class="line">  <span class="number">-0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>,</span><br><span class="line">   <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">  <span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0.0</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 오른쪽 삼각형</span></span><br><span class="line">  <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>,</span><br><span class="line">  <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">  <span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0.0</span></span><br><span class="line">];</span><br><span class="line"><span class="comment">// 공간 좌표 (x,y,z)이고 값은 캔버스 크기로부터 -1~1 까지 표현된다.</span></span><br><span class="line">gl.bufferData(gl.ARRAY_BUFFER, <span class="keyword">new</span> <span class="built_in">Float32Array</span>(triangleVertices), gl.STATIC_DRAW);</span><br></pre></td></tr></table></figure></p><p>WebGL은 강력한 형의 값을 요구하기 때문에<br>데이터를 32비트 부동 소수점 형식의 값의 배열로 만들기 위해 Float32Array를 사용해 줍니다.<br>이때 앞에서 정의 한 triangleVerticeBuffer를 인자로 넘기지 않는 이유는<br>이미 바인드 포인트가 triangleVerticeBuffer를 가리키고 있기때문 입니다.</p><hr><p><strong>bufferData( target, data, usage )</strong></p><hr><p>bufferData 호출에서 세번째 파라미터 usage(용법)는 3가지가 존재하는데,<br>최적화와 관련된 상수라고 합니다.(파악안됨..)</p><ul><li><p>STATIC_DRAW<br>데이터를 한번만 설정하고 애플리케이션이 여러번 사용하는 동안 다시 변경하지 않습니다.</p></li><li><p>DYNAMIC_DRAW<br>애플리케이션에서 데이터를 여러번 사용하지만 매번 내용을 재설정합니다.</p></li><li><p>STREAM_DRAW<br>데이터를 변경하지 않습니다.</p></li></ul><h3 id="5-애트리뷰트-참고하기"><a href="#5-애트리뷰트-참고하기" class="headerlink" title="5 - 애트리뷰트 참고하기"></a>5 - 애트리뷰트 참고하기</h3><p>마지막으로 앞서 만든 GLSL 프로그램에서 애트리뷰트로 aVertexPosition이 사용되는데,<br>WebGL API를 통하여 프로그램에 정의된 애트리뷰트의 위치를 얻어옵니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var positionAttributeLocation = gl.getAttribLocation(program, &quot;aVertexPosition&quot;);</span><br></pre></td></tr></table></figure><p>getAttribLocation()함수를 이용해 프로그램의 a_position 애트리뷰트의 위치를 참조했습니다.</p><p>셰이더 컴파일 및 링크, 데이터를 버퍼에 제공, 애트리뷰트의 위치를 참조까지 완료하면<br>삼각형을 그리기 위한 준비가 완료됩니다.</p><p>이 과정은 초기화 과정으로 전체 코드 동작중 한번만 실행하도록 해야한다고 합니다.</p><p>다음 장에서는 WebGL 기초 마지막으로<br>삼각형을 그려보도록 하겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-기초-2-삼각형-그리기-준비&quot;&gt;&lt;a href=&quot;#WebGL-기초-2-삼각형-그리기-준비&quot; class=&quot;headerlink&quot; title=&quot;WebGL 기초( 2 - 삼각형 그리기 준비 )&quot;&gt;&lt;/a&gt;W
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL 기초( 1 - 시작 )</title>
    <link href="http://shs400.github.io/2018/08/06/WebGL-1/"/>
    <id>http://shs400.github.io/2018/08/06/WebGL-1/</id>
    <published>2018-08-06T07:28:35.000Z</published>
    <updated>2019-01-10T01:16:33.306Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-기초-1-시작하기"><a href="#WebGL-기초-1-시작하기" class="headerlink" title="WebGL 기초( 1 - 시작하기 )"></a>WebGL 기초( 1 - 시작하기 )</h1><p>기초에서는 삼각형을 그리는것을 목표로 합니다.</p><p>우선 WebGL은 래스터화 엔진 중 하나입니다.<br>래스터화는 벡터 또는 윤곽선 데이터를 비트맵으로 바꾸는 과정을 의미합니다.<br>개발자는 WebGL 3D API를 사용해 코드를 작성하면 점, 선, 도형 등을 그릴 수 있습니다.</p><p>WebGL은 컴퓨터의 GPU(Graphic Processing Unit)에서 운영됩니다.<br>그래서 GPU에 실행명령을 수행하기 위해 셰이더가 필요하고<br>그 셰이더에는 2개의 함수가 제공되는데,<br>각각을 <code>정점 셰이더(or 버텍스 셰이더)</code>, <code>프래그먼트 셰이더(or 픽셀 셰이더)</code> 라고합니다.</p><p>이 셰이더 함수들은 GLSL(GL Shader Language)라고 하는 C/C++ 언어로 작성할 수 있습니다.<br>(GLSL에 대해서는 후에 설명)</p><h2 id="셰이더-Shader"><a href="#셰이더-Shader" class="headerlink" title="셰이더(Shader)"></a>셰이더(Shader)</h2><p>셰이더란 화면에 출력할 픽셀의 위치와 색상을 계산하는 함수입니다.</p><p>정점은 셰이더로 넘겨줄 수 있는 어트리뷰트를 갖고 있습니다.<br>또한 각 정점별로 일정한 유니폼 값도 셰이더로 넘겨 줄 수 있는데,<br>자세한 내용은 뒤에 다루기로 하겠습니다.</p><p>지금은 셰이더엔 <code>정점 셰이더</code>와 <code>프래그먼트 셰이더</code>가 있고,<br>하는일은 아래와 같다는 정도만 알고 있기로 합니다.</p><ul><li>정점(vertex) 셰이더 : 정점의 최종 위치를 설정</li><li>프래그먼트 셰이더 : 각 픽셀의 최종 색상을 설정</li></ul><p>화면안의 그려줄 영역의 위치를 계산해 주는 함수를 정점 셰이더라고 하고,<br>영역안의 픽셀들마다 색상을 계산해서 그려주는 함수를<br>프래그먼트 셰이더(픽셀 셰이더) 라고합니다.</p><p><img src="/images/shader.png" alt="셰이더과정"><br>이미지 출처 : [<a href="https://github.com/ejonghyuck/TIL/blob/master/Shader/shader.md]" target="_blank" rel="noopener">https://github.com/ejonghyuck/TIL/blob/master/Shader/shader.md]</a></p><h2 id="셰이더가-참고할-데이터를-제공하는-방법"><a href="#셰이더가-참고할-데이터를-제공하는-방법" class="headerlink" title="셰이더가 참고할 데이터를 제공하는 방법"></a>셰이더가 참고할 데이터를 제공하는 방법</h2><p>셰이더는 GPU에 공급된 데이터로 어떻게 그림을 그리는지 GPU에 시킬 명령들을 선언한 함수일뿐입니다.<br>함수를 실행하기 전에 셰이더가 그림을 그리기 위한 데이터를 GPU에 제공해야하는데</p><p>방법으로는 4가지가 있습니다.</p><ol><li><p>애트리뷰트<br>애트리뷰트는 버터를 사용합니다.<br>버퍼 : 개발자가 GPU에 올려줄 바이너리 배열 데이터입니다.<br>또한 애트리뷰트는 vertex shader에서만 사용되며 읽기 전용 값 입니다.</p></li><li><p>유니폼<br>유니폼은 셰이더 실행하기 전에 정의하는 전역 변수입니다.<br>이 전역 변수에 변환 행렬 정보나 특정 필터 정보 또는 뷰포트 정보 등을 정의해두면 셰이더가 이 변수의 데이타를 참고할 수 있습니다.<br>JavaScript에서 uniformMatrix#fv()를 통해 전달 받은 값을 저장하며 주로 변형(이동, 회전, 스케일)을 계산하기 위한 벡터가 넘어옴</p></li><li><p>텍스쳐<br>텍스처는 셰이더에서 무작위로 접근이 가능한 배열로 된 데이타입니다.<br>텍스처는 보통 이미지 데이터라고 생각할 수 있지만 텍스처 자체는 단순한 데이타이기 때문에 색상 뿐아니라 다른 것도 쉽게 추가시킬 수 있습니다.</p></li><li><p>배어링<br>버텍스 셰이더에서 만든 데이터를 프래그먼트 셰이더에게 전달하는데 쓰입니다.<br>vertex shader에서 계산된 값을 fragment shader로 전달해 줄 때 사용합니다.</p></li></ol><p>Ex) 버텍스 셰이더와 프래그먼트 셰이더<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>WebGL<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  body &#123; background: grey; &#125;</span></span><br><span class="line"><span class="undefined">  canvas &#123; background: white; &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 캔버스 정의 - WebGL의 결과 랜더링 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"my-canvas"</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"500"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- 버텍스 셰이더 작성 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"shader-vs"</span> <span class="attr">type</span>=<span class="string">"x-shader/x-vertex"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    attribute vec3 aVertexPosition;</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">    <span class="keyword">void</span> main(<span class="keyword">void</span>) &#123;</span></span><br><span class="line"><span class="undefined">      gl_Position = vec4(aVertexPosition, 1.0);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 프래그먼트 셰이더 작성 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"shader-fs"</span> <span class="attr">type</span>=<span class="string">"x-shader/x-fragment"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">void</span> main(<span class="keyword">void</span>) &#123;</span></span><br><span class="line"><span class="undefined">      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>코드를 보시면 각 셰이더에서<br>type 은 text/javascript가 아닌 임의의 값을 주면 됩니다.<br>이유는 셰이더가 javascript로 해석되지 않도록 하는 것이 목적이기 때문입니다.</p><p>셰이더에서 <code>attribute vec3 aVertexPosition</code> 는<br>attribute : 셰이더 변수 종류( attribute | uniform | varying )<br>vec3 : 배열 타입, vec3는 3행 배열<br>aVertexPosition : 배열 이름, 한 개의 버텍스를 나타냅니다. 관습적으로 맨 앞에 a를 붙여서 attribute임을 표시를 나타냅니다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/4ntr3obg/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>WebGL의 기본이 되는 canvas는 HTML5 스펙입니다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"my-canvas"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span></span><br><span class="line">    해당 브라우저는 html5 canvas element를 지원하지 않습니다.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="기본-canvas-화면"><a href="#기본-canvas-화면" class="headerlink" title="기본 canvas 화면"></a>기본 canvas 화면</h2><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/jr0xw1zg/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>※ html5 canvas 미지원시<br>‘해당 브라우저는 html5 canvas element를 지원하지 않습니다.’를 출력합니다.</p><h2 id="WebGL-기초"><a href="#WebGL-기초" class="headerlink" title="WebGL 기초"></a>WebGL 기초</h2><p>canvas는 ‘2D’와 ‘webgl’이라는 두개의 캔버스 context가 있습니다.</p><p>canvas는 둘 중 어떤 컨텍스트를 사용하든 상관하지 않지만<br>원하는 API를 노출하는 적절한 객체를 제공해주려면<br>canvas에게 명시적으로 알려줘야 합니다.</p><p>context를 가져오려면 canvas의 getContext 메소드를 호출하면됩니다.</p><ul><li>getContext</li></ul><ul><li>첫번째 파라미터 : context 타입 </li><li>두번째 파라미터 : context 속성</li></ul><p>Ex) canvas.getContext(‘experimental-webgl’, {<br>  antialias: false, // 앤티 앨리어싱을 수행할지 여부를 나타내는 부울 값입니다.<br>  depth: false  // 캔버스에 알파 버퍼가 있는지 여부를 나타내는 부울입니다.<br>});<br>// experimental-webgl은 WebGL이 정식으로 지원되지 않을 때 사용되던 이름</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = setupWebGL;</span><br><span class="line"><span class="keyword">var</span> gl = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// gl 은 웹지엘에서 컨텍스트 객체를 참조할 떄 관례적으로 사용하는 변수명</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupWebGL</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"my-canvas"</span>);</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    gl = canvas.getContext(<span class="string">'experimental-webgl'</span>);</span><br><span class="line">  &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">    <span class="comment">//컨텍스트 가져오지 못하여 에러 발생시  </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(gl)&#123;</span><br><span class="line">    gl.clearColor(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// clearColor(R,G,B,A)</span></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">'WebGL 지원 안함'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/tLpjk184/embedded/result/dark" frameborder="0" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-기초-1-시작하기&quot;&gt;&lt;a href=&quot;#WebGL-기초-1-시작하기&quot; class=&quot;headerlink&quot; title=&quot;WebGL 기초( 1 - 시작하기 )&quot;&gt;&lt;/a&gt;WebGL 기초( 1 - 시작하기 
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 Transform</title>
    <link href="http://shs400.github.io/2018/06/07/CSS3-Study/"/>
    <id>http://shs400.github.io/2018/06/07/CSS3-Study/</id>
    <published>2018-06-07T00:46:00.000Z</published>
    <updated>2019-01-10T01:17:25.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="transform-화면-변형"><a href="#transform-화면-변형" class="headerlink" title="transform (화면 변형)"></a>transform (화면 변형)</h1><p>transform은 엘리먼트의 크기, 위치, 모양을 변경하는 속성입니다.</p><p>transform 함수들은 transform: scale(2, 0.5)같은 형태로 사용가능<br>다중으로 사용할경우에는 transform: scale(2, 0.5) rotate(45deg) 처럼 사용가능</p><p>X, Y, Z 축의 대한 이미지</p><p><img src="/images/x.gif" alt="x축 회전 이미지"></p><p><img src="/images/y.gif" alt="y축 회전 이미지"></p><p><img src="/images/z.gif" alt="z축 회전 이미지"></p><h2 id="scale-크기변경"><a href="#scale-크기변경" class="headerlink" title="scale - 크기변경"></a>scale - 크기변경</h2><p>2D 크기의 변환 함수.</p><p>Ex1) transform: scale(x,y)<br>y 값이 없을시 x 와 동일값으로 가정하여 계산</p><p>Ex2) transform: scaleX(x)<br>y 값이 없을시 y는 1값으로 가정하여 계산</p><p>Ex3) transform: scaleY(y)<br>x 값이 없을시 x는 1값으로 가정하여 계산</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/wcutdk8f/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="translate-이동"><a href="#translate-이동" class="headerlink" title="translate - 이동"></a>translate - 이동</h2><p>Ex) transform: translate(x,y)<br>좌표 평면에서의 2D 이동.<br>y의 값이 없으면 0으로 가정하여 계산</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/5zwejxg6/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="rotate-회전하기"><a href="#rotate-회전하기" class="headerlink" title="rotate - 회전하기"></a>rotate - 회전하기</h2><p>Ex) transform: rotate(angle)<br>요소를 자신의 원점(또는 transform-origin 속성에 설정된 지점)을 기준으로<br>angle 각도만큼 시계방향으로 회전시킨다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/kf3cxygv/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>transform-origin은 rotate(), skew() 등의<br>회전, 변형 속성을 사용하기 전에 기준점을 정해 두는 것이고<br>디폴트 값은 (50%, 50%)입니다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/h0ey5fcd/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="skew-기울이기"><a href="#skew-기울이기" class="headerlink" title="skew - 기울이기"></a>skew - 기울이기</h2><p>Ex) transform: skew(angleX, angleY)<br>요소에 x,y 축을 중심으로 각 angle 각도 만큼 기울인다.<br>angleY 값이 없으면 Y축 연산은 하지않는다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/e1wohf3v/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="matrix"><a href="#matrix" class="headerlink" title="matrix"></a>matrix</h2><p>Ex1) transform: matrix(1,2,3,4,5,6)<br>Ex2) matrix(scaleX(), skewY(), skewX(), scaleY(), translateX(), translateY());<br>martrix는 다른 함수들의 기초가 되는 함수입니다.<br>그래서 matrix를 제대로 쓸 줄 알면 다른 transform 함수들을 조합해서<br>사용하는 것보다 간결하게 작성할 수 있습니다.</p><p><img src="/images/matrix.png" alt="matrix 정보 이미지"></p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/6gj943kp/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="perspective-시점-또는-관찰자-관점-원근감-깊이감"><a href="#perspective-시점-또는-관찰자-관점-원근감-깊이감" class="headerlink" title="perspective - 시점(또는 관찰자 관점,원근감,깊이감)"></a>perspective - 시점(또는 관찰자 관점,원근감,깊이감)</h2><p>원근감을 제어합니다.<br>값이 작을 수록 가까이에서 보는 것 같이 느껴지고 3D 효과도 커집니다.</p><p>쉽게 표현하자면 멀리 떨어져있는것은 작게만들고<br>가까운곳에 있는것은 크게만들어서 원근감을 부여하는것입니다.<br>perspective() 함수를 이용해서 transform 속성에 지정할 수도 있고<br>perspective 속성을 이용해서 부모요소에 지정할 수도 있습니다.<br>부모요소에 지정할 경우 자식요소들이 동일한 소실점을 갖습니다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/u5gvdzy9/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="부모-perspective-와-자식-perspective-차이"><a href="#부모-perspective-와-자식-perspective-차이" class="headerlink" title="부모 perspective 와 자식 perspective 차이"></a>부모 perspective 와 자식 perspective 차이</h2><iframe scrolling="no" width="100%" height="600" src="//jsfiddle.net/enphb0fw/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>부모요소에 perspective을 주면<br>원근감이 개별적이지않고 전체적으로 영향을 주기때문에 각각의 요소의 변형이 다르게 나타난다.</p><p>하지만 자식요소에  perspective을 주면<br>요소마다 개별적으로 영향을 주기때문에 각각의 요소의 변형이 동일하다.</p><h2 id="perspective-와-translateZ"><a href="#perspective-와-translateZ" class="headerlink" title="perspective 와 translateZ"></a>perspective 와 translateZ</h2><iframe scrolling="no" width="100%" height="700" src="//jsfiddle.net/2kaw5fgu/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p><img src="/images/perspective.png" alt="원근감 이해 이미지"></p><h2 id="translate-와-rotate-동시-변화-및-순서-변경"><a href="#translate-와-rotate-동시-변화-및-순서-변경" class="headerlink" title="translate 와 rotate 동시 변화 및 순서 변경"></a>translate 와 rotate 동시 변화 및 순서 변경</h2><iframe scrolling="no" width="100%" height="700" src="//jsfiddle.net/zs8mL5w1/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>결과가 다른이유는 축을 기점으로 이동하기 때문이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;transform-화면-변형&quot;&gt;&lt;a href=&quot;#transform-화면-변형&quot; class=&quot;headerlink&quot; title=&quot;transform (화면 변형)&quot;&gt;&lt;/a&gt;transform (화면 변형)&lt;/h1&gt;&lt;p&gt;transform은 엘리먼
      
    
    </summary>
    
      <category term="css" scheme="http://shs400.github.io/categories/css/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/css/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/css/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="css" scheme="http://shs400.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>javascript - call(),apply(), bind() 메서드</title>
    <link href="http://shs400.github.io/2018/01/02/script-study03/"/>
    <id>http://shs400.github.io/2018/01/02/script-study03/</id>
    <published>2018-01-02T07:43:50.000Z</published>
    <updated>2019-01-10T01:17:00.017Z</updated>
    
    <content type="html"><![CDATA[<p>call(),apply(), bind() 메서드<br><!-- excerpt --></p><p>앞서 설명하였던 기본적인 this 바인딩 3가지 방법 외에도<br>메서드를 이용하여 임의적으로 특정 객체에 바인딩 시키는 방법이 3가지 존재한다.</p><p>1) apply() 메서드</p><ul><li>apply은 파라미터 중 첫 번째 인자를 함수 내부에서 사용할 this로 만들어준다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Name = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objName = &#123;&#125;</span><br><span class="line">Name.apply(objName,[<span class="string">'sim'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(objName);</span><br><span class="line"><span class="comment">//&#123; name: 'sim' &#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>2) call() 메서드</p><ul><li>call은 apply와 기능은 같지만, 두번째 매개변수가 배열이 아닌 각각의 값으로 넘길 수 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Name = <span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objName = &#123;&#125;</span><br><span class="line">Name.call(objName,<span class="string">'sim'</span>,<span class="number">31</span>);</span><br><span class="line"><span class="built_in">console</span>.log(objName);</span><br><span class="line"><span class="comment">//&#123; name: 'sim', age: 31&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>3) bind() 메서드 ※ es5 문법</p><ul><li>함수가 가리키는 this만 바꾸고 호출하지는 않음.</li><li>새 함수를 만드는데 그 this는 bind에 전달된 값. <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"> <span class="keyword">var</span> example = &#123; <span class="attr">color</span> : <span class="string">"blue"</span>&#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">colorValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line"> &#125;</span><br><span class="line">colorValue();</span><br><span class="line"><span class="keyword">var</span> bindColor = colorValue.bind(example);</span><br><span class="line">bindColor();</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure></li></ul><p>colorValue 함수의 this는 window 이므로 red 가 출력되고<br>colorValue에 example 을 bind 해줄시 this가 example 객체를 가리키므로<br>this.color 값은 blue가 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;call(),apply(), bind() 메서드&lt;br&gt;&lt;!-- excerpt --&gt;&lt;/p&gt;
&lt;p&gt;앞서 설명하였던 기본적인 this 바인딩 3가지 방법 외에도&lt;br&gt;메서드를 이용하여 임의적으로 특정 객체에 바인딩 시키는 방법이 3가지 존재한다.&lt;/
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>javascript - this 바인딩</title>
    <link href="http://shs400.github.io/2018/01/02/script-study02/"/>
    <id>http://shs400.github.io/2018/01/02/script-study02/</id>
    <published>2018-01-02T06:54:29.000Z</published>
    <updated>2019-01-10T01:17:00.023Z</updated>
    
    <content type="html"><![CDATA[<p>this 바인딩<br><!-- excerpt --></p><p>this 바인딩은 기본적으로 3가지 유형이 있다.<br>this는 함수가 호출되는 패턴에 따라 this가 어디에 바인딩 되는지 결정된다.</p><ol><li><p>전역함수를 호출할 떄 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="string">'global'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> global = <span class="string">'local'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this.global : '</span>,<span class="keyword">this</span>.global);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this : '</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func();</span><br><span class="line"><span class="comment">// global</span></span><br><span class="line"><span class="comment">// window</span></span><br></pre></td></tr></table></figure></li><li><p>함수가 객체의 속성이고 해당 객체를 통해 함수를 호출할 때</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    func : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.func();</span><br><span class="line"><span class="comment">// object ( obj 객체 )</span></span><br></pre></td></tr></table></figure></li><li><p>생성자 함수(new)를 호출할 때 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name || <span class="string">'empty'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sim = <span class="keyword">new</span> Person(<span class="string">'sim'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sim.name);</span><br></pre></td></tr></table></figure></li></ol><p>이외의 방법으로 call(),apply(), bind() 메서드가 존재한다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;this 바인딩&lt;br&gt;&lt;!-- excerpt --&gt;&lt;/p&gt;
&lt;p&gt;this 바인딩은 기본적으로 3가지 유형이 있다.&lt;br&gt;this는 함수가 호출되는 패턴에 따라 this가 어디에 바인딩 되는지 결정된다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;전역함수를 호출
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>javascript - clouser(클로저)</title>
    <link href="http://shs400.github.io/2017/12/29/script-study01/"/>
    <id>http://shs400.github.io/2017/12/29/script-study01/</id>
    <published>2017-12-29T02:04:32.000Z</published>
    <updated>2019-01-10T01:17:03.717Z</updated>
    
    <content type="html"><![CDATA[<p>clouser(클로저)<br><!-- excerpt --></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> name = <span class="string">'SIM'</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'My name is '</span>+name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myName = outerFunc();</span><br><span class="line">myName(); <span class="comment">// My name is SIM</span></span><br></pre></td></tr></table></figure><p>outerFunc 함수는 함수 내부에 name 지역 변수를 가지고 있고,<br>return 값으로 익명함수(inner함수라고 생각하자)를 가지고 있다.</p><p>아래에서 선언해준 myName 변수에 outerFunc()를 저장한다는 것은<br>myName은 outerFunc 함수의 return 값인 익명함수를 저장한다는 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'My name is '</span>+name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>myName 에는 함수가 담겨있으므로 실행이 가능하고<br>myName()을 호출하면 ‘My name is SIM’ 라는 문자열이 console.log로 인해 출력된다.</p><p>여기서 이상한점은 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'My name is '</span>+name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myName(); <span class="comment">// My name is SIM</span></span><br></pre></td></tr></table></figure><p>이부분에서 myName을 호출할때 익명함수 안의<br>console.log(‘My name is ‘+name) 의 name은 어디에도 존재하지 않는다.<br>그렇다면 당연히 not defined 에러가 나야하지만<br>실행해보면<br>‘My name is SIM’ 을 출력할 것이다.<br>이것이 Clouser(클로저)이다.</p><p>외부함수안의 내부함수를 호출할 때 이미 종료된 외부함수의 환경을 기억하여 사용한다.<br>즉, outerFunc 함수안의 내부함수(위의 예시의 익명함수)를 호출할 때<br>이미 호출되고 종료되어 접근 할 수 없는 outerFunc 함수의 환경을 기억해<br>name 값을 사용하는 것이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;clouser(클로저)&lt;br&gt;&lt;!-- excerpt --&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
  </entry>
  
</feed>
