<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Roy Blog</title>
  <icon>https://www.gravatar.com/avatar/0564578760656ea13d584c96ba9a60c0</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shs400.github.io/"/>
  <updated>2019-01-29T08:21:19.524Z</updated>
  <id>http://shs400.github.io/</id>
  
  <author>
    <name>shs400</name>
    <email>tlagustn88@naver.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>immutable</title>
    <link href="http://shs400.github.io/2019/01/29/immutable/"/>
    <id>http://shs400.github.io/2019/01/29/immutable/</id>
    <published>2019-01-29T02:23:16.000Z</published>
    <updated>2019-01-29T08:21:19.524Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="Immutable-JS"><a href="#Immutable-JS" class="headerlink" title="Immutable JS"></a>Immutable JS</h1><p>저희가 사용하는 React와 Redux에서는 immutablity(불변성)를 항상 강조하고 있습니다.<br>Immutable JS에 대해 설명하기전에 immutablity(불변성)에 대해 설명을 하고 넘어가겠습니다.</p><h2 id="immutablity란"><a href="#immutablity란" class="headerlink" title="immutablity란?"></a>immutablity란?</h2><p>불변성 - 말 그대로 변하지 않는다는 것 입니다.<br>※ 우선 리액트 코드를 예를 들어 불변성에 대해 설명하고, Immutable JS 가 필요한 이유에 대해 설명하겠습니다.</p><p>React는 state의 불변성을 유지해야 한다고 합니다. 그렇기 때문에<br>state를 변경할때는 필수로 setState를 사용하여 업데이트를 해야하고,<br>state 객체 값을 <strong>직접 수정하면 안됩니다.</strong> </p><p>코드로 보자면<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  userList: [</span><br><span class="line">    &#123; </span><br><span class="line">      name: <span class="string">'sim'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; </span><br><span class="line">      name: <span class="string">'park'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>리액트 state에 userList라는 배열이 있고, 그 배열에 name: ‘kim’을 추가하거나<br>기존 userList를 수정한다 했을 때 아래와 같이 수정을 하는분들도 있을 것 입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state.userList.push(&#123; <span class="attr">name</span>: <span class="string">'kim'</span> &#125;);</span><br><span class="line">or</span><br><span class="line"><span class="keyword">this</span>.state.userList[<span class="number">0</span>].name = <span class="string">'lee'</span>;</span><br></pre></td></tr></table></figure><p>리액트를 사용하신다면 절대 위와 같이 사용하면 안됩니다.<br>리액트는 상태가 변할때 리렌더링이 되고, 리렌더링은 setState를 통해서 동작하도록 되어있습니다.<br>그렇기 때문에 아래 코드와 같이 수정해주어야 합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  name: <span class="string">'kim'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>위와 같이 setState를 이용하여 코드 작성시<br>리액트의 기본속성중의 하나인 부모 컴포넌트가 리렌더링 되면, 자식컴포넌트도 리렌더링 되는 현상을 보실 수 있을겁니다.<br>그 과정은 가상 DOM에서만 이뤄지는 렌더링이고, 렌더링 후에 리액트의 diffing알고리즘을 통하여 변화가 일어나는 부분만 실제로 업데이트 해준다고 합니다.</p><p>Ex)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ItemList <span class="keyword">from</span> <span class="string">"./item"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    users: PropTypes.array,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    users: [],</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  renderList() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; users &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> users.map(<span class="function">(<span class="params">user</span>) =&gt;</span> &lt;ItemList key=&#123;<span class="string">`<span class="subst">$&#123;user.id&#125;</span>_key`</span>&#125; user=&#123;user&#125; /&gt;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'users List 렌더됨 : '</span>,<span class="keyword">this</span>.props.users)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123; <span class="keyword">this</span>.renderList() &#125;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default UserList;</span></span><br></pre></td></tr></table></figure></p><p>해당 코드는 유저 리스트 화면을 렌더링해주는 코드입니다.<br>처음 렌더링이 될때 유저의 정보를 받고 해당 텍스트를 console에 출력합니다.<br><img src="/images/immutable/immutable01.png#left" alt="immutable"></p><p>문제는 부모컴포넌트에서 추가로 userList를 입력했을시 setState를 통해 상태를 변경해주면, 부모컨테이너가 리렌더링 되면서 자식 컴포넌트인 UserList 컴포넌트도 리렌더링 되게됩니다.<br>만약 부모 컴포넌트에서 입력해주는 input이 변경될때마다 setState를 변경시켰다면, 부모 컨테이너는 물론 UserList컨테이너 까지 리렌더링이되어 아래와 같은 문제가 나타나게 됩니다.<br><img src="/images/immutable/immutable02.png#left" alt="immutable"></p><p>실제 UserList는 변경되지 않았는데, 계속해서 리렌더링되고 있습니다. 실제 DOM에 반영되지 않는다 하더라도<br>미세하게 CPU 낭비가 존재 할 것이며, 이런 낭비를 없애기 위해 shouldComponentUpdate 라이프 사이클 훅을 작성합니다.<br>불변함을 유지하면서 코드를 짯기 때문에 아주 쉽게 코드를 작성할 수 있을 것입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  <span class="keyword">return</span> nextProps.users !== <span class="keyword">this</span>.props.users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserList 컴포넌트에 shouldComponentUpdate 라이프 사이클 훅에, 전달받은 props를 비교하여, Boolean 값을 리턴 해줌으로써<br>리렌더링을 할것인지 말것인지 판단하도록 해주게 됩니다.</p><p>드디어 immutable JS에 관해 설명을 하도록 하겠습니다.</p><p>이렇게 위의 내용처럼 최적화를 위해 불변성을 유지시켜 코드를 작성하다보면 복잡한 상태가 있을 수도 있습니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  userList: [</span><br><span class="line">    &#123; </span><br><span class="line">      id: <span class="number">01</span>,</span><br><span class="line">      name: <span class="string">'sim'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; </span><br><span class="line">      id: <span class="number">02</span>,</span><br><span class="line">      name: <span class="string">'park'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>이런 상태의 객체에서 불변성을을 유지하면서 userList 배열의 2번째 객체 이름을 변경하려면,<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; userList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"><span class="keyword">const</span> copyUser = [ ...userList ]; </span><br><span class="line"><span class="comment">// copyUser라는 변수에 spread 연산자를 통해 값을 복사해 넣습니다.</span></span><br><span class="line">copyUser[<span class="number">1</span>] = &#123;</span><br><span class="line">  ...userList[<span class="number">1</span>],</span><br><span class="line">  name: <span class="string">'lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  userList: copyUser</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>이렇게 userList의 2번째 객체이름을 변경해주면 불변성을 유지하면서 변경해줄 수 있습니다.<br>하지만 이런 구조가 더 깊은 구조로 되어있다면… 아래 내용처럼 해주어야합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  userList: &#123;</span><br><span class="line">    id: &#123;</span><br><span class="line">      idx: <span class="number">1</span>,</span><br><span class="line">      userName: &#123;</span><br><span class="line">        name: <span class="string">'sim'</span>,</span><br><span class="line">        friendsName: <span class="string">'park'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>위 코드를 불변성을 유지하며 변경하려면..<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; userList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"><span class="keyword">const</span> copyData = &#123; ...userList &#125;; </span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  userList: &#123;</span><br><span class="line">    ...copyData</span><br><span class="line">    id: &#123;</span><br><span class="line">      ...copyData.id</span><br><span class="line">      userName: &#123;</span><br><span class="line">        ...copyData.id.userName.name,</span><br><span class="line">        friends: <span class="string">'lee'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>이런식으로 spread 연산자가 반복적으로 사용되게 됩니다.<br>이렇게 번거롭고 복잡한 작업이 있을때 사용되는것이<br><strong>Immutable JS</strong> 입니다.</p><p>우선 immutable은 규칙이 있습니다.</p><ol><li>List - 배열</li><li>Map - 객체</li><li>set - 설정</li><li>get - 불러오기(읽기)</li><li>update - 불러오고 업데이트 시</li><li>List에 배열의 내장함수와 비슷한 함수들 존재 ( push, slice, filter 등 <a href="https://facebook.github.io/immutable-js/docs/#/List" target="_blank" rel="noopener">공식 사이트 문서 List() 참조</a> )</li><li>toJS - 일반 javascript 로 변환</li><li>setIn, getIn, updateIn - 깊은 구조의 객체의 값을 set, get, update 할때 </li><li>delete - key를 지울때 </li></ol><hr><p>이렇게 여러가지 규칙이 있습니다.<br>자세한 내용은 <a href="https://facebook.github.io/immutable-js/" target="_blank" rel="noopener">공식 사이트 문서 참조</a>하시길 바랍니다.</p><p>위의 규칙들을 사용해 객체의 구조에 적용해 본다면<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  userList: <span class="built_in">Map</span>(&#123;</span><br><span class="line">    users: List([</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'sim'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'park'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이렇게 적용이 가능하게 됩니다. immutable로 감싼 state는 사용시에도 규칙을 따르는데,<br>input에 텍스트 입력 후 버튼 클릭하는 함수에 코드를 작성해보면</p><pre><code class="javascript">onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> {  <span class="keyword">const</span> { userList } = <span class="keyword">this</span>.state;  <span class="keyword">this</span>.setState({    userList: userList.update(<span class="string">'users'</span>, users =&gt; users.push(<span class="built_in">Map</span>({      name: <span class="string">'lee'</span> <span class="comment">// 입력을 lee로 했다고 가정함.</span>    })))  });}</code></pre><p>위와 같이 작성할 수 있습니다.</p><p>immutable을 왜 사용해야 하는지 필요성을 못느낄 수 도 있겠지만,<br>필자의 경우는 코드의 가독성을 위해서 위와 같은 상황에서는 사용하는 것을 추천합니다.</p><p>.get(), getIn()을 계속 하는게 싫다면 Record를 사용하면 좀 더 편리하게 사용할 수 있다고 합니다.<br>하지만 저는 Record는 따로 설명하지 않으려고 합니다.<br>그 이유는 다음 포스트로 작성할 Immer JS는 Immutable JS 대신 사용하는 라이브러리 인데<br>사용하게되면 Record 를 사용하는것과 다를것이 없다고 생각되어 Record 설명은 생략하도록 하겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;Immutable-JS&quot;&gt;&lt;a href=&quot;#Immutable-JS&quot; class=&quot;headerlink&quot; title=&quot;Immutable JS&quot;&gt;&lt;/a&gt;Immutable JS&lt;/h1&gt;&lt;p&gt;저희가 사용하는 Reac
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
      <category term="immutable" scheme="http://shs400.github.io/categories/javascript/blog/study/immutable/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="study" scheme="http://shs400.github.io/tags/study/"/>
    
      <category term="immutable" scheme="http://shs400.github.io/tags/immutable/"/>
    
  </entry>
  
  <entry>
    <title>Test Utility - Enzyme</title>
    <link href="http://shs400.github.io/2019/01/23/enzyme/"/>
    <id>http://shs400.github.io/2019/01/23/enzyme/</id>
    <published>2019-01-23T04:18:23.000Z</published>
    <updated>2019-01-24T00:58:04.906Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="Test-Utility-Enzyme"><a href="#Test-Utility-Enzyme" class="headerlink" title="Test Utility - Enzyme"></a>Test Utility - Enzyme</h1><p>이번장은 앞장에서 설명한 <a href="//2019/01/22/jest/">Test FrameWork: Jest</a>에 이어서<br>React를 위한 자바스크립트 테스트 유틸리티인 Enzyme(엔자임)을 설명하려고 합니다.</p><h2 id="Enzyme이란"><a href="#Enzyme이란" class="headerlink" title="Enzyme이란?"></a>Enzyme이란?</h2><p>Enzyme은 airbnb에서 개발한 <strong>React용 컴포넌트 테스트 플러그인</strong>입니다.<br>컴포넌트를 얖게(shallow) 렌더링해서 테스트 해 볼 수 있고, 전체 DOM을 불러와 확인 할 수도 있습니다.<br>또한 그 형태가 jQuery 형태로 컴포넌트를 조회할 수 있기 떄문에, <strong>컴포넌트 테스트</strong>로는 Enzyme이 매우 유용합니다.</p><h2 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h2><p>우선 npm으로 enzyme &amp; enzyme-adapter-react-16 를 설치합니다.<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev enzyme enzyme-adapter-react-<span class="number">16</span></span><br></pre></td></tr></table></figure></p><p>enzyme-adapter-react-16은<br>Enzyme이 react 16버전과 react 15버전에서 다르게 동작하기 때문에 enzyme-adapter-react-16 을 사용하여<br>react 16을 사용하고 있음을 알려주는 서드파티 입니다.</p><p>자 이제 앞장(<a href="//2019/01/22/jest/">Test FrameWork: Jest</a>)에서 작성했던 Counter.test.jsx 테스트 코드에 enzyme을 적용해보겠습니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> renderer <span class="keyword">from</span> <span class="string">"react-test-renderer"</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./index'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Counter'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> component = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'renders correctly'</span>, () =&gt; &#123;</span><br><span class="line">    component = renderer.create(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('matches snapshot', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    expect(component).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('increases correctly', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    component.getInstance().onIncrease();</span></span><br><span class="line"><span class="xml">    expect(component.getInstance().state.value).toBe(2);</span></span><br><span class="line"><span class="xml">    expect(component).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('decreases correctly', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    component.getInstance().onDecrease();</span></span><br><span class="line"><span class="xml">    expect(component.getInstance().state.value).toBe(1);</span></span><br><span class="line"><span class="xml">    const tree = component.toJSON();</span></span><br><span class="line"><span class="xml">    expect(tree).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure></p><p>위의 테스트 코드에 Enzyme을 적용하면<br>이제는 react-test-renderer 대신 Enzyme의 shallow를 사용하게됩니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; shallow, configure &#125; <span class="keyword">from</span> <span class="string">'enzyme'</span>;</span><br><span class="line"><span class="keyword">import</span> Adapter <span class="keyword">from</span> <span class="string">'enzyme-adapter-react-16'</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./index'</span>;</span><br><span class="line">configure(&#123; <span class="attr">adapter</span>: <span class="keyword">new</span> Adapter() &#125;);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Counter'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> component = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'renders correctly'</span>, () =&gt; &#123;</span><br><span class="line">    component = shallow(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('matches snapshot', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    expect(component).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('increases correctly', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    component.instance().onIncrease();</span></span><br><span class="line"><span class="xml">    expect(component.state().value).toBe(2);</span></span><br><span class="line"><span class="xml">    expect(component).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('decreases correctly', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    component.instance().onDecrease();</span></span><br><span class="line"><span class="xml">    expect(component.state().value).toBe(1);</span></span><br><span class="line"><span class="xml">    expect(component).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure></p><p>Enzyme에서 configure를 제외한다면 크게는 3가지 메서드가 존재하고, 그 메서드는 shallow, mount, render 입니다.</p><ol><li>shallow: 간단한 컴포넌트를 메모리에 렌더링합니다. ( 단일 컴포넌트를 테스트할 때 유용합니다. )</li><li>mount: HOC나 자식 컴포넌트 까지 전부 렌더링합니다. ( 다른 컴포넌트와의 관계를 테스트할 때 유용합니다. )</li><li>render: 컴포넌트를 정적인 html로 렌더링합니다. ( 컴포넌트가 브라우저에 붙었을 때 html로 어떻게 되는지 판단할 때 사용합니다.)</li></ol><hr><p>※ shallow 와 mount 두 API는 유사한 동작을 합니다.<br>그러나 mount가 좀 더 실제에 가깝게 동작을 합니다.<br>공식문서에는 테스트할 컴포넌트가 DOM API를 사용하거나 라이프사이클 훅 을 모두 활용할떄 mount API를 사용하는것을 권장하고 있습니다.</p><p>특히 라이프 사이클 훅 관련하여 shallow와 mount는 차이점이 있습니다.<br>mount API는 모든 라이프사이클 훅이 호출되고,<br>shallow API는 componentDidmount 와 componentDidUpdate를 제외한 라이프사이클 훅이 호출된다는 점입니다.<br>이러한 차이점을 유의하여 필요에 따라 API를 사용하시면 됩니다. </p><p>위의 코드가 Enzyme을 적용한 코드인데<br>이렇게만 보면 굳이 왜? react-test-renderer 대신 Enzyme의 shallow를 사용하지? 라고 생각할 수 있을 것 입니다.</p><p>하지만<br>Enzyme을 사용하면 저희는 DOM이벤트를 시뮬레이트 해 볼 수 있습니다.<br>DOM이벤트를 시뮬레이트한다? 필자는 글로봐서는 감이 오지 않았습니다.</p><p>Enzyme API중 simulate를 사용하게 되는 것 인데,<br>위의 Enzyme 적용 테스트 코드 내용 중<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component.instance().onIncrease()</span><br></pre></td></tr></table></figure></p><p>처럼 함수를 실행하는 것이 아니라<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component.find(<span class="string">'.increaseButton'</span>).simulate(<span class="string">'click'</span>);</span><br></pre></td></tr></table></figure></p><p>처럼 실제로 카운트를 증가시키는 버튼을 마우스를 클릭하는 이벤트를 시뮬레이션 할 수 있게 되고,<br>아래의 테스트 코드처럼 테스트 할수 있게 됩니다.<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it('increases correctly', () =&gt; &#123;</span><br><span class="line">  component.<span class="built_in">find</span>('.increaseButton').simulate('click');</span><br><span class="line">  expect(component.state().value).toBe(<span class="number">2</span>);</span><br><span class="line">  expect(component).toMatchSnapshot();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>이렇게 Enzyme을 사용하면 특정 DOM에 이벤트를 시뮬레이트 할 수 도 있고, 그 외에도 수 많은 기능들이 있습니다.<br>나머지 수많은 기능들은 <a href="https://airbnb.io/enzyme/" target="_blank" rel="noopener">Enzyme 공식 홈페이지</a>를 참고하여 필요에 따라 사용하시길 바랍니다.</p><p>마지막으로 Jest와 Enzyme을 같이 사용하면 스냅샷이 보기 힘든 형태로 나오게 되는데 이 부분은<br>pakage.json에<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"jest"</span>: &#123;</span><br><span class="line">    <span class="string">"snapshotSerializers"</span>: [</span><br><span class="line">      <span class="string">"enzyme-to-json/serializer"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>를 추가해주시면 됩니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;Test-Utility-Enzyme&quot;&gt;&lt;a href=&quot;#Test-Utility-Enzyme&quot; class=&quot;headerlink&quot; title=&quot;Test Utility - Enzyme&quot;&gt;&lt;/a&gt;Test Utili
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="test" scheme="http://shs400.github.io/categories/javascript/blog/test/"/>
    
      <category term="tdd" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/"/>
    
      <category term="framework" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/framework/"/>
    
      <category term="jest" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/framework/jest/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/framework/jest/study/"/>
    
      <category term="enzyme" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/framework/jest/study/enzyme/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="test" scheme="http://shs400.github.io/tags/test/"/>
    
      <category term="tdd" scheme="http://shs400.github.io/tags/tdd/"/>
    
      <category term="framework" scheme="http://shs400.github.io/tags/framework/"/>
    
      <category term="jest" scheme="http://shs400.github.io/tags/jest/"/>
    
      <category term="enzyme" scheme="http://shs400.github.io/tags/enzyme/"/>
    
  </entry>
  
  <entry>
    <title>Test FrameWork - Jest</title>
    <link href="http://shs400.github.io/2019/01/22/jest/"/>
    <id>http://shs400.github.io/2019/01/22/jest/</id>
    <published>2019-01-22T01:52:04.000Z</published>
    <updated>2019-01-23T07:23:32.390Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="Test-Framework-Jest"><a href="#Test-Framework-Jest" class="headerlink" title="Test Framework - Jest"></a>Test Framework - Jest</h1><p>이번 내용은 리액트 테스트 프레임워크인 jest에 대해 설명하려고 합니다.</p><p>필자는 우선 테스트라는 것은 전혀 생각도 하지 않았고, 몇년전 모임 스터디중 Jasmine(자스민)을<br>아주 잠깐 맛보기로 써봤을 뿐이였습니다. 그당시 자스민을 쓰면서도 이걸 언제 작성하고 할까.. 귀찮은데..<br>재미도없어.. 이런 마음이 컷기 때문에 맛보기 정도만 해보고 그대로 저의 기억속에서 잊혀졌습니다.</p><p>그러다 최근 팀에 새로 입사하신분께서 jest에 대해 설명해주셨고, 유용함을 이제서야 느끼게 되어<br>이 글을 작성하게 되었습니다.</p><p>그렇다면 왜 테스트를 해야하는가에 대해 먼저 얘기해 보겠습니다.</p><h2 id="테스트-Why"><a href="#테스트-Why" class="headerlink" title="테스트.. Why?"></a>테스트.. Why?</h2><p>물론 저는 아직도 테스트를 반드시, 무조건 해야한다고 생각하지는 않습니다.<br>실무에 이미 도입되어있거나 혹은 도입하기위해 실무에 바로 써야하는 분들의 경우도 있을 것 이며,<br>아직 테스트코드에 대해 모르거나 예전의 저처럼 비관적으로 바라보는 경우도 있을 것 입니다.<br>왜냐하면 혼자하는 작업이거나 소규모 프로젝트라면 오히려 진행 속도를 늦출 수 있기 때문입니다.</p><p>일단 장점과 단점을 설명하자면 아래와 같습니다.</p><p><strong>장점</strong></p><ol><li>리팩토링할때 좋다.<ul><li>리팩토링 후에도 해당 모듈이 의도대로 작동하고 있음을 유닛 테스트를 통해서 확신할 수 있는데, 이를 회귀 테스트(Regression testing)라 합니다.</li></ul></li><li>협업시 좋다.<ul><li>A의 코드와 B의 코드로 C 라는 기능을 구현 하는데, A를 수정한뒤에 A 코드의 정상 동작을 확인 하였는데, 갑자기 A에서 문제가 생겼다고 했을시 기존에 유닛 테스트를 했다면<br>A코드의 문제를 바로 발견하고 수정했을것입니다. 하지만 유닛코드를 작성하지 않았다면 어디서 버그가 나타났는지 찾기 힘들것입니다.     </li></ul></li><li>그룹내에 공용으로 사용하여 테스트 코드를 늘릴 수 있다. ( 예외적인 상황 )<ul><li>예를 들면 같은 개발팀 내에서 validation 관련 컴포넌트 &amp; 테스트 코드를 공유하며 하나하나씩 테스트 코드를 작성하다보면 테스트 코드가 공유되고 양도 늘어나 더욱 빠른 테스트 환경을 만들 수 있다.</li></ul></li></ol><hr><p><strong>단점</strong></p><ol><li>시간이 걸린다.<ul><li>테스트 코드 작성 및 러닝커브</li></ul></li></ol><hr><p>이처럼 유닛테스트는 개발 시간을 증가 시키는것 처럼 보일 수 있습니다.<br>하지만 유닛테스트를 함으로써 개발 기간 중 대부분을 차지하는 디버깅 시간을 단축시킬수 있기 때문에 필수는 아니지만<br>할 수 있다면 작성 하며 개발 하는 것을 개인적으로는 추천합니다.</p><p>*필자는 그전에 개발을 하였을 때 테스트 없이 개발 하였고, 리팩토링하거나 코드 수정시 기존의 기능들이 제대로 동작하는지 하나하나 확인 했었는데,<br>테스트 코드를 작성함으로써 테스트만 돌리면 따로 확인작업을 하지않아도 된다는 것이 매력적으로 다가왔습니다.<br>물론 테스트 코드가 100%를 테스트 해주진 않겠지만 ( 테스트 코드 작성에 따라 다름으로 ) 어느정도 커버해준다는 것만 으로도 큰 매력이 있다고 생각합니다. </p><p>다음으로 이제 jest에 대해 설명하도록 하겠습니다.<br>(필자는 react를 사용하며 react에 최적화되어있는 test framework인 jest에 대해 알아보려고 합니다.)</p><h2 id="Jest란"><a href="#Jest란" class="headerlink" title="Jest란?"></a>Jest란?</h2><p>Jest는 페이스북에서 만든 테스트 프레임워크입니다.<br>React를 포함한 모든 자바스크립트 코드를 테스트하는데 사용될 수 있습니다.<br>Jest의 철학중 “Zero-Configuration”이 있는데, 이는 아래와 같이 설정 없는 테스트 환경을 제공한다고 합니다.<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev jset // jest 설치</span><br><span class="line">npm run jest // jest 시작</span><br></pre></td></tr></table></figure></p><p>이렇게 간단하게 설치와 테스트를 할 수 있습니다.<br>물론 테스트 코드를 작성하는것은 별개의 작업이지만 따로 설정이 필요없이 설치만 하면 테스트를 할수 있는 환경이 이루어집니다.</p><p>이렇게 Jest를 사용하여 저희는 <strong><a href="https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%9B_%ED%85%8C%EC%8A%A4%ED%8A%B8" target="_blank" rel="noopener">Unit Test(단위 테스트)</a></strong>를 해보려고 합니다.</p><h2 id="Unit-Test-단위-테스트-란"><a href="#Unit-Test-단위-테스트-란" class="headerlink" title="Unit Test(단위 테스트)란?"></a>Unit Test(단위 테스트)란?</h2><p><strong>Unit Test</strong>란, 소프트웨어를 최소한의 단위로 쪼개서 아주 작은 단위로 테스트 하는 것 을 말합니다.<br>예를 들자면 React에 A라는 Counter 컴포넌트가 있다면, A컴포넌트의 카운트 증가 함수를 테스트 하거나 카운트 감소 함수를 테스트 하는 것을 말합니다.</p><h2 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h2><p>기본적으로 React는 사용 하실줄 안다는 것을 가정하여 설명하도록 하겠습니다.<br>( 아래와 같이 Counter.jsx 컴포넌트 코드와 Counter.test.jsx 컴포넌트 테스트 코드를 먼저 작성합니다. )</p><p>Counter.jsx<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onIncrease = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">&#123;value&#125;</span>) =&gt;</span> (&#123; <span class="attr">value</span>: value + <span class="number">1</span> &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onDecrease = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">&#123;value&#125;</span>) =&gt;</span> (&#123; <span class="attr">value</span>: value &lt;= <span class="number">0</span> ? value : value - <span class="number">1</span> &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;카운터 예제&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;&#123;value&#125;&lt;/</span>h2&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.onIncrease&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.onDecrease&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Counter;</span></span><br></pre></td></tr></table></figure></p><p>Counter.test.jsx<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> renderer <span class="keyword">from</span> <span class="string">'react-test-renderer'</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./index'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Counter'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> component = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'renders correctly'</span>, () =&gt; &#123;</span><br><span class="line">    component = renderer.create(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('matches snapshot', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    const tree = component.toJSON();</span></span><br><span class="line"><span class="xml">    expect(tree).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  //increase 동작 확인</span></span><br><span class="line"><span class="xml">  it('increases correctly', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    component.getInstance().onIncrease();</span></span><br><span class="line"><span class="xml">    expect(component.getInstance().state.value).toBe(2); // value 값이 2인지 확인</span></span><br><span class="line"><span class="xml">    const tree = component.toJSON(); // re-render</span></span><br><span class="line"><span class="xml">    expect(tree).toMatchSnapshot(); // 스냅샷을 비교합니다.</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  // decrease 동작 확인</span></span><br><span class="line"><span class="xml">  it('decreases correctly', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    component.getInstance().onDecrease();</span></span><br><span class="line"><span class="xml">    expect(component.getInstance().state.value).toBe(1); // value 값이 1인지 확인</span></span><br><span class="line"><span class="xml">    const tree = component.toJSON(); // re-render</span></span><br><span class="line"><span class="xml">    expect(tree).toMatchSnapshot(); // 스냅샷을 비교합니다.</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure></p><p>중요한 것은 Counter.test.jsx 입니다. Counter.test.jsx 코드를 보시면<br>renderer, describe, it, expect등 처음 보는 메서드 들이 있을 것입니다.</p><p>describe와 it은 jest에서 제공되는 함수입니다.<br>describe는 테스트 묶음을 정의하고, it은 테스트 케이스를 정의 합니다.<br>( Counter.test.jsx 테스트 묶음(Suite)은 4개의 테스트를 가지고 있습니다. )</p><p>expect도 jest에서 제공하는 함수로 테스트값과 예상값이 일치하는지 여부를 판단합니다.<br>일치여부 뿐만 아니라 다른 비교도 할 수 있는데 <a href="https://jestjs.io/docs/en/expect.html" target="_blank" rel="noopener">Jest - Expect</a>에서 확인할 수 있습니다.</p><p>그리고 describe 와 it 에서 첫번째 파라미터는 해당 작업의 설명을 넣어주게 되는데,<br>describe 에서는 어떤 기능을 확인하는지, 그리고 it 부분에선 무엇을 검사해야 되는지에 대한 설명을 넣으시면 됩니다.</p><p>renderer는 스냅샷 테스트를 위해 사용되는 함수입니다. renderer를 사용하기위해서는 먼저 react-test-renderer 를 설치해 주어야합니다.<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev react-test-renderer</span><br></pre></td></tr></table></figure></p><p>react-test-renderer의 create() 함수는 인자로 리액트 컴포넌트를 받아 렌더링합니다.<br>이후 toMatchSnapshot() matcher를 통해 렌더링된 컴포넌트를 스냅샷과 비교할 수 있습니다.</p><h2 id="SnapShot-스냅샷-테스트란"><a href="#SnapShot-스냅샷-테스트란" class="headerlink" title="SnapShot(스냅샷) 테스트란?"></a>SnapShot(스냅샷) 테스트란?</h2><p>결과값을 파일로 저장해서 테스트할 때마다 테스트 결과값을 파일의 결과값과 비교합니다.<br>비교해서 다를때 개발자가 수정을 한 코드이면 업데이트를 하면되고( npm run jest – -u ),<br>의도하지 않은 코드라면 버그라고 판단하고 코드를 수정하면 될 것 입니다.</p><p>위의 Counter.test.jsx 테스트를 실행하면<br><img src="/images/jest/jest_img01.png#left" alt="snapshot"><br>이렇게 해당 테스트 코드 위치에 snapshots 폴더가 생기고 스냅샷 결과값은 아래와 같이 나오게된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">exports[<span class="string">`Counter decreases correctly 1`</span>] = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;h1&gt;</span></span><br><span class="line"><span class="string">    카운터</span></span><br><span class="line"><span class="string">  &lt;/h1&gt;</span></span><br><span class="line"><span class="string">  &lt;h2&gt;</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">  &lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;button</span></span><br><span class="line"><span class="string">    onClick=&#123;[Function]&#125;</span></span><br><span class="line"><span class="string">  &gt;</span></span><br><span class="line"><span class="string">    +</span></span><br><span class="line"><span class="string">  &lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;button</span></span><br><span class="line"><span class="string">    onClick=&#123;[Function]&#125;</span></span><br><span class="line"><span class="string">  &gt;</span></span><br><span class="line"><span class="string">    -</span></span><br><span class="line"><span class="string">  &lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line">exports[<span class="string">`Counter increases correctly 1`</span>] = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;h1&gt;</span></span><br><span class="line"><span class="string">    카운터</span></span><br><span class="line"><span class="string">  &lt;/h1&gt;</span></span><br><span class="line"><span class="string">  &lt;h2&gt;</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">  &lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;button</span></span><br><span class="line"><span class="string">    onClick=&#123;[Function]&#125;</span></span><br><span class="line"><span class="string">  &gt;</span></span><br><span class="line"><span class="string">    +</span></span><br><span class="line"><span class="string">  &lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;button</span></span><br><span class="line"><span class="string">    onClick=&#123;[Function]&#125;</span></span><br><span class="line"><span class="string">  &gt;</span></span><br><span class="line"><span class="string">    -</span></span><br><span class="line"><span class="string">  &lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line">exports[<span class="string">`Counter matches snapshot 1`</span>] = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;h1&gt;</span></span><br><span class="line"><span class="string">    카운터</span></span><br><span class="line"><span class="string">  &lt;/h1&gt;</span></span><br><span class="line"><span class="string">  &lt;h2&gt;</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">  &lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;button</span></span><br><span class="line"><span class="string">    onClick=&#123;[Function]&#125;</span></span><br><span class="line"><span class="string">  &gt;</span></span><br><span class="line"><span class="string">    +</span></span><br><span class="line"><span class="string">  &lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;button</span></span><br><span class="line"><span class="string">    onClick=&#123;[Function]&#125;</span></span><br><span class="line"><span class="string">  &gt;</span></span><br><span class="line"><span class="string">    -</span></span><br><span class="line"><span class="string">  &lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure></p><p>이렇게 작성된 스냅샷과 현재 코드와 비교하여 달라진 곳이 있는지 테스트 하게 되는 것 입니다.</p><p>지금까지 설명한데로 진행하게되면, 터미널에는 아래와 같은 메세지가 출력될 것입니다.<br><img src="/images/jest/jest_img02.png#left" alt="jset_test"></p><p>이를 바탕으로 더 많은 테스트 코드를 작성하여 안정성있는 코드를 작성하실 수 있길 바랍니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;Test-Framework-Jest&quot;&gt;&lt;a href=&quot;#Test-Framework-Jest&quot; class=&quot;headerlink&quot; title=&quot;Test Framework - Jest&quot;&gt;&lt;/a&gt;Test Frame
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="test" scheme="http://shs400.github.io/categories/javascript/blog/test/"/>
    
      <category term="tdd" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/"/>
    
      <category term="framework" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/framework/"/>
    
      <category term="jest" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/framework/jest/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/test/tdd/framework/jest/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="test" scheme="http://shs400.github.io/tags/test/"/>
    
      <category term="tdd" scheme="http://shs400.github.io/tags/tdd/"/>
    
      <category term="framework" scheme="http://shs400.github.io/tags/framework/"/>
    
      <category term="jest" scheme="http://shs400.github.io/tags/jest/"/>
    
  </entry>
  
  <entry>
    <title>WebGL-8</title>
    <link href="http://shs400.github.io/2019/01/22/WebGL-8/"/>
    <id>http://shs400.github.io/2019/01/22/WebGL-8/</id>
    <published>2019-01-22T01:51:31.000Z</published>
    <updated>2019-01-23T07:25:14.970Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-8-작성중"><a href="#WebGL-8-작성중" class="headerlink" title="WebGL ( 8 - 작성중 )"></a>WebGL ( 8 - 작성중 )</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-8-작성중&quot;&gt;&lt;a href=&quot;#WebGL-8-작성중&quot; class=&quot;headerlink&quot; title=&quot;WebGL ( 8 - 작성중 )&quot;&gt;&lt;/a&gt;WebGL ( 8 - 작성중 )&lt;/h1&gt;
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL-7</title>
    <link href="http://shs400.github.io/2018/12/24/WebGL-7/"/>
    <id>http://shs400.github.io/2018/12/24/WebGL-7/</id>
    <published>2018-12-24T00:17:36.000Z</published>
    <updated>2019-01-23T07:21:33.826Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-7-View"><a href="#WebGL-7-View" class="headerlink" title="WebGL ( 7 - View )"></a>WebGL ( 7 - View )</h1><p>이번장은 3D 도형을 구현하기전에 View 관점에 대해 설명하려고 합니다.<br>앞의 6장의 행렬과 관련된 내용입니다.</p><h2 id="모델-뷰-프로젝션-Matrix-MVP"><a href="#모델-뷰-프로젝션-Matrix-MVP" class="headerlink" title="모델, 뷰, 프로젝션 Matrix ( MVP )"></a>모델, 뷰, 프로젝션 Matrix ( MVP )</h2><p>먼저 랜더링 간단한 랜더링 파이프라인은 이렇습니다.</p><p><img src="/images/webgl6/matrix08.jpg" alt="matrix"></p><p>월드 -&gt; 카메라 -&gt; 투영행렬을 거쳐 3차원이 2차원으로 변환되는 과정입니다.<br>투영행렬이 끝난뒤에 클리핑과 뷰포트 변환이 있지만 여기서는 위와같이 투영 행렬까지만 설명합니다.</p><p><img src="/images/webgl6/matrix09.jpg" alt="matrix"></p><p><code>모델 Matrix</code>는 모델좌표계에서 월드 좌표계로 변환해주는 행렬입니다.<br>( 6장에서 배운 translate, scale, rotate 변환이 모델 Matrix 입니다. )</p><p><img src="/images/webgl6/matrix10.jpg" alt="matrix 변환"></p><p>다음으로 월드 좌표계에서 카메라 좌표계로 변환해줘야 하는데<br>이때 <code>뷰 Matrix</code>를 사용합니다.<br>( 이 과정에서 카메라의 이동이라던지 카메라 위치 설정등이 이루어지고 lookAt 함수를 사용하게 됩니다. )</p><p><img src="/images/webgl6/matrix11.jpg" alt="matrix 변환"></p><p>마지막으로 투영 변환 ( Projection Matrix )</p><p>월드 좌표계와 카메라 좌표계는 모두 3차원 좌표계입니다.<br>그러나 우리가 디스플레이로 확인하게 되는 랜더링 결과들은 모두 2차원의 화면입니다.<br>때문에 3차원 좌표계를 2차원 좌표계로 바꾸는 변환이 필요하다는 것을 알 수 있는데,<br>이때 <code>투영 변환</code>이 필요합니다.</p><p>투영 변환에는 perspective와 Orthographic가 있는데<br>우리는 perspective를 사용하도록 하겠습니다.</p><h3 id="perspective"><a href="#perspective" class="headerlink" title="perspective"></a>perspective</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Ex)</span><br><span class="line">mat4.perspective(view, canvas.width / canvas.height, <span class="number">0.1</span>, <span class="number">2000.0</span>, pMatrix);</span><br><span class="line"><span class="comment">// mat4.perspective 는 gl-matrix 라이브러리의 헬퍼 함수 </span></span><br><span class="line"><span class="comment">// (시야, 종횡비, 전방 및 후방 경계를 인자로 받는다.)</span></span><br><span class="line"><span class="comment">// 1. 시야 : 수직방향 시야각입니다.</span></span><br><span class="line"><span class="comment">// 2. 종횡비 : 화면 비 이고, 윈도우 크기에 의존합니다.</span></span><br><span class="line"><span class="comment">// 3. 근거리 잘라내기</span></span><br><span class="line"><span class="comment">// 4. 원거리 잘라내기</span></span><br></pre></td></tr></table></figure><iframe src="https://webgl2fundamentals.org/webgl/frustum-diagram.html" width="700px" height="600px" frameborder="0" allowfullscreen></iframe><p>출처 : [webglfundamentals.org]</p><p>위의 변환까지 모두 완료가 되면 GLSL에서<br>Model, View, Projection 을 모두 곱해줘야합니다.<br>이때 행렬의 곱 순서는 꼭 mvp의 역순으로 곱해주어야 합니다.<br>( MVPmatrix = projection X view X model; )</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=<span class="string">"shader-vs"</span> type=<span class="string">"x-shader/x-vertex"</span>&gt;</span><br><span class="line">    attribute vec3 aVertexPosition;</span><br><span class="line">    attribute vec4 aVertexColor;</span><br><span class="line"></span><br><span class="line">    uniform mat4 uMVMatrix;</span><br><span class="line">    uniform mat4 uPMatrix;</span><br><span class="line"></span><br><span class="line">    varying vec4 v_color;</span><br><span class="line">    <span class="keyword">void</span> main(<span class="keyword">void</span>) &#123;</span><br><span class="line">      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, <span class="number">1.0</span>);</span><br><span class="line">      v_color = aVertexColor * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>이번장은 여기서 마무리하고 다음장에서는 실제 3D 화면을 구현해 보도록 하겠습니다.</p><p><img src="/images/webgl6/matrix12.jpg" alt="matrix 변환"></p><p>핵심 위치에 라벨을 붙임</p><p><img src="/images/webgl6/matrix13.jpg" alt="matrix 변환"></p><p>라벨을 붙인후 각 라벨에 인덱스 정점을 활용</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-7-View&quot;&gt;&lt;a href=&quot;#WebGL-7-View&quot; class=&quot;headerlink&quot; title=&quot;WebGL ( 7 - View )&quot;&gt;&lt;/a&gt;WebGL ( 7 - View )&lt;/h1&gt;&lt;p&gt;이
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL ( 6 - Martrix )</title>
    <link href="http://shs400.github.io/2018/11/21/WebGL-6/"/>
    <id>http://shs400.github.io/2018/11/21/WebGL-6/</id>
    <published>2018-11-21T05:40:37.000Z</published>
    <updated>2019-01-23T07:21:33.842Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-6-Martrix"><a href="#WebGL-6-Martrix" class="headerlink" title="WebGL ( 6 - Martrix )"></a>WebGL ( 6 - Martrix )</h1><p>이번에는 3D를 표현하기에 앞서<br>Matrix(행렬)에 대해 설명부터 하려고 합니다.</p><p>3D를 표현하기전에<br>저희는 기존에 버텍스를(x,y,z,w) 다루었습니다.<br>( * 앞장까지는 x,y,z 만으로도 표현이 가능하였습니다. )</p><p>저희가 기억해야할 것은 w입니다.</p><ul><li><code>w = 1 이면 벡터공간에서의 점의 위치입니다. ( x, y, z, 1 )</code></li><li><code>w = 0 이면 벡터공간에서의 방향입니다. ( x, y, z, 0 )</code></li></ul><p>위의 내용은 무조건 기억하고 있어야합니다.</p><h3 id="Matrix-이해"><a href="#Matrix-이해" class="headerlink" title="Matrix 이해"></a>Matrix 이해</h3><p>3D 그래픽스에서 4x4 행렬을 주로 사용하는데,<br>이들은 우리의 (x,y,z,w) 버텍스들을 변형하게 해줍니다. 이에 대한 공식은 아래와 같습니다.<br>행렬 x 버텍스 = 변형된 버텍스 ( * 순서가 동일해야합니다. )</p><p><img src="/images/webgl6/matrix01.gif" alt="matrix 변환"></p><p>위의 공식은 GLSL에서는 아래와 같이 사용합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mat4 Matrix;</span><br><span class="line">vec4 Vector;</span><br><span class="line"></span><br><span class="line">vec4 transformedVector = Matrix * Vector;</span><br></pre></td></tr></table></figure><p>이처럼 저희는 변형된 버텍스 값을 사용하게되며,<br>앞서 말했던 (x,y,z,w) 벡터에 대해 설명하기 위해<br>이해하기 쉬운 평행이동 행렬에 대해 설명하겠습니다.</p><h4 id="평행이동-행렬"><a href="#평행이동-행렬" class="headerlink" title="평행이동 행렬"></a>평행이동 행렬</h4><p><img src="/images/webgl6/matrix02.png" alt="matrix 변환"></p><p>위의 행렬이 평행이동 행렬입니다.<br>X,Y,Z에 있는 것들이 자신의 위치에서 더하고자 하는 값입니다.</p><p><img src="/images/webgl6/matrix03.png" alt="matrix 변환"></p><p>자신을 X 방향으로 20만큼 평행이동 시키면 위와 같이 계산을 하게되고,<br>결과는 벡터 ( 10, 10, 10, 1 )을 X 방향으로 20 이동시킨<br>( 30, 10, 10, 1 ) 벡터값을 얻게 됩니다.<br><code>(w = 1 일때 x 방향으로 이동하였으므로 위치가 변경되었습니다.)</code></p><p><img src="/images/webgl6/matrix04.png" alt="matrix 변환"></p><p>자신을 X 방향으로 20만큼 평행이동 시키면 위와 같이 계산을 하게되고,<br>결과는 벡터 ( 0, 0, -1, 0 )을 X 방향으로 20 이동시켰으나<br>변함이 없는 ( 0, 0, -1, 0 ) 벡터값을 얻게 됩니다.<br><code>(w = 0 일때 x 방향으로 이동하였으나 변화가 없습니다.)</code><br><code>이유는 바로 점은 이동하면 다른 좌표값을 갖는 점이 되지만 벡터는 이동한다고 방향이나 크기가 변하지 않기 때문입니다</code></p><h4 id="단위-행렬"><a href="#단위-행렬" class="headerlink" title="단위 행렬"></a>단위 행렬</h4><p>단위 행렬은 주 대각선이 1이고 나머지가 0인 행렬이고, 아무것도 하지않는 행렬입니다.</p><p><img src="/images/webgl6/matrix05.png" alt="matrix 변환"></p><p>단위행렬에 벡터값(x, y, z, w)을 곱하면 벡터값 자신이 나오기 때문에 아무것도 하지 않습니다.</p><p>이를 이용하여 우리는 scale 매트릭스, translate 매트릭스, rotate 매트릭스등을 활용할 수 있습니다.<br>예를 들어 scale 매트릭스는 아래의 그림과 같습니다.</p><h4 id="Scale-행렬"><a href="#Scale-행렬" class="headerlink" title="Scale 행렬"></a>Scale 행렬</h4><p><img src="/images/webgl6/matrix06.png" alt="matrix 변환"></p><p>벡터값을 모든방향으로 2배 scale하려면</p><p><img src="/images/webgl6/matrix07.png" alt="matrix 변환"></p><p>벡터값의 x,y,z가 아닌 scale 매트릭스의 x,y,z값을 2배로 주면 벡터값이 2배가 되고,<br>실제 코드에선 아래와 같이 사용됩니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mat4.scale(mvMatrix, [<span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">2.0</span>]);</span><br><span class="line"><span class="comment">// 스캐일 매트릭스 사용법</span></span><br></pre></td></tr></table></figure><p>!! 만약 scale, translate, rotate를 같이 사용할때는 꼭 순서를 지켜서 사용하여야 합니다.<br>순서는 translate -&gt; rotate -&gt; scale</p><p>위와 같이 단위 행렬, 평행이동 행렬, Scale 행렬 등 여러 행렬을 따로 구현 하는 것 보다는<br>이미 나와있는 기존의 라이브러리를 활용하는 것이 좋습니다.</p><p>우리는 gl-matrix라는 라이브러리를 사용하려고 하고,<br>해당 라이브러리의 주소는 <a href="http://glmatrix.net" target="_blank" rel="noopener">http://glmatrix.net</a> 입니다.</p><p>해당 페이지의 내용과 이미지의 출처는<br><a href="https://webglfundamentals.org/" target="_blank" rel="noopener">https://webglfundamentals.org/</a> 입니다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-6-Martrix&quot;&gt;&lt;a href=&quot;#WebGL-6-Martrix&quot; class=&quot;headerlink&quot; title=&quot;WebGL ( 6 - Martrix )&quot;&gt;&lt;/a&gt;WebGL ( 6 - Martri
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL 기초( 5 - 도형 이동 )</title>
    <link href="http://shs400.github.io/2018/11/01/WebGL-5/"/>
    <id>http://shs400.github.io/2018/11/01/WebGL-5/</id>
    <published>2018-11-01T07:58:46.000Z</published>
    <updated>2019-01-23T07:21:33.838Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-기초-5-도형-이동"><a href="#WebGL-기초-5-도형-이동" class="headerlink" title="WebGL 기초( 5 - 도형 이동 )"></a>WebGL 기초( 5 - 도형 이동 )</h1><p>이번에는 삼각형에 움직임을 추가해보려고 합니다.</p><p>이를 위해서 애니메이션 루프를 설정해야하는데<br>setTimeout 이나 setInterveal 보다 requestAnimationFrame 활용할 예정입니다.</p><p>앞의 두 메서드가 아닌 requestAnimationFrame 사용하려는 이유는<br>좀 더 정확하고, 다른 브라우저 탭을 보고 있는 동안에는 씬에 애니메이션을 적용하지 않기 때문입니다.<br>( 예외로 requestAnimationFrame 사용하면 모바일 기기에서 불필요한 배터리 수명을 줄일 수 있다고 합니다.)</p><p>애니메이션을 만들게 될때 씬의 뷰를 움직이는 방법이있는데,<br>현재는 뷰를 조절하는 법을 모르기때문에 모델의 좌표계를 수정하여 움직임을 주도록 작성하였습니다.</p><p>requestAnimationFrame 지원이 브라우저마다 다르기때문에<br>사용항 브라우저에서 지원되는지를 확인하고 사용하여야 하거나 polyfill을 통해 수행할 수 있습니다.<br>url : <a href="https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/" target="_blank" rel="noopener">https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// setupWebGL();</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// initShader();</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// setupBuffers();</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// drawScene();</span></span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="comment">// 기존에 init해주던 부분에 animLoop를 호출하여 계속 반복시킵니다.</span></span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="undefined">  initShader();</span></span><br><span class="line"><span class="undefined">  setupBuffers();</span></span><br><span class="line"><span class="javascript">  (<span class="function"><span class="keyword">function</span> <span class="title">animLoop</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">    setupWebGL();</span></span><br><span class="line"><span class="undefined">    setupDynamicBuffers();</span></span><br><span class="line"><span class="undefined">    drawScene();</span></span><br><span class="line"><span class="undefined">    requestAnimationFrame(animLoop, canvas);</span></span><br><span class="line"><span class="undefined">  &#125;)();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>requestAnimationFrame의 첫번째 파라미터는 콜백 함수이고,<br>두번째 인자는 애니메이션의 대상이되는 엘리먼트입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> angle = <span class="number">0.0</span>;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">setupDynamicBuffers</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 변환 범위를 -0.5 ~ 0.5로 제한하기위해 sin 사용</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> x_translation = <span class="built_in">Math</span>.sin(angle)/<span class="number">2.0</span>;</span></span><br><span class="line"><span class="undefined">              </span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> positionsColor = [</span></span><br><span class="line"><span class="javascript">        <span class="number">-0.5</span> + x_translation,  <span class="number">0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 1</span></span></span><br><span class="line"><span class="javascript">        <span class="number">-0.5</span> + x_translation, <span class="number">-0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 2</span></span></span><br><span class="line"><span class="javascript">        <span class="number">0.5</span> + x_translation, <span class="number">-0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 3</span></span></span><br><span class="line"><span class="undefined">      ];</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined">      positionsColorBuffer = gl.createBuffer();</span></span><br><span class="line"><span class="undefined">      gl.bindBuffer(gl.ARRAY_BUFFER, positionsColorBuffer);</span></span><br><span class="line"><span class="javascript">      gl.bufferData(gl.ARRAY_BUFFER, <span class="keyword">new</span> <span class="built_in">Float32Array</span>(positionsColor), gl.DYNAMIC_DRAW);</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> triangleVertices = [</span></span><br><span class="line"><span class="javascript">        <span class="number">-0.5</span> + x_translation,  <span class="number">0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 1</span></span></span><br><span class="line"><span class="javascript">        <span class="number">-0.5</span> + x_translation, <span class="number">-0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 2</span></span></span><br><span class="line"><span class="javascript">        <span class="number">0.5</span> + x_translation, <span class="number">-0.5</span> + x_translation, <span class="comment">//첫번째 삼각형의 정점 3</span></span></span><br><span class="line"><span class="undefined">      ];</span></span><br><span class="line"><span class="undefined">      angle += 0.01;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined">      trianglesVerticeBuffer = gl.createBuffer();</span></span><br><span class="line"><span class="undefined">      gl.bindBuffer(gl.ARRAY_BUFFER, trianglesVerticeBuffer);</span></span><br><span class="line"><span class="javascript">      gl.bufferData(gl.ARRAY_BUFFER, <span class="keyword">new</span> <span class="built_in">Float32Array</span>(triangleVertices), gl.DYNAMIC_DRAW);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>가장 중요한 것은 정점이나 데이터가 변경될때는 정점의 타입을<br>STATIC_DRAW에서 DYNAMIC_DRAW로 바꾸어야한다는 것입니다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/j6p9qozr/embedded/result/dark" frameborder="0" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-기초-5-도형-이동&quot;&gt;&lt;a href=&quot;#WebGL-기초-5-도형-이동&quot; class=&quot;headerlink&quot; title=&quot;WebGL 기초( 5 - 도형 이동 )&quot;&gt;&lt;/a&gt;WebGL 기초( 5 - 도형
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL 기초( 4 - Shader 이해 &amp; 색상 채우기 )</title>
    <link href="http://shs400.github.io/2018/10/31/WebGL-4/"/>
    <id>http://shs400.github.io/2018/10/31/WebGL-4/</id>
    <published>2018-10-31T05:06:29.000Z</published>
    <updated>2019-01-10T01:16:44.877Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-기초-4-Shader-이해-amp-색상-채우기"><a href="#WebGL-기초-4-Shader-이해-amp-색상-채우기" class="headerlink" title="WebGL 기초( 4 - Shader 이해 &amp; 색상 채우기 )"></a>WebGL 기초( 4 - Shader 이해 &amp; 색상 채우기 )</h1><p>이번에는 Shader에서 알아보고<br>삼각형에 색상을 그라이데이션으로 넣어보는 작업을 하도록 하겠습니다.</p><h3 id="Shader의-이해"><a href="#Shader의-이해" class="headerlink" title="Shader의 이해"></a>Shader의 이해</h3><p>GPU는 아래와 같이 2가지 일을 합니다. </p><ol><li>원본의 정점을 클립공간 정점으로 처리</li><li>클립공간을 pixel로 처리</li></ol><p>vertexShader 셰이더와 fragmentShader는 GPU가 이러한 일들을 할 수 있도록<br>명령과 계산된 데이터를 전달하는 기능을 수행합니다. </p><p>먼저 vertex-Shader와 fragment-Shader를 작성해줍니다.<br>(* vertex-Shader : 정점, fragment-Shader : 색상 )</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 버텍스 셰이더 작성 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"shader-vs"</span> <span class="attr">type</span>=<span class="string">"x-shader/x-vertex"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  attribute vec4 aVertexPosition;  </span></span><br><span class="line"><span class="undefined">  uniform mat4 u_matrix;</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="keyword">void</span> main(<span class="keyword">void</span>) &#123;</span></span><br><span class="line"><span class="undefined">    gl_Position = u_matrix * aVertexPosition;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 클립공간은 -1.0 ~ 1.0의 범위 인데 </span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// gl_Position * 0.5 + 0.5 하여 0.0 ~ 1.0 으로 변경하였다.</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> primitiveType = gl.TRIANGLES;</span><br><span class="line"><span class="keyword">var</span> offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">9</span>;</span><br><span class="line">gl.drawArrays(primitiveType, offset, count);</span><br></pre></td></tr></table></figure><p><img src="/images/vertex-shader-anim.gif" alt="버텍스셰이"><br>출처 : webglfundamentals.org</p><p>위의 이미지와 같이 원본 정점 9개를 작성한 vertexShader 함수를 통하여<br>GLSL에서 정의된 변수인 gl_Position에 주면 클립공간 정점으로 GPU에 저장합니다.</p><p>gl.drawArrays() 함수를 호출할 떄 primitiveType을 TRIANGLES로 지정하였기 때문에<br>3개의 클립공간의 정점이 생성될 때마다 GPU는 이를 이용해 삼각형을 그리게 됩니다.</p><p>이 삼각형을 그릴때 아래의 그림과 같이 3개의 정점을 기준으로 래스터화 합니다.</p><ul><li>래스터화 = ‘삼각형을 픽셀로 그림’<br>Ex) <img src="/images/webgl4/webgl4_1.png" alt="정점삼각형"> &gt;&gt; <img src="/images/webgl4/webgl4_2.png" alt="삼각형래스터화"></li></ul><p>래스터화를 할 때 삼각형을 구성하는 각각의 픽셀에 대해서 프래그먼트 셰이더를 호출하게 되는데<br>이때 프래그먼트 셰이더는 특수변수인 gl_FragColor를 통해 각 픽셀의 색상을 알려주게 됩니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 프래그먼트 셰이더 작성 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"shader-fs"</span> <span class="attr">type</span>=<span class="string">"x-shader/x-fragment"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  precision mediump float; <span class="comment">// 실수 정확도</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 낮은 정도의 precision을 가질수록 빠른 렌더 속도를 가지지만 렌더 퀄리가 그만큼 떨어진다.</span></span></span><br><span class="line"><span class="undefined">  varying vec4 v_color;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">void</span> main(<span class="keyword">void</span>) &#123;</span></span><br><span class="line"><span class="javascript">    gl_FragColor = vec4(<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>); <span class="comment">// vec4(R,G,B,A)</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// GLSL의 색상값은 0~1 의 값으로 나타낸다.</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/7osmx9rz/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>이를 응용하면 아래와 같이 응용할 수 있습니다.</p><p>참고)<br>varing은 vertexShader에서 만든 데이터를 에서 fragmentShader에게 전달하는데 사용됩니다.<br>(* varing의 타입과 이름이 동일해야 연결이 됩니다.)</p><ol><li>프래그먼트 셰이더는 래스터화된 점, 선, 면 등을 구성하는 픽셀 수 만큼 호출된다.</li><li>버텍스 셰이더에서 설정한 배어링 값은 선의 경우 2점 보간, 삼각형의 경우 3점 보간을 해서<br>프래그먼트 셰이더에게 전달된다(배어링은 보간되어 전달된다는 점이 중요합니다).</li></ol><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/oct0k29f/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>아래의 그림을 통하여 정점 3개의 삼각형의 v_color가 보간되어 레스터화 되는 동작을 확인할 수 있습니다.</p><iframe src="https://webglfundamentals.org/webgl/lessons/resources/fragment-shader-anim.html" width="400px" height="300px" frameborder="0" allowfullscreen></iframe><p>출처 : [webglfundamentals.org]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-기초-4-Shader-이해-amp-색상-채우기&quot;&gt;&lt;a href=&quot;#WebGL-기초-4-Shader-이해-amp-색상-채우기&quot; class=&quot;headerlink&quot; title=&quot;WebGL 기초( 4 -
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL 기초( 3 - 삼각형 그리기 )</title>
    <link href="http://shs400.github.io/2018/08/08/WebGL-3/"/>
    <id>http://shs400.github.io/2018/08/08/WebGL-3/</id>
    <published>2018-08-08T11:18:53.000Z</published>
    <updated>2019-01-23T07:21:33.845Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-기초-3-삼각형-그리기"><a href="#WebGL-기초-3-삼각형-그리기" class="headerlink" title="WebGL 기초( 3 - 삼각형 그리기 )"></a>WebGL 기초( 3 - 삼각형 그리기 )</h1><p>모든 준비가 완료되었으니 마지막으로 렌더링을 시작하겠습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 클리어 색상을 녹색으로 설정</span></span><br><span class="line">gl.clearColor(<span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.1</span>, <span class="number">1.0</span>);</span><br><span class="line">gl.clear(gl.COLOR_BUFFER_BIT);</span><br></pre></td></tr></table></figure><p>초기화시 클리어 색상값(R,G,B,A)을 정하고 클리어하게되면<br>작성자가 정한 색으로 캔버스의 배경색이 칠해지게 됩니다.</p><p>그 후 WebGL이 앞서 만든 프로그램을 사용가능 하도록 해줍니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 앞장에서 glProgram 이라는 프로그램을 만듬</span></span><br><span class="line"><span class="comment">// 프로그램 사용</span></span><br><span class="line">gl.useProgram(glProgram);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 참조한 위치 애트리뷰트를 사용할 것임을 알려줍니다.</span></span><br><span class="line">gl.enableVertexAttribArray(positionAttributeLocation);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 위치 버퍼를 바인드 합니다.</span></span><br><span class="line"><span class="comment">// 어느 버퍼를 사용할지 바인드 포인트로 지정하는 셈입니다.</span></span><br><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// positionBuffer (ARRAY_BUFFER)에서 데이터를 가져오는</span></span><br><span class="line"><span class="comment">// 방법을 위치 애트리뷰트에게 알려 줌</span></span><br><span class="line"><span class="keyword">var</span> size = <span class="number">2</span>;          <span class="comment">// 각 반복마다 2개씩 버퍼 데이타 참조</span></span><br><span class="line"><span class="keyword">var</span> type = gl.FLOAT;   <span class="comment">// 32bit 부동 소수점 값</span></span><br><span class="line"><span class="keyword">var</span> normalize = <span class="literal">false</span>; <span class="comment">// 데이터를 노말라이즈 하지 않는다.</span></span><br><span class="line"><span class="keyword">var</span> stride = <span class="number">0</span>;        <span class="comment">// 0 = move forward size * sizeof(type) 각 반복마다 다음 위치</span></span><br><span class="line"><span class="keyword">var</span> offset = <span class="number">0</span>;        <span class="comment">// 버퍼 시작 위치</span></span><br><span class="line">gl.vertexAttribPointer(</span><br><span class="line">  positionAttributeLocation,</span><br><span class="line">  size,</span><br><span class="line">  type,</span><br><span class="line">  normalize,</span><br><span class="line">  stride,</span><br><span class="line">  offset</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이제 마지막으로 WebGL 에게 만든 GLSL 프로그램을 실행하라고 요청을 해봅시다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GLSL 프로그램을 실행하도록 요청</span></span><br><span class="line"><span class="keyword">var</span> primitiveType = gl.TRIANGLES;</span><br><span class="line"><span class="keyword">var</span> offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">3</span>;</span><br><span class="line">gl.drawArrays(primitiveType, offset, count);</span><br></pre></td></tr></table></figure></p><p>이제는 아래와 같이 두개의 삼각형이 보이게 될 것입니다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/6szy70u2/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>마지막으로 drawArrays에 사용되는 원시타입에 대해 설명을 하자면</p><p><code>원시 타입(primitiveType)</code><br>원시 타입은 특정 그래픽 언어에서<br>모델을 개발할 때 사용하는 그래픽 구성 요소입니다.<br>웹지엘에는 7개의 원시타입이 있는데<br><img src="/images/primitive_type.png" alt="원시타입"><br><code>좌측 상단부터 우측 하단 순서</code><br>POINTS, LINES, LINE_STRIP, LINE_LOOP,<br>TRIANGLES, TRIANGLE_STRIP, TRIANFLE_FAN 이 있습니다.</p><ul><li><p>POINTS<br>POINTS는 한번에 하나씩 렌더링되는 정점(공간좌표)입니다.<br>(총 정점 : 4개)</p></li><li><p>LINES<br>정점의 쌍을 따라 형태를 이룹니다.<br>두개의 선이 같은 정점을 공유하고 있찌만, 각선은 별로도 정의 되어있습니다.<br>(총 정점 : 6개)</p></li><li><p>LINE_STRIP<br>첫번째 선을 제외하고 각 선의 시작점이 이전 선의 끝점인 정점 컬렉션으로 이뤄집니다.<br>LINE_STRIP에서는 여러 선에서 일부 정점을 재사용합니다.<br>(총 정점 : 5개) </p></li><li><p>LINE_LOOP<br>첫번째 정점과 마지막 정점이 다시 연결돼 닫힌 고리를 형성한다는 점 을 제외하곤 LINE_STRIP과 유사합니다.<br>(총 정점 : 5개)</p></li><li><p>TRIANGLES<br>삼각형당 정점 3개로 이뤄집니다.<br>위 그림에서 삼각형 3개를 그리는데 삼각형별로 정점 3개씩 필요하며,<br>LINES와 마찬가지로 공유된 정점은 우연히 겹쳐 있을 뿐입니다.<br>(총 정점 : 9개)</p></li><li><p>TRIANGLE_STRIP<br>ABC, (BC)D, (CD)E, (DE)F, (EF)G, (FG)H, (GH)I 정점을 통해 형성됩니다.<br>여러 삼각형에서 정점을 재사용 하여 삼각형을 렌더링 합니다.<br>(총 정점 : 9개)</p></li><li><p>TRIANFLE_FAN<br>삼각형의 일부로 지정한 첫번쨰 정점을 사용합니다.<br>첫번째 정점 A는 7번 사용 나머지 정점은 2번씩 사용됩니다.<br>(총 정점 : 8개)</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-기초-3-삼각형-그리기&quot;&gt;&lt;a href=&quot;#WebGL-기초-3-삼각형-그리기&quot; class=&quot;headerlink&quot; title=&quot;WebGL 기초( 3 - 삼각형 그리기 )&quot;&gt;&lt;/a&gt;WebGL 기초( 
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL 기초( 2 - 삼각형 그리기 준비 )</title>
    <link href="http://shs400.github.io/2018/08/08/WebGL-2/"/>
    <id>http://shs400.github.io/2018/08/08/WebGL-2/</id>
    <published>2018-08-08T06:04:46.000Z</published>
    <updated>2019-01-23T07:21:33.849Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-기초-2-삼각형-그리기-준비"><a href="#WebGL-기초-2-삼각형-그리기-준비" class="headerlink" title="WebGL 기초( 2 - 삼각형 그리기 준비 )"></a>WebGL 기초( 2 - 삼각형 그리기 준비 )</h1><p>이번에는 코드를 보며 아래와 같이 삼각형을 만들어보기로 합니다.</p><h3 id="1-셰이더-작성"><a href="#1-셰이더-작성" class="headerlink" title="1 - 셰이더 작성"></a>1 - 셰이더 작성</h3><p>먼저 앞장에서 작업한 버텍스 셰이더와 프래그먼트 셰이더를 작성합니다.</p><h3 id="2-WebGL-렌더링-컨텍스트-생성하기"><a href="#2-WebGL-렌더링-컨텍스트-생성하기" class="headerlink" title="2 - WebGL 렌더링 컨텍스트 생성하기"></a>2 - WebGL 렌더링 컨텍스트 생성하기</h3><p>WebGL 렌더링 컨텍스트는 canvas로부터 얻어올 수 있습니다.</p><p>canvas는 ‘2D’와 ‘webgl’이라는 두개의 캔버스 context가 있습니다.<br>canvas는 둘 중 어떤 컨텍스트를 사용하든 상관하지 않지만<br>원하는 API를 노출하는 적절한 객체를 제공해주려면<br>canvas에게 명시적으로 알려줘야 합니다.</p><p>context를 가져오려면 canvas의 getContext 메소드를 호출하면됩니다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrap'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"my-canvas"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span></span><br><span class="line">      해당 브라우저는 html5 canvas element를 지원하지 않습니다.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> gl = <span class="literal">null</span>,</span></span><br><span class="line"><span class="javascript">      canvas = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">    canvas = <span class="built_in">document</span>.getElementById(<span class="string">'my-canvas'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">try</span>&#123;</span></span><br><span class="line"><span class="javascript">      gl = canvas.getContext(<span class="string">'webgl'</span>) || </span></span><br><span class="line"><span class="javascript">      canvas.getContext(<span class="string">'experimental-webgl'</span>);</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">catch</span> (e)&#123;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>*getContext<br>-첫번째 파라미터 : context이름<br>-두번째 파라미터 : 선택인자</p><h3 id="3-셰이더-컴파일-및-링크-gt-프로그램-생성"><a href="#3-셰이더-컴파일-및-링크-gt-프로그램-생성" class="headerlink" title="3 - 셰이더 컴파일 및 링크 -&gt; 프로그램 생성"></a>3 - 셰이더 컴파일 및 링크 -&gt; 프로그램 생성</h3><p>지금까지 작성한 셰이더를 GPU에서 동작하도록 단계별로 진행합니다.</p><p><strong>1단계</strong><br>정점 셰이더와 프래그먼트 셰이더의 문자열을 가져옵니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vertexShaderSource = <span class="built_in">document</span>.getElementById(<span class="string">"2d-vertex-shader"</span>).text;</span><br><span class="line"><span class="keyword">var</span> fragmentShaderSource = <span class="built_in">document</span>.getElementById(<span class="string">"2d-fragment-shader"</span>).text;</span><br></pre></td></tr></table></figure></p><p><strong>2단계</strong><br>셰이더 생성 및 컴파일을 합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 셰이더 컴파일</span></span><br><span class="line"><span class="keyword">var</span> vertextShader = makeShader(vertexShaderSource, gl.VERTEX_SHADER),</span><br><span class="line">    fragmentShader = makeShader(fragmentShaderSource, gl.FRAGMENT_SHADER);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeShader</span>(<span class="params">src, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> shader = gl.createShader(type);</span><br><span class="line">  gl.shaderSource(shader, src);</span><br><span class="line">  gl.compileShader(shader);</span><br><span class="line">  <span class="keyword">return</span> shader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>3단계</strong><br>2개의 셰이더를 1개의 프로그램에 연결하기<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 프로그램 생성</span></span><br><span class="line"><span class="comment">// 프로그램은 vertexShader,fragmentShader 두쌍을 합쳐서 프로그램이라고 합니다.</span></span><br><span class="line">glProgram = gl.createProgram();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 프로그램에 셰이더 첨부 및 연결</span></span><br><span class="line">gl.attachShader(glProgram, vertexShader);</span><br><span class="line">gl.attachShader(glProgram, fragmentShader);</span><br><span class="line">gl.linkProgram(glProgram);</span><br></pre></td></tr></table></figure></p><p>여기까지가 하나의 GLSL프로그램을 만드는 과정입니다.</p><h3 id="4-셰이더에서-참조할-데이터-넣기"><a href="#4-셰이더에서-참조할-데이터-넣기" class="headerlink" title="4 - 셰이더에서 참조할 데이터 넣기"></a>4 - 셰이더에서 참조할 데이터 넣기</h3><p>이제부터 WebGL API를 사용하여 앞에서 만든 GLSL프로그램에서 참조할 데이터를 넣어줄 것입니다.</p><p>앞에서 만든 GLSL프로그램에서 aVertexPosition 애트리뷰트를 사용하였는데,<br>이 애트리뷰트에서 소비할 데이터를 제공할 버퍼를 만들어 줍니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> triangleVerticeBuffer = gl.createBuffer();</span><br><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, triangleVerticeBuffer);</span><br></pre></td></tr></table></figure></p><hr><p><strong>bindBuffer( target, mybuffer )</strong></p><hr><p>WebGL은 내부에 버퍼를 여러개 생성하고 관리할 수 있습니다.<br>그래서 어떤 버퍼를 사용하고 있는지 일려주어야 하는데, 어떤 버퍼를 사용하고 있다고 가리키는 것을<br><code>바인드 포인트(bind point)</code>라고 합니다.<br>그렇기 때문에 bindBuffer 함수를 실행하면 바인드 포인트는 triangleVerticeBuffer를 가리키게 되고,<br>이후에 제공되는 데이터는 이 바인드 포인트가 가리키는 버퍼에 입력되게 됩니다.</p><p>bindBuffer의 첫번째 인자로는 상수 값<br>ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER 이 들어가는데<br>ARRAY_BUFFER는 타깃 버퍼가 <code>위치 및 색상같은 정점 어트리뷰트</code>에 사용될때,<br>ELEMENT_ARRAY_BUFFER는 타깃 버퍼가 <code>정점 인덱스를 포함할 때</code> 사용합니다.</p><p>그후 bufferData를 통해 GPU에 데이터를 올리게 됩니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> triangleVertices = [</span><br><span class="line">  <span class="comment">// 왼쪽 삼각형</span></span><br><span class="line">  <span class="number">-0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>,</span><br><span class="line">   <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">  <span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0.0</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 오른쪽 삼각형</span></span><br><span class="line">  <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>,</span><br><span class="line">  <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">  <span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0.0</span></span><br><span class="line">];</span><br><span class="line"><span class="comment">// 공간 좌표 (x,y,z)이고 값은 캔버스 크기로부터 -1~1 까지 표현된다.</span></span><br><span class="line">gl.bufferData(gl.ARRAY_BUFFER, <span class="keyword">new</span> <span class="built_in">Float32Array</span>(triangleVertices), gl.STATIC_DRAW);</span><br></pre></td></tr></table></figure></p><p>WebGL은 강력한 형의 값을 요구하기 때문에<br>데이터를 32비트 부동 소수점 형식의 값의 배열로 만들기 위해 Float32Array를 사용해 줍니다.<br>이때 앞에서 정의 한 triangleVerticeBuffer를 인자로 넘기지 않는 이유는<br>이미 바인드 포인트가 triangleVerticeBuffer를 가리키고 있기때문 입니다.</p><hr><p><strong>bufferData( target, data, usage )</strong></p><hr><p>bufferData 호출에서 세번째 파라미터 usage(용법)는 3가지가 존재하는데,<br>최적화와 관련된 상수라고 합니다.(파악안됨..)</p><ul><li><p>STATIC_DRAW<br>데이터를 한번만 설정하고 애플리케이션이 여러번 사용하는 동안 다시 변경하지 않습니다.</p></li><li><p>DYNAMIC_DRAW<br>애플리케이션에서 데이터를 여러번 사용하지만 매번 내용을 재설정합니다.</p></li><li><p>STREAM_DRAW<br>데이터를 변경하지 않습니다.</p></li></ul><h3 id="5-애트리뷰트-참고하기"><a href="#5-애트리뷰트-참고하기" class="headerlink" title="5 - 애트리뷰트 참고하기"></a>5 - 애트리뷰트 참고하기</h3><p>마지막으로 앞서 만든 GLSL 프로그램에서 애트리뷰트로 aVertexPosition이 사용되는데,<br>WebGL API를 통하여 프로그램에 정의된 애트리뷰트의 위치를 얻어옵니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var positionAttributeLocation = gl.getAttribLocation(program, &quot;aVertexPosition&quot;);</span><br></pre></td></tr></table></figure><p>getAttribLocation()함수를 이용해 프로그램의 a_position 애트리뷰트의 위치를 참조했습니다.</p><p>셰이더 컴파일 및 링크, 데이터를 버퍼에 제공, 애트리뷰트의 위치를 참조까지 완료하면<br>삼각형을 그리기 위한 준비가 완료됩니다.</p><p>이 과정은 초기화 과정으로 전체 코드 동작중 한번만 실행하도록 해야한다고 합니다.</p><p>다음 장에서는 WebGL 기초 마지막으로<br>삼각형을 그려보도록 하겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-기초-2-삼각형-그리기-준비&quot;&gt;&lt;a href=&quot;#WebGL-기초-2-삼각형-그리기-준비&quot; class=&quot;headerlink&quot; title=&quot;WebGL 기초( 2 - 삼각형 그리기 준비 )&quot;&gt;&lt;/a&gt;W
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>WebGL 기초( 1 - 시작 )</title>
    <link href="http://shs400.github.io/2018/08/06/WebGL-1/"/>
    <id>http://shs400.github.io/2018/08/06/WebGL-1/</id>
    <published>2018-08-06T07:28:35.000Z</published>
    <updated>2019-01-23T07:21:33.833Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="WebGL-기초-1-시작하기"><a href="#WebGL-기초-1-시작하기" class="headerlink" title="WebGL 기초( 1 - 시작하기 )"></a>WebGL 기초( 1 - 시작하기 )</h1><p>기초에서는 삼각형을 그리는것을 목표로 합니다.</p><p>우선 WebGL은 래스터화 엔진 중 하나입니다.<br>래스터화는 벡터 또는 윤곽선 데이터를 비트맵으로 바꾸는 과정을 의미합니다.<br>개발자는 WebGL 3D API를 사용해 코드를 작성하면 점, 선, 도형 등을 그릴 수 있습니다.</p><p>WebGL은 컴퓨터의 GPU(Graphic Processing Unit)에서 운영됩니다.<br>그래서 GPU에 실행명령을 수행하기 위해 셰이더가 필요하고<br>그 셰이더에는 2개의 함수가 제공되는데,<br>각각을 <code>정점 셰이더(or 버텍스 셰이더)</code>, <code>프래그먼트 셰이더(or 픽셀 셰이더)</code> 라고합니다.</p><p>이 셰이더 함수들은 GLSL(GL Shader Language)라고 하는 C/C++ 언어로 작성할 수 있습니다.<br>(GLSL에 대해서는 후에 설명)</p><h2 id="셰이더-Shader"><a href="#셰이더-Shader" class="headerlink" title="셰이더(Shader)"></a>셰이더(Shader)</h2><p>셰이더란 화면에 출력할 픽셀의 위치와 색상을 계산하는 함수입니다.</p><p>정점은 셰이더로 넘겨줄 수 있는 어트리뷰트를 갖고 있습니다.<br>또한 각 정점별로 일정한 유니폼 값도 셰이더로 넘겨 줄 수 있는데,<br>자세한 내용은 뒤에 다루기로 하겠습니다.</p><p>지금은 셰이더엔 <code>정점 셰이더</code>와 <code>프래그먼트 셰이더</code>가 있고,<br>하는일은 아래와 같다는 정도만 알고 있기로 합니다.</p><ul><li>정점(vertex) 셰이더 : 정점의 최종 위치를 설정</li><li>프래그먼트 셰이더 : 각 픽셀의 최종 색상을 설정</li></ul><p>화면안의 그려줄 영역의 위치를 계산해 주는 함수를 정점 셰이더라고 하고,<br>영역안의 픽셀들마다 색상을 계산해서 그려주는 함수를<br>프래그먼트 셰이더(픽셀 셰이더) 라고합니다.</p><p><img src="/images/shader.png" alt="셰이더과정"><br>이미지 출처 : [<a href="https://github.com/ejonghyuck/TIL/blob/master/Shader/shader.md]" target="_blank" rel="noopener">https://github.com/ejonghyuck/TIL/blob/master/Shader/shader.md]</a></p><h2 id="셰이더가-참고할-데이터를-제공하는-방법"><a href="#셰이더가-참고할-데이터를-제공하는-방법" class="headerlink" title="셰이더가 참고할 데이터를 제공하는 방법"></a>셰이더가 참고할 데이터를 제공하는 방법</h2><p>셰이더는 GPU에 공급된 데이터로 어떻게 그림을 그리는지 GPU에 시킬 명령들을 선언한 함수일뿐입니다.<br>함수를 실행하기 전에 셰이더가 그림을 그리기 위한 데이터를 GPU에 제공해야하는데</p><p>방법으로는 4가지가 있습니다.</p><ol><li><p>애트리뷰트<br>애트리뷰트는 버터를 사용합니다.<br>버퍼 : 개발자가 GPU에 올려줄 바이너리 배열 데이터입니다.<br>또한 애트리뷰트는 vertex shader에서만 사용되며 읽기 전용 값 입니다.</p></li><li><p>유니폼<br>유니폼은 셰이더 실행하기 전에 정의하는 전역 변수입니다.<br>이 전역 변수에 변환 행렬 정보나 특정 필터 정보 또는 뷰포트 정보 등을 정의해두면 셰이더가 이 변수의 데이타를 참고할 수 있습니다.<br>JavaScript에서 uniformMatrix#fv()를 통해 전달 받은 값을 저장하며 주로 변형(이동, 회전, 스케일)을 계산하기 위한 벡터가 넘어옴</p></li><li><p>텍스쳐<br>텍스처는 셰이더에서 무작위로 접근이 가능한 배열로 된 데이타입니다.<br>텍스처는 보통 이미지 데이터라고 생각할 수 있지만 텍스처 자체는 단순한 데이타이기 때문에 색상 뿐아니라 다른 것도 쉽게 추가시킬 수 있습니다.</p></li><li><p>배어링<br>버텍스 셰이더에서 만든 데이터를 프래그먼트 셰이더에게 전달하는데 쓰입니다.<br>vertex shader에서 계산된 값을 fragment shader로 전달해 줄 때 사용합니다.</p></li></ol><p>Ex) 버텍스 셰이더와 프래그먼트 셰이더<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>WebGL<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  body &#123; background: grey; &#125;</span></span><br><span class="line"><span class="undefined">  canvas &#123; background: white; &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 캔버스 정의 - WebGL의 결과 랜더링 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"my-canvas"</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"500"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- 버텍스 셰이더 작성 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"shader-vs"</span> <span class="attr">type</span>=<span class="string">"x-shader/x-vertex"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    attribute vec3 aVertexPosition;</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="undefined">    void main(void) &#123;</span></span><br><span class="line"><span class="undefined">      gl_Position = vec4(aVertexPosition, 1.0);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 프래그먼트 셰이더 작성 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"shader-fs"</span> <span class="attr">type</span>=<span class="string">"x-shader/x-fragment"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    void main(void) &#123;</span></span><br><span class="line"><span class="undefined">      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>코드를 보시면 각 셰이더에서<br>type 은 text/javascript가 아닌 임의의 값을 주면 됩니다.<br>이유는 셰이더가 javascript로 해석되지 않도록 하는 것이 목적이기 때문입니다.</p><p>셰이더에서 <code>attribute vec3 aVertexPosition</code> 는<br>attribute : 셰이더 변수 종류( attribute | uniform | varying )<br>vec3 : 배열 타입, vec3는 3행 배열<br>aVertexPosition : 배열 이름, 한 개의 버텍스를 나타냅니다. 관습적으로 맨 앞에 a를 붙여서 attribute임을 표시를 나타냅니다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/4ntr3obg/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>WebGL의 기본이 되는 canvas는 HTML5 스펙입니다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"my-canvas"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span></span><br><span class="line">    해당 브라우저는 html5 canvas element를 지원하지 않습니다.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="기본-canvas-화면"><a href="#기본-canvas-화면" class="headerlink" title="기본 canvas 화면"></a>기본 canvas 화면</h2><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/jr0xw1zg/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>※ html5 canvas 미지원시<br>‘해당 브라우저는 html5 canvas element를 지원하지 않습니다.’를 출력합니다.</p><h2 id="WebGL-기초"><a href="#WebGL-기초" class="headerlink" title="WebGL 기초"></a>WebGL 기초</h2><p>canvas는 ‘2D’와 ‘webgl’이라는 두개의 캔버스 context가 있습니다.</p><p>canvas는 둘 중 어떤 컨텍스트를 사용하든 상관하지 않지만<br>원하는 API를 노출하는 적절한 객체를 제공해주려면<br>canvas에게 명시적으로 알려줘야 합니다.</p><p>context를 가져오려면 canvas의 getContext 메소드를 호출하면됩니다.</p><ul><li>getContext</li></ul><ul><li>첫번째 파라미터 : context 타입 </li><li>두번째 파라미터 : context 속성</li></ul><p>Ex) canvas.getContext(‘experimental-webgl’, {<br>  antialias: false, // 앤티 앨리어싱을 수행할지 여부를 나타내는 부울 값입니다.<br>  depth: false  // 캔버스에 알파 버퍼가 있는지 여부를 나타내는 부울입니다.<br>});<br>// experimental-webgl은 WebGL이 정식으로 지원되지 않을 때 사용되던 이름</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = setupWebGL;</span><br><span class="line"><span class="keyword">var</span> gl = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// gl 은 웹지엘에서 컨텍스트 객체를 참조할 떄 관례적으로 사용하는 변수명</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupWebGL</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"my-canvas"</span>);</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    gl = canvas.getContext(<span class="string">'experimental-webgl'</span>);</span><br><span class="line">  &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">    <span class="comment">//컨텍스트 가져오지 못하여 에러 발생시  </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(gl)&#123;</span><br><span class="line">    gl.clearColor(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// clearColor(R,G,B,A)</span></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">'WebGL 지원 안함'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/tLpjk184/embedded/result/dark" frameborder="0" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;h1 id=&quot;WebGL-기초-1-시작하기&quot;&gt;&lt;a href=&quot;#WebGL-기초-1-시작하기&quot; class=&quot;headerlink&quot; title=&quot;WebGL 기초( 1 - 시작하기 )&quot;&gt;&lt;/a&gt;WebGL 기초( 1 - 시작하기 
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
      <category term="webgl" scheme="http://shs400.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 Transform</title>
    <link href="http://shs400.github.io/2018/06/07/CSS3-Study/"/>
    <id>http://shs400.github.io/2018/06/07/CSS3-Study/</id>
    <published>2018-06-07T00:46:00.000Z</published>
    <updated>2019-01-23T07:20:30.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="transform-화면-변형"><a href="#transform-화면-변형" class="headerlink" title="transform (화면 변형)"></a>transform (화면 변형)</h1><p>transform은 엘리먼트의 크기, 위치, 모양을 변경하는 속성입니다.</p><p>transform 함수들은 transform: scale(2, 0.5)같은 형태로 사용가능<br>다중으로 사용할경우에는 transform: scale(2, 0.5) rotate(45deg) 처럼 사용가능</p><p>X, Y, Z 축의 대한 이미지</p><p><img src="/images/x.gif" alt="x축 회전 이미지"></p><p><img src="/images/y.gif" alt="y축 회전 이미지"></p><p><img src="/images/z.gif" alt="z축 회전 이미지"></p><h2 id="scale-크기변경"><a href="#scale-크기변경" class="headerlink" title="scale - 크기변경"></a>scale - 크기변경</h2><p>2D 크기의 변환 함수.</p><p>Ex1) transform: scale(x,y)<br>y 값이 없을시 x 와 동일값으로 가정하여 계산</p><p>Ex2) transform: scaleX(x)<br>y 값이 없을시 y는 1값으로 가정하여 계산</p><p>Ex3) transform: scaleY(y)<br>x 값이 없을시 x는 1값으로 가정하여 계산</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/wcutdk8f/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="translate-이동"><a href="#translate-이동" class="headerlink" title="translate - 이동"></a>translate - 이동</h2><p>Ex) transform: translate(x,y)<br>좌표 평면에서의 2D 이동.<br>y의 값이 없으면 0으로 가정하여 계산</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/5zwejxg6/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="rotate-회전하기"><a href="#rotate-회전하기" class="headerlink" title="rotate - 회전하기"></a>rotate - 회전하기</h2><p>Ex) transform: rotate(angle)<br>요소를 자신의 원점(또는 transform-origin 속성에 설정된 지점)을 기준으로<br>angle 각도만큼 시계방향으로 회전시킨다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/kf3cxygv/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>transform-origin은 rotate(), skew() 등의<br>회전, 변형 속성을 사용하기 전에 기준점을 정해 두는 것이고<br>디폴트 값은 (50%, 50%)입니다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/h0ey5fcd/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="skew-기울이기"><a href="#skew-기울이기" class="headerlink" title="skew - 기울이기"></a>skew - 기울이기</h2><p>Ex) transform: skew(angleX, angleY)<br>요소에 x,y 축을 중심으로 각 angle 각도 만큼 기울인다.<br>angleY 값이 없으면 Y축 연산은 하지않는다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/e1wohf3v/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="matrix"><a href="#matrix" class="headerlink" title="matrix"></a>matrix</h2><p>Ex1) transform: matrix(1,2,3,4,5,6)<br>Ex2) matrix(scaleX(), skewY(), skewX(), scaleY(), translateX(), translateY());<br>martrix는 다른 함수들의 기초가 되는 함수입니다.<br>그래서 matrix를 제대로 쓸 줄 알면 다른 transform 함수들을 조합해서<br>사용하는 것보다 간결하게 작성할 수 있습니다.</p><p><img src="/images/matrix.png" alt="matrix 정보 이미지"></p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/6gj943kp/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="perspective-시점-또는-관찰자-관점-원근감-깊이감"><a href="#perspective-시점-또는-관찰자-관점-원근감-깊이감" class="headerlink" title="perspective - 시점(또는 관찰자 관점,원근감,깊이감)"></a>perspective - 시점(또는 관찰자 관점,원근감,깊이감)</h2><p>원근감을 제어합니다.<br>값이 작을 수록 가까이에서 보는 것 같이 느껴지고 3D 효과도 커집니다.</p><p>쉽게 표현하자면 멀리 떨어져있는것은 작게만들고<br>가까운곳에 있는것은 크게만들어서 원근감을 부여하는것입니다.<br>perspective() 함수를 이용해서 transform 속성에 지정할 수도 있고<br>perspective 속성을 이용해서 부모요소에 지정할 수도 있습니다.<br>부모요소에 지정할 경우 자식요소들이 동일한 소실점을 갖습니다.</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/u5gvdzy9/embedded/result/dark" frameborder="0" allowfullscreen></iframe><h2 id="부모-perspective-와-자식-perspective-차이"><a href="#부모-perspective-와-자식-perspective-차이" class="headerlink" title="부모 perspective 와 자식 perspective 차이"></a>부모 perspective 와 자식 perspective 차이</h2><iframe scrolling="no" width="100%" height="600" src="//jsfiddle.net/enphb0fw/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>부모요소에 perspective을 주면<br>원근감이 개별적이지않고 전체적으로 영향을 주기때문에 각각의 요소의 변형이 다르게 나타난다.</p><p>하지만 자식요소에  perspective을 주면<br>요소마다 개별적으로 영향을 주기때문에 각각의 요소의 변형이 동일하다.</p><h2 id="perspective-와-translateZ"><a href="#perspective-와-translateZ" class="headerlink" title="perspective 와 translateZ"></a>perspective 와 translateZ</h2><iframe scrolling="no" width="100%" height="700" src="//jsfiddle.net/2kaw5fgu/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p><img src="/images/perspective.png" alt="원근감 이해 이미지"></p><h2 id="translate-와-rotate-동시-변화-및-순서-변경"><a href="#translate-와-rotate-동시-변화-및-순서-변경" class="headerlink" title="translate 와 rotate 동시 변화 및 순서 변경"></a>translate 와 rotate 동시 변화 및 순서 변경</h2><iframe scrolling="no" width="100%" height="700" src="//jsfiddle.net/zs8mL5w1/embedded/result/dark" frameborder="0" allowfullscreen></iframe><p>결과가 다른이유는 축을 기점으로 이동하기 때문이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;transform-화면-변형&quot;&gt;&lt;a href=&quot;#transform-화면-변형&quot; class=&quot;headerlink&quot; title=&quot;transform (화면 변형)&quot;&gt;&lt;/a&gt;transform (화면 변형)&lt;/h1&gt;&lt;p&gt;transform은 엘리먼
      
    
    </summary>
    
      <category term="css" scheme="http://shs400.github.io/categories/css/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/css/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/css/blog/study/"/>
    
    
      <category term="css" scheme="http://shs400.github.io/tags/css/"/>
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>javascript - call(),apply(), bind() 메서드</title>
    <link href="http://shs400.github.io/2018/01/02/script-study03/"/>
    <id>http://shs400.github.io/2018/01/02/script-study03/</id>
    <published>2018-01-02T07:43:50.000Z</published>
    <updated>2019-01-22T08:53:43.928Z</updated>
    
    <content type="html"><![CDATA[<p>call(),apply(), bind() 메서드<br><!-- excerpt --></p><p>앞서 설명하였던 기본적인 this 바인딩 3가지 방법 외에도<br>메서드를 이용하여 임의적으로 특정 객체에 바인딩 시키는 방법이 3가지 존재한다.</p><p>1) apply() 메서드</p><ul><li>apply은 파라미터 중 첫 번째 인자를 함수 내부에서 사용할 this로 만들어준다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Name = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objName = &#123;&#125;</span><br><span class="line">Name.apply(objName,[<span class="string">'sim'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(objName);</span><br><span class="line"><span class="comment">//&#123; name: 'sim' &#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>2) call() 메서드</p><ul><li>call은 apply와 기능은 같지만, 두번째 매개변수가 배열이 아닌 각각의 값으로 넘길 수 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Name = <span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objName = &#123;&#125;</span><br><span class="line">Name.call(objName,<span class="string">'sim'</span>,<span class="number">31</span>);</span><br><span class="line"><span class="built_in">console</span>.log(objName);</span><br><span class="line"><span class="comment">//&#123; name: 'sim', age: 31&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>3) bind() 메서드 ※ es5 문법</p><ul><li>함수가 가리키는 this만 바꾸고 호출하지는 않음.</li><li>새 함수를 만드는데 그 this는 bind에 전달된 값. <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"> <span class="keyword">var</span> example = &#123; <span class="attr">color</span> : <span class="string">"blue"</span>&#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">colorValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line"> &#125;</span><br><span class="line">colorValue();</span><br><span class="line"><span class="keyword">var</span> bindColor = colorValue.bind(example);</span><br><span class="line">bindColor();</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure></li></ul><p>colorValue 함수의 this는 window 이므로 red 가 출력되고<br>colorValue에 example 을 bind 해줄시 this가 example 객체를 가리키므로<br>this.color 값은 blue가 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;call(),apply(), bind() 메서드&lt;br&gt;&lt;!-- excerpt --&gt;&lt;/p&gt;
&lt;p&gt;앞서 설명하였던 기본적인 this 바인딩 3가지 방법 외에도&lt;br&gt;메서드를 이용하여 임의적으로 특정 객체에 바인딩 시키는 방법이 3가지 존재한다.&lt;/
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript - this 바인딩</title>
    <link href="http://shs400.github.io/2018/01/02/script-study02/"/>
    <id>http://shs400.github.io/2018/01/02/script-study02/</id>
    <published>2018-01-02T06:54:29.000Z</published>
    <updated>2019-01-22T08:54:12.116Z</updated>
    
    <content type="html"><![CDATA[<p>this 바인딩<br><!-- excerpt --></p><p>this 바인딩은 기본적으로 3가지 유형이 있다.<br>this는 함수가 호출되는 패턴에 따라 this가 어디에 바인딩 되는지 결정된다.</p><ol><li><p>전역함수를 호출할 떄 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="string">'global'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> global = <span class="string">'local'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this.global : '</span>,<span class="keyword">this</span>.global);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this : '</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func();</span><br><span class="line"><span class="comment">// global</span></span><br><span class="line"><span class="comment">// window</span></span><br></pre></td></tr></table></figure></li><li><p>함수가 객체의 속성이고 해당 객체를 통해 함수를 호출할 때</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    func : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.func();</span><br><span class="line"><span class="comment">// object ( obj 객체 )</span></span><br></pre></td></tr></table></figure></li><li><p>생성자 함수(new)를 호출할 때 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name || <span class="string">'empty'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sim = <span class="keyword">new</span> Person(<span class="string">'sim'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sim.name);</span><br></pre></td></tr></table></figure></li></ol><p>이외의 방법으로 call(),apply(), bind() 메서드가 존재한다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;this 바인딩&lt;br&gt;&lt;!-- excerpt --&gt;&lt;/p&gt;
&lt;p&gt;this 바인딩은 기본적으로 3가지 유형이 있다.&lt;br&gt;this는 함수가 호출되는 패턴에 따라 this가 어디에 바인딩 되는지 결정된다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;전역함수를 호출
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript - clouser(클로저)</title>
    <link href="http://shs400.github.io/2017/12/29/script-study01/"/>
    <id>http://shs400.github.io/2017/12/29/script-study01/</id>
    <published>2017-12-29T02:04:32.000Z</published>
    <updated>2019-01-22T08:54:04.480Z</updated>
    
    <content type="html"><![CDATA[<p>clouser(클로저)<br><!-- excerpt --></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> name = <span class="string">'SIM'</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'My name is '</span>+name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myName = outerFunc();</span><br><span class="line">myName(); <span class="comment">// My name is SIM</span></span><br></pre></td></tr></table></figure><p>outerFunc 함수는 함수 내부에 name 지역 변수를 가지고 있고,<br>return 값으로 익명함수(inner함수라고 생각하자)를 가지고 있다.</p><p>아래에서 선언해준 myName 변수에 outerFunc()를 저장한다는 것은<br>myName은 outerFunc 함수의 return 값인 익명함수를 저장한다는 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'My name is '</span>+name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>myName 에는 함수가 담겨있으므로 실행이 가능하고<br>myName()을 호출하면 ‘My name is SIM’ 라는 문자열이 console.log로 인해 출력된다.</p><p>여기서 이상한점은 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'My name is '</span>+name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myName(); <span class="comment">// My name is SIM</span></span><br></pre></td></tr></table></figure><p>이부분에서 myName을 호출할때 익명함수 안의<br>console.log(‘My name is ‘+name) 의 name은 어디에도 존재하지 않는다.<br>그렇다면 당연히 not defined 에러가 나야하지만<br>실행해보면<br>‘My name is SIM’ 을 출력할 것이다.<br>이것이 Clouser(클로저)이다.</p><p>외부함수안의 내부함수를 호출할 때 이미 종료된 외부함수의 환경을 기억하여 사용한다.<br>즉, outerFunc 함수안의 내부함수(위의 예시의 익명함수)를 호출할 때<br>이미 호출되고 종료되어 접근 할 수 없는 outerFunc 함수의 환경을 기억해<br>name 값을 사용하는 것이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;clouser(클로저)&lt;br&gt;&lt;!-- excerpt --&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;
      
    
    </summary>
    
      <category term="javascript" scheme="http://shs400.github.io/categories/javascript/"/>
    
      <category term="blog" scheme="http://shs400.github.io/categories/javascript/blog/"/>
    
      <category term="study" scheme="http://shs400.github.io/categories/javascript/blog/study/"/>
    
    
      <category term="blog" scheme="http://shs400.github.io/tags/blog/"/>
    
      <category term="javascript" scheme="http://shs400.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
